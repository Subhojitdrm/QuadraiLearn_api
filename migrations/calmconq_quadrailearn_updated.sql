-- phpMyAdmin SQL Dump
-- version 5.2.2
-- https://www.phpmyadmin.net/
--
-- Host: localhost:3306
-- Generation Time: Nov 09, 2025 at 04:17 AM
-- Server version: 5.7.44-48
-- PHP Version: 8.3.26

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `calmconq_quadrailearn`
--

-- --------------------------------------------------------

--
-- Table structure for table `books`
--

CREATE TABLE `books` (
  `id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `topic` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `purpose` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `language` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `details` json DEFAULT NULL COMMENT 'Stores context-specific details (e.g., board, class)',
  `preferences` json DEFAULT NULL COMMENT 'Stores user preferences (e.g., includeExercises)',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Dumping data for table `books`
--

INSERT INTO `books` (`id`, `user_id`, `topic`, `purpose`, `language`, `details`, `preferences`, `created_at`, `updated_at`) VALUES
(3, 1, 'java', 'Academic', 'English (Indian)', '{\"type\": \"Academic Details\", \"board\": \"CBSE\", \"class\": \"10\"}', '{\"structure\": \"chapter\", \"includeExercises\": false}', '2025-11-01 12:05:04', '2025-11-01 12:05:04'),
(4, 1, 'Ai in software technology', 'school-project', 'English (Indian)', '{\"figures\": 0, \"subject\": \"software\", \"sections\": [\"Abstract\", \"Introduction\", \"Methodology\", \"Results\", \"Conclusion\", \"Bibliography\"], \"wordTarget\": 1500, \"projectType\": \"Case Study\", \"classOrSemester\": \"Class 10\", \"boardOrUniversity\": \"CBSE\"}', '[]', '2025-11-01 18:21:52', '2025-11-01 18:21:52'),
(5, 1, 'python', 'audience-book', 'English (Indian)', '[]', '[]', '2025-11-01 21:23:58', '2025-11-01 21:23:58'),
(7, 1, 'math', 'audience-book', 'Bengali', '{\"gk\": null, \"tech\": null, \"hobby\": null, \"school\": null, \"nonTech\": null, \"govtExam\": {\"exam\": \"SBI Clerk\"}, \"university\": null}', '[]', '2025-11-04 17:57:38', '2025-11-04 17:57:38'),
(8, 1, 'class 10 Prepositions', 'audience-book', 'English (Indian)', '{\"gk\": null, \"tech\": null, \"hobby\": null, \"school\": null, \"nonTech\": null, \"govtExam\": null, \"university\": null}', '[]', '2025-11-06 19:03:14', '2025-11-06 19:03:14'),
(9, 1, 'math', 'audience-book', 'English (Indian)', '{\"gk\": null, \"tech\": null, \"hobby\": null, \"school\": {\"board\": \"CBSE\", \"class\": \"Class 10\"}, \"nonTech\": null, \"govtExam\": null, \"university\": null}', '[]', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(10, 8, 'math', 'audience-book', 'English (Indian)', '{\"gk\": null, \"tech\": null, \"hobby\": null, \"school\": {\"board\": \"CBSE\", \"class\": \"Class 10\"}, \"nonTech\": null, \"govtExam\": null, \"university\": null}', '[]', '2025-11-08 00:17:55', '2025-11-08 00:17:55');

-- --------------------------------------------------------

--
-- Table structure for table `chapters`
--

CREATE TABLE `chapters` (
  `id` int(11) NOT NULL,
  `book_id` int(11) NOT NULL,
  `chapter_index` int(11) NOT NULL,
  `title` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `generated_content` longtext COLLATE utf8mb4_unicode_ci,
  `status` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'idle' COMMENT '''idle'', ''loading'', ''ready'', ''error''',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Dumping data for table `chapters`
--

INSERT INTO `chapters` (`id`, `book_id`, `chapter_index`, `title`, `generated_content`, `status`, `created_at`, `updated_at`) VALUES
(23, 3, 0, 'Introduction to Java Programming', 'Welcome to the exciting world of Java programming! This chapter serves as your foundational guide, introducing you to the core concepts of programming, Java\'s unique features, and the essential tools you\'ll need to begin your coding journey. We\'ll demystify key terminology, walk you through setting up your development environment, and together, write your very first Java program, establishing a strong base for your learning ahead.\n\n## Fundamentals of Programming\n\nAt its heart, programming is the art of giving instructions to a computer to perform specific tasks. Computers, being machines, need these instructions in a language they can understand. This is where programming languages come into play, acting as a bridge between human thought and machine execution.\n\n### What is Programming?\n\nProgramming involves designing, writing, testing, debugging, and maintaining the source code of computer programs. It\'s about solving problems by breaking them down into smaller, manageable steps, which are then translated into code.\n\n### Basic Programming Concepts\n\nBefore diving into Java, understanding a few fundamental programming concepts is crucial:\n\n*   **Algorithms:** An **algorithm** is a step-by-step procedure or a set of rules used to solve a specific problem. Think of it as a recipe for a computer program.\n*   **Variables:** **Variables** are named storage locations in memory that hold data. They are like containers that can store different types of information, such as numbers, text, or true/false values.\n*   **Data Types:** **Data types** classify the type of data a variable can hold (e.g., integers, floating-point numbers, characters, booleans). This helps the computer understand how to store and manipulate the data.\n*   **Control Structures:** These determine the flow of execution in a program.\n    *   **Sequential:** Instructions are executed one after another.\n    *   **Conditional (Selection):** Allows the program to make decisions based on certain conditions (e.g., `if-else` statements).\n    *   **Iterative (Looping):** Enables the program to repeat a block of code multiple times (e.g., `for` and `while` loops).\n\n### Compilation vs. Interpretation\n\nProgramming languages can be broadly categorised based on how their code is executed:\n\n*   **Compilation:** A **compiler** translates the entire source code into machine code (or an intermediate bytecode) before execution. Java uses a compiler to convert its source code into *bytecode*.\n*   **Interpretation:** An **interpreter** executes the source code line by line without a prior compilation step. Java\'s *bytecode* is then interpreted by the Java Virtual Machine (JVM).\n\n## Key Features and Applications of Java\n\nJava, developed by Sun Microsystems (now Oracle), has consistently been one of the most popular programming languages globally. Its popularity stems from a robust set of features that make it highly versatile.\n\n### Salient Features of Java\n\n*   **Simple:** Java\'s syntax is relatively easy to learn, especially if you have a background in C++ or C. It removes complex features like explicit pointers and operator overloading.\n*   **Object-Oriented:** Java is a purely **object-oriented programming (OOP)** language. This means everything in Java is an object, promoting modularity, reusability, and easier maintenance.\n*   **Platform Independent (WORA):** This is Java\'s most significant feature, encapsulated by the phrase \"**Write Once, Run Anywhere (WORA)**\". Java code is compiled into *bytecode*, which can run on any device that has a Java Virtual Machine (JVM), regardless of the underlying operating system.\n*   **Robust:** Java is designed for reliability. It has strong memory management, automatic garbage collection (which frees up unused memory), and powerful exception handling mechanisms to prevent runtime errors.\n*   **Secure:** Java was designed with security in mind, offering a secure runtime environment. The JVM provides a sandbox environment for running untrusted code.\n*   **Multithreaded:** Java supports **multithreading**, allowing a program to perform multiple tasks concurrently. This enhances application performance and responsiveness.\n*   **High Performance:** While interpreted, Java uses **Just-In-Time (JIT) compilers** within the JVM to convert bytecode into machine code at runtime, leading to high performance, often comparable to compiled languages.\n*   **Distributed:** Java is designed for distributed computing, making it easy to create applications that work across networks.\n\n### Applications of Java\n\nGiven its robust features, Java is used across a vast array of domains:\n\n*   **Enterprise Applications:** Building large-scale, mission-critical applications for businesses (e.g., financial services, supply chain management). Frameworks like Spring and Hibernate are prominent here.\n*   **Android Mobile Development:** Java is the foundational language for developing native Android applications.\n*   **Big Data Technologies:** Many leading Big Data frameworks like Apache Hadoop and Apache Spark are written in Java or Scala (which runs on the JVM).\n*   **Web Applications:** Developing dynamic web applications and backend services (e.g., using servlets, JSP, Spring Boot).\n*   **Scientific Applications:** Used in scientific research for complex calculations and simulations.\n*   **Embedded Systems:** Java ME (Micro Edition) is used for programming devices with limited resources, like smart cards and set-top boxes.\n*   **Desktop Applications:** While less common now, Java Swing and JavaFX can be used for graphical user interface (GUI) desktop applications.\n\n## Understanding JDK, JRE, and JVM\n\nTo truly leverage Java\'s power, it\'s essential to understand the core components that make up its ecosystem: the Java Virtual Machine (JVM), Java Runtime Environment (JRE), and Java Development Kit (JDK).\n\n### JVM (Java Virtual Machine)\n\nThe **Java Virtual Machine (JVM)** is the core component that enables Java\'s platform independence. It is an abstract machine that provides a runtime environment for executing Java bytecode.\n\n*   **Functionality:**\n    *   It interprets the compiled Java bytecode into machine-specific instructions.\n    *   Manages memory (**garbage collection**).\n    *   Handles security by isolating the program from the operating system.\n*   **Key takeaway:** The JVM is where your Java program *runs*. It\'s the \"virtual machine\" that allows the same compiled Java code to execute on different operating systems.\n\n### JRE (Java Runtime Environment)\n\nThe **Java Runtime Environment (JRE)** is a package that provides the minimum requirements for running a Java application. It contains the JVM along with the necessary Java class libraries and other supporting files.\n\n*   **Components:** JVM + Java Class Libraries (e.g., `java.lang`, `java.util`, `java.io`).\n*   **Purpose:** If you only need to *run* Java applications and not develop them, you only need the JRE. End-users typically install JRE.\n\n### JDK (Java Development Kit)\n\nThe **Java Development Kit (JDK)** is the complete software development environment for writing Java applications. It includes the JRE, along with a suite of development tools necessary to compile, debug, and package Java programs.\n\n*   **Components:** JRE + development tools (e.g., `javac` compiler, `javadoc` documentation tool, `jdb` debugger).\n*   **Purpose:** This is what Java developers install on their systems. It allows you to *write* and *compile* Java code, in addition to running it.\n\n**Analogy:**\n*   **JVM** is like the engine of a car. It makes the car run.\n*   **JRE** is like the entire car without the manufacturing tools. You can drive it, but not build or repair it.\n*   **JDK** is like the car along with all the tools needed to design, build, and repair it.\n\n## Setting Up the Java Development Environment\n\nBefore you can start writing Java code, you need to set up your system with the necessary tools. This involves installing the JDK and configuring your environment variables.\n\n### 1. Download and Install JDK\n\nThe first step is to download the appropriate Java Development Kit for your operating system (Windows, macOS, Linux).\n\n*   **Source:** You can download the official Oracle JDK from Oracle\'s website or opt for an OpenJDK distribution (like AdoptOpenJDK/Eclipse Temurin, Amazon Corretto). For learning, any standard JDK will suffice.\n*   **Installation:** Follow the on-screen instructions of the installer. It typically involves accepting license agreements and choosing an installation directory. Remember the installation path (e.g., `C:\\Program Files\\Java\\jdk-17`).\n\n### 2. Set Environment Variables\n\nAfter installation, you need to configure your system\'s environment variables so that the operating system knows where to find Java\'s executable files.\n\n*   **JAVA_HOME:** Create a new system variable named `JAVA_HOME` and set its value to the path of your JDK installation directory (e.g., `C:\\Program Files\\Java\\jdk-17`).\n*   **Path Variable:** Append the `bin` directory of your JDK to the system\'s `Path` variable. This allows you to run Java commands from any directory in your command prompt/terminal.\n    *   Add `%JAVA_HOME%\\bin` (Windows) or `$JAVA_HOME/bin` (Linux/macOS) to the `Path` variable.\n\n### 3. Verify Installation\n\nOnce the environment variables are set, open a new command prompt or terminal and verify the installation:\n\n*   Type `java -version` and press Enter. You should see the installed Java version.\n*   Type `javac -version` and press Enter. This should also display the version of the Java compiler.\n\nIf both commands show the correct version, your Java environment is successfully set up.\n\n### 4. (Optional) Install an Integrated Development Environment (IDE)\n\nWhile you can write Java code using a simple text editor, an **Integrated Development Environment (IDE)** significantly enhances productivity. IDEs provide features like code completion, syntax highlighting, debugging tools, and project management.\n\n*   **Popular Java IDEs:**\n    *   **IntelliJ IDEA:** Highly recommended, offers a robust free Community Edition.\n    *   **Eclipse:** Another powerful and widely used open-source IDE.\n    *   **VS Code:** A lightweight yet powerful editor with excellent Java extensions.\n\nFor your initial programs, a simple text editor and the command line will be sufficient to understand the core processes.\n\n## Writing Your First Java Program: Hello World\n\nIt\'s a tradition in programming to start with a \"Hello World\" program. This simple program will demonstrate the basic steps of writing, compiling, and running a Java application.\n\n### The Code\n\nOpen a text editor (like Notepad, Sublime Text, VS Code, or your chosen IDE) and type the following code exactly as shown:\n\n```java\n// HelloWorld.java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\nSave this file as `HelloWorld.java`. Make sure the filename exactly matches the class name (`HelloWorld`) and has the `.java` extension.\n\n### Understanding the Code\n\nLet\'s break down this simple program:\n\n*   `// HelloWorld.java`: This is a **single-line comment**. Comments are ignored by the compiler and are used to explain the code to humans.\n*   `public class HelloWorld`: This line declares a **class** named `HelloWorld`. In Java, all code resides within classes. `public` means this class can be accessed from anywhere.\n*   `public static void main(String[] args)`: This is the **main method**, which is the entry point of any standalone Java application.\n    *   `public`: Makes the method accessible from outside the class.\n    *   `static`: Allows the method to be called without creating an object of the class.\n    *   `void`: Indicates that the method does not return any value.\n    *   `main`: The method name, which is special; the JVM looks for a method with this name to start execution.\n    *   `(String[] args)`: Parameters passed to the program from the command line, typically an array of strings.\n*   `System.out.println(\"Hello, World!\");`: This statement prints the string \"Hello, World!\" to the console.\n    *   `System`: A predefined class that provides system functionality.\n    *   `out`: A static member of the `System` class, representing the standard output stream.\n    *   `println()`: A method of the `PrintStream` class (accessed via `out`) that prints a string and then moves to the next line.\n\n### Compilation\n\nNavigate to the directory where you saved `HelloWorld.java` using your command prompt or terminal, and execute the Java compiler:\n\n```bash\njavac HelloWorld.java\n```\n\nIf there are no errors, this command will create a file named `HelloWorld.class` in the same directory. This `.class` file contains the **bytecode**, which is understandable by the JVM.\n\n### Execution\n\nNow, run the compiled program using the Java interpreter:\n\n```bash\njava HelloWorld\n```\n\n**Note:** You only specify the class name (`HelloWorld`), not the `.class` extension.\n\n### Expected Output\n\nYou should see the following output in your console:\n\n```\nHello, World!\n```\n\nCongratulations! You\'ve successfully written, compiled, and executed your first Java program.\n\n## Basic Structure of a Java Program\n\nWhile \"Hello World\" was simple, real-world Java programs have a more elaborate structure. Understanding these components is crucial for writing organised and maintainable code.\n\n### 1. Comments\n\n**Comments** are non-executable statements used to explain code. Java supports three types:\n\n*   **Single-line comments:** Start with `//` and continue to the end of the line.\n    ```java\n    // This is a single-line comment\n    ```\n*   **Multi-line comments:** Start with `/*` and end with `*/`. Can span multiple lines.\n    ```java\n    /*\n     * This is a multi-line comment.\n     * It can explain complex blocks of code.\n     */\n    ```\n*   **Javadoc comments:** Start with `/**` and end with `*/`. Used for generating API documentation.\n    ```java\n    /**\n     * This is a Javadoc comment.\n     * It\'s used to document classes, methods, and variables.\n     * @param args Command line arguments\n     */\n    ```\n\n### 2. Package Declaration\n\nA **package** is a mechanism to organise classes and interfaces into logical groups, preventing naming conflicts and improving modularity. The `package` statement must be the first non-comment, non-whitespace statement in a Java source file.\n\n```java\npackage com.mycompany.myapp; // Declares the package for this file\n\n// ... rest of the code\n```\n\n### 3. Import Statements\n\n**Import statements** allow you to use classes and interfaces defined in other packages without having to use their fully qualified names. They typically appear after the package declaration and before any class definitions.\n\n```java\nimport java.util.Scanner; // Imports the Scanner class from java.util package\nimport java.io.*;          // Imports all classes from the java.io package\n\n// ... rest of the code\n```\n\n### 4. Class Declaration\n\nEvery Java program is defined within a **class**. A class is a blueprint for creating objects.\n\n```java\npublic class MyProgram { // Declares a public class named MyProgram\n    // Class members (fields and methods) go here\n}\n```\n\n*   `public`: Access modifier, making the class accessible from anywhere.\n*   `class`: Keyword to declare a class.\n*   `MyProgram`: The name of the class (should follow Java naming conventions, typically PascalCase).\n\n### 5. Main Method\n\nFor any standalone Java application, the **`main` method** serves as the program\'s entry point. The JVM starts execution from this method.\n\n```java\npublic class MyProgram {\n    public static void main(String[] args) { // The main method\n        // Program logic starts here\n        System.out.println(\"Program is running!\");\n    }\n}\n```\n\nWe discussed its components (`public`, `static`, `void`, `main`, `String[] args`) earlier.\n\n### 6. Statements and Blocks\n\n*   **Statements:** These are the executable instructions in a program, ending with a semicolon (`;`).\n    ```java\n    int age = 25; // A statement declaring and initialising a variable\n    System.out.println(\"Age: \" + age); // Another statement\n    ```\n*   **Blocks:** Code enclosed within curly braces `{}` forms a block. Blocks define scope for variables and delineate the body of classes, methods, and control structures (like `if` statements or `for` loops).\n    ```java\n    public void myMethod() { // Method block\n        int x = 10;\n        if (x > 5) { // If-statement block\n            System.out.println(\"x is greater than 5\");\n        }\n    }\n    ```\n\nUnderstanding this basic structure is fundamental as you build more complex Java applications. Each component plays a specific role in organising and executing your code efficiently.', 'ready', '2025-11-01 12:05:04', '2025-11-01 13:18:39'),
(24, 3, 1, 'Data Types, Variables, and Operators', '## Data Types, Variables, and Operators\n\nIn the exciting world of Java programming, understanding how to store and manipulate data is absolutely fundamental. This chapter will take you through the very basics: from defining the kinds of data Java can handle – known as **data types** – to how we name and store these pieces of information using **variables**. We’ll also delve into the powerful **operators** that allow us to perform calculations, comparisons, and logical operations on our data, forming the backbone of any dynamic program. Let\'s get started with these crucial building blocks!\n\n### Primitive Data Types in Java\n\nJava is a **statically-typed language**, which means every variable must have a declared type before it can be used. These types define the kind of values a variable can hold, and how much memory it will occupy. Java offers a set of **primitive data types** that are the fundamental building blocks for storing simple values. They are not objects, which makes them quite efficient.\n\nHere are the 8 primitive data types in Java:\n\n*   **Integer Types**: These are used to store whole numbers (without decimal points).\n    *   `byte`: Stores very small whole numbers, ranging from -128 to 127. It uses 1 byte of memory. Quite handy for saving memory in large arrays.\n    *   `short`: Stores short whole numbers, from -32,768 to 32,767. It uses 2 bytes of memory.\n    *   `int`: The most commonly used integer type. It can store whole numbers from -2,147,483,648 to 2,147,483,647. It uses 4 bytes of memory.\n    *   `long`: Used for very large whole numbers, exceeding the capacity of `int`. It ranges from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. It uses 8 bytes of memory. Remember to suffix `L` or `l` (e.g., `100L`) for `long` literals.\n*   **Floating-Point Types**: These are used to store numbers with decimal points.\n    *   `float`: Stores single-precision floating-point numbers. It\'s good for situations where high precision isn\'t strictly required. Uses 4 bytes. Remember to suffix `F` or `f` (e.g., `3.14F`) for `float` literals.\n    *   `double`: The default choice for decimal numbers, providing double-precision floating-point values. It offers much higher precision than `float`. Uses 8 bytes. Decimal literals are `double` by default.\n*   **Character Type**:\n    *   `char`: Stores a single Unicode character (e.g., \'A\', \'1\', \'$\'). It uses 2 bytes of memory. Character literals are enclosed in single quotes.\n*   **Boolean Type**:\n    *   `boolean`: Stores only two possible values: `true` or `false`. It\'s crucial for decision-making in programs. It uses roughly 1 bit of information, though its exact memory footprint can vary.\n\n### Variables: Declaration, Initialization, and Scope\n\nVariables are essentially named storage locations in memory that hold data. Think of them as labelled boxes where you can keep your data, and the label helps you find and use that data later.\n\n#### Declaration\n\nBefore you can use a variable, you must declare it. This tells the Java compiler its name and what type of data it will store.\n\n**Syntax:**\n`dataType variableName;`\n\n**Example:**\n```java\nint studentAge;        // Declares an integer variable named studentAge\ndouble studentGPA;     // Declares a double variable named studentGPA\nchar initial;          // Declares a character variable named initial\nboolean isActive;      // Declares a boolean variable named isActive\n```\n\n#### Initialization\n\n**Initialization** is the process of assigning a first, or initial, value to a variable. Without initialization, a local variable (variables declared inside a method) will not have a value, and Java will not allow you to use it, leading to a compilation error.\n\n**Syntax:**\n`variableName = value;`\nOr, you can declare and initialize in one go:\n`dataType variableName = value;`\n\n**Example:**\n```java\nint count;             // Declaration\ncount = 100;           // Initialization\n\nString studentName = \"Ravi Sharma\"; // Declaration and Initialization\ndouble price = 99.99;\nboolean isAvailable = true;\n```\n\n#### Scope\n\nThe **scope** of a variable defines the region of the program where that variable is accessible. Once a variable goes out of scope, it can no longer be accessed or used. Understanding scope is quite important for writing correct and bug-free code.\n\nIn Java, there are mainly three types of variable scope:\n\n*   **Local Variables**: These are declared inside a method, constructor, or any block (`{...}`). They are only accessible within that specific block. Once the block\'s execution finishes, the local variables are destroyed.\n    ```java\n    public void calculateSum() {\n        int num1 = 10; // num1 is a local variable\n        if (num1 > 5) {\n            int num2 = 20; // num2 is a local variable, only accessible inside this if block\n            System.out.println(num1 + num2);\n        }\n        // System.out.println(num2); // This would cause a compile-time error! num2 is out of scope.\n    }\n    ```\n*   **Instance Variables (Non-static fields)**: These are declared inside a class but outside any method or block. They belong to an object (instance) of the class. Each object will have its own copy of instance variables. Their scope is throughout the object\'s lifetime.\n*   **Class Variables (Static fields)**: These are declared inside a class, outside any method or block, and are marked with the `static` keyword. They belong to the class itself, not to any specific object. There\'s only one copy of a static variable shared among all objects of that class. Their scope is global to the class.\n\n### Keywords, Identifiers, and Literals\n\nWhen writing Java code, you\'ll constantly deal with these three elements. Let\'s understand them clearly.\n\n#### Keywords\n\n**Keywords** are reserved words in Java that have a predefined meaning to the compiler. You cannot use keywords as names for variables, methods, classes, or any other identifiers. They are case-sensitive, meaning `int` is a keyword, but `Int` is not.\n\n**Examples of Java Keywords:**\n`public`, `static`, `void`, `int`, `if`, `else`, `for`, `while`, `class`, `new`, `this`, `super`, `return`, `true`, `false`, `null`, etc.\n\n#### Identifiers\n\n**Identifiers** are names given by the programmer to elements like variables, methods, classes, packages, etc., to uniquely identify them in the program.\n\n**Rules for creating valid Java Identifiers:**\n\n*   They must begin with a letter (A-Z or a-z), an underscore (`_`), or a dollar sign (`$`).\n*   Subsequent characters can be letters, digits (0-9), underscores, or dollar signs.\n*   Identifiers cannot be Java keywords.\n*   Identifiers are case-sensitive (e.g., `myVar` and `MyVar` are different).\n*   There is no limit on the length of an identifier.\n\n**Naming Conventions (Highly Recommended):**\n\n*   **Variables and Methods**: Start with a lowercase letter, and capitalize the first letter of subsequent words (e.g., `studentName`, `calculateTotal`). This is known as **camelCase**.\n*   **Classes and Interfaces**: Start with an uppercase letter, and capitalize the first letter of subsequent words (e.g., `MyClass`, `ShoppingCart`). This is called **PascalCase** or UpperCamelCase.\n*   **Constants**: Use all uppercase letters, with underscores separating words (e.g., `MAX_VALUE`, `PI`).\n*   **Packages**: Use all lowercase letters (e.g., `com.mycompany.myapp`).\n\n#### Literals\n\n**Literals** are fixed values that are directly represented in your code. They are constant values that don\'t change during program execution.\n\n**Types of Literals:**\n\n*   **Integer Literals**: Whole numbers like `10`, `1000`, `-5`. By default, they are `int` type. If they exceed `int` range, they are `long` if suffixed with `L` (e.g., `1234567890123L`).\n*   **Floating-Point Literals**: Numbers with decimal points like `3.14`, `0.5`, `-10.25`. By default, they are `double` type. For `float` type, suffix with `F` (e.g., `3.14F`).\n*   **Character Literals**: Single characters enclosed in single quotes like `\'A\'`, `\'a\'`, `\'5\'`, `\'$\'`. Special characters like newline `\'\\n\'` are also character literals.\n*   **String Literals**: A sequence of characters enclosed in double quotes like `\"Hello Java\"`, `\"My name is Arjun\"`. Although `String` is a class, string literals are very commonly used.\n*   **Boolean Literals**: The two fixed values are `true` and `false`.\n*   **Null Literal**: Represents the absence of an object reference, written as `null`.\n\n### Arithmetic, Relational, and Logical Operators\n\nOperators are special symbols that perform specific operations on one or more operands (values or variables).\n\n#### Arithmetic Operators\n\nThese are used to perform basic mathematical calculations.\n\n*   `+` (Addition): Adds two operands. `int sum = 5 + 3;` (sum is 8)\n*   `-` (Subtraction): Subtracts the second operand from the first. `int diff = 10 - 4;` (diff is 6)\n*   `*` (Multiplication): Multiplies two operands. `int prod = 6 * 7;` (prod is 42)\n*   `/` (Division): Divides the first operand by the second.\n    *   If both operands are integers, the result is an integer (truncates decimal part). `int result = 10 / 3;` (result is 3)\n    *   If at least one operand is a floating-point type, the result is a floating-point type. `double result = 10.0 / 3;` (result is 3.333...)\n*   `%` (Modulus): Returns the remainder of a division. `int remainder = 10 % 3;` (remainder is 1)\n\n#### Relational Operators\n\nThese operators are used to compare two values. The result of a relational operation is always a **boolean** value (`true` or `false`).\n\n*   `==` (Equal to): Checks if two operands are equal. `boolean check = (5 == 5);` (check is `true`)\n*   `!=` (Not equal to): Checks if two operands are not equal. `boolean check = (5 != 3);` (check is `true`)\n*   `>` (Greater than): Checks if the first operand is greater than the second. `boolean check = (10 > 7);` (check is `true`)\n*   `<` (Less than): Checks if the first operand is less than the second. `boolean check = (4 < 9);` (check is `true`)\n*   `>=` (Greater than or equal to): Checks if the first operand is greater than or equal to the second. `boolean check = (8 >= 8);` (check is `true`)\n*   `<=` (Less than or equal to): Checks if the first operand is less than or equal to the second. `boolean check = (6 <= 10);` (check is `true`)\n\n#### Logical Operators\n\nLogical operators are used to combine or negate boolean expressions. They are vital for creating complex conditional statements.\n\n*   `&&` (Logical AND): Returns `true` only if **both** operands are `true`. Otherwise, it\'s `false`. It performs **short-circuit evaluation** – if the first operand is `false`, it doesn\'t evaluate the second one.\n    `boolean result = (age > 18 && hasLicense);`\n*   `||` (Logical OR): Returns `true` if **at least one** operand is `true`. It\'s `false` only if both are `false`. It also performs **short-circuit evaluation** – if the first operand is `true`, it doesn\'t evaluate the second one.\n    `boolean result = (isStudent || isDiscountEligible);`\n*   `!` (Logical NOT): Inverts the boolean value of its operand. If the operand is `true`, it becomes `false`, and vice-versa.\n    `boolean result = !(isRaining);` (If `isRaining` is `true`, `result` is `false`)\n\n### Assignment and Unary Operators\n\nThese operators are also quite common and simplify many operations in Java.\n\n#### Assignment Operators\n\nThe most basic assignment operator is `=`, which assigns the value of the right operand to the variable on the left.\n\n*   `=` (Simple Assignment): `int x = 10;`\n*   **Compound Assignment Operators**: These combine an arithmetic operator with the assignment operator, providing a shorthand for common operations.\n    *   `+=` (Add and Assign): `x += 5;` is equivalent to `x = x + 5;`\n    *   `-=` (Subtract and Assign): `x -= 3;` is equivalent to `x = x - 3;`\n    *   `*=` (Multiply and Assign): `x *= 2;` is equivalent to `x = x * 2;`\n    *   `/=` (Divide and Assign): `x /= 4;` is equivalent to `x = x / 4;`\n    *   `%=` (Modulus and Assign): `x %= 3;` is equivalent to `x = x % 3;`\n\nThese compound operators are not just for integers; they work with floating-point types as well.\n\n#### Unary Operators\n\nUnary operators operate on a single operand.\n\n*   `+` (Unary Plus): Indicates a positive value (rarely used as numbers are positive by default). `int positiveNum = +5;`\n*   `-` (Unary Minus): Negates an expression or value. `int negativeNum = -10;`\n*   `++` (Increment Operator): Increases the value of a variable by 1.\n    *   **Pre-increment (`++variable`)**: Increments the variable first, then uses its new value in the expression.\n        ```java\n        int a = 5;\n        int b = ++a; // a becomes 6, then b gets 6\n        // Now, a is 6, b is 6\n        ```\n    *   **Post-increment (`variable++`)**: Uses the original value of the variable in the expression first, then increments the variable.\n        ```java\n        int x = 5;\n        int y = x++; // y gets 5, then x becomes 6\n        // Now, x is 6, y is 5\n        ```\n*   `--` (Decrement Operator): Decreases the value of a variable by 1.\n    *   **Pre-decrement (`--variable`)**: Decrements the variable first, then uses its new value.\n    *   **Post-decrement (`variable--`)**: Uses the original value of the variable first, then decrements it.\n\nPre and post increment/decrement can be a bit tricky, so do remember their distinct behaviours!\n\n### Type Conversion and Type Casting\n\nSometimes, you need to convert a value from one data type to another. Java provides mechanisms for this, broadly categorised into type conversion and type casting.\n\n#### Type Conversion (Widening Conversion / Implicit Conversion)\n\n**Type conversion** happens automatically when the target data type can accommodate the source data type\'s value without any loss of information. This is also called **widening conversion** because you\'re converting a smaller range type to a larger range type. It\'s done **implicitly** by the Java compiler.\n\n**Rules for Implicit Conversion:**\n\n*   `byte` can be converted to `short`, `int`, `long`, `float`, `double`.\n*   `short` can be converted to `int`, `long`, `float`, `double`.\n*   `char` can be converted to `int`, `long`, `float`, `double` (its ASCII/Unicode value is used).\n*   `int` can be converted to `long`, `float`, `double`.\n*   `long` can be converted to `float`, `double`.\n*   `float` can be converted to `double`.\n\n**Example:**\n```java\nint myInt = 100;\nlong myLong = myInt;       // int to long, implicit conversion (no data loss)\ndouble myDouble = myLong;  // long to double, implicit conversion\nfloat myFloat = myInt;     // int to float, implicit conversion (potential precision loss, but value fits)\n\nSystem.out.println(myDouble); // Output: 100.0\n```\n\n#### Type Casting (Narrowing Conversion / Explicit Conversion)\n\n**Type casting** is required when you want to convert a value from a larger data type to a smaller data type. This is called **narrowing conversion**, and it might lead to **data loss** or precision loss, as the smaller type might not be able to hold the entire value of the larger type. Therefore, you must perform this conversion **explicitly** using the casting operator `()`.\n\n**Syntax:**\n`targetType variableName = (targetType) sourceVariable;`\n\n**Example:**\n```java\ndouble myDouble = 9.78;\nint myInt = (int) myDouble; // double to int, explicit casting\n\nSystem.out.println(myDouble); // Output: 9.78\nSystem.out.println(myInt);    // Output: 9 (decimal part is truncated)\n\nlong bigLong = 123456789123L;\nint smallInt = (int) bigLong; // long to int, explicit casting (potential data loss)\n\nSystem.out.println(smallInt); // Output: -539222957 (data loss occurred as bigLong was too large for int)\n```\nIt\'s important to be careful with type casting, especially when converting larger integer types to smaller ones, or floating-point types to integers, as you might lose information or get unexpected results.\n\nThis wraps up our foundational understanding of data types, variables, and operators. Mastering these concepts is absolutely crucial as they are the building blocks for every piece of Java code you\'ll write!', 'ready', '2025-11-01 12:05:04', '2025-11-01 14:54:40'),
(25, 3, 2, 'Input and Output Operations', 'This chapter delves into the essential operations of input and output (I/O) within Java programs. Understanding how to take data *into* your program and how to present results *out* of it is fundamental to creating interactive, useful, and user-friendly applications. We\'ll explore the primary tools Java provides for console I/O, allowing your programs to communicate effectively with users and display information clearly.\n\n## Significance of Input-Output in Programs\n\nInput and output operations are the lifeblood of almost any practical program. Without them, a program would be a sealed box, unable to receive instructions or provide results.\n\n*   **Interaction with Users:** I/O allows programs to ask users for information (like their name, age, or preferences) and then use that information to perform tasks. This makes programs dynamic and responsive.\n*   **Receiving Data:** Programs often need to process data from various sources, not just users. This could include reading configurations from files, fetching data from databases, or receiving information over a network. While this chapter focuses on console input, the principles of data reception are broadly similar.\n*   **Displaying Results:** Once a program has performed its computations, it needs a way to present the outcomes. This could be simple text messages, complex data tables, or graphical representations. Clear and understandable output is crucial for a program\'s usability.\n*   **Debugging and Monitoring:** I/O operations, particularly printing messages to the console, are invaluable tools for developers. They allow us to see the state of variables, track program flow, and identify issues during development.\n\nIn essence, I/O transforms a static piece of code into a dynamic entity that can interact with its environment and serve a purpose.\n\n## Using the Scanner Class for Input\n\nIn Java, the **`Scanner` class** is our primary tool for reading input from the console (and other sources like files). It\'s part of the `java.util` package, meaning you\'ll need to import it.\n\nTo use `Scanner`:\n\n1.  **Import the class:** At the top of your Java file, add `import java.util.Scanner;`.\n2.  **Create a `Scanner` object:** Instantiate a `Scanner` object, typically linking it to `System.in`, which represents the standard input stream (usually your keyboard).\n    ```java\n    Scanner inputScanner = new Scanner(System.in);\n    ```\n    Here, `inputScanner` is the name of our `Scanner` object, and `System.in` tells it to read from the console.\n3.  **Read input:** Use various methods of the `Scanner` object to read different types of data.\n4.  **Close the `Scanner`:** It\'s good practice, and often necessary to prevent resource leaks, to close the `Scanner` when you are finished with it.\n    ```java\n    inputScanner.close();\n    ```\n\n**Example:**\n```java\nimport java.util.Scanner; // Don\'t forget this!\n\npublic class MyInputProgram {\n    public static void main(String[] args) {\n        Scanner inputScanner = new Scanner(System.in); // Create a Scanner\n\n        System.out.println(\"What is your name?\");\n        String name = inputScanner.nextLine(); // Read a whole line of text\n\n        System.out.println(\"Hello, \" + name + \"!\");\n\n        inputScanner.close(); // Close the Scanner\n    }\n}\n```\n\n## Reading Different Data Types from Console\n\nThe `Scanner` class provides several convenient methods to read specific data types from the input stream. Each method waits for the user to type something and press Enter before returning the value.\n\nHere are the most commonly used methods:\n\n*   **`next()`**: Reads the **next token** (a sequence of non-whitespace characters) as a `String`. It stops reading when it encounters whitespace (space, tab, newline).\n*   **`nextLine()`**: Reads the **entire line** of input up to the newline character (`\\n`) and returns it as a `String`. It *consumes* the newline character.\n*   **`nextInt()`**: Reads the next token as an `int`.\n*   **`nextDouble()`**: Reads the next token as a `double`.\n*   **`nextBoolean()`**: Reads the next token as a `boolean` (expects \"true\" or \"false\" ignoring case).\n*   **`nextLong()`**: Reads the next token as a `long`.\n*   **`nextFloat()`**: Reads the next token as a `float`.\n*   **`nextShort()`**: Reads the next token as a `short`.\n*   **`nextByte()`**: Reads the next token as a `byte`.\n\n**Important Note on `nextLine()` after `next()`/`nextInt()`/`nextDouble()` etc.:**\nWhen you use methods like `nextInt()`, `nextDouble()`, or `next()`, they read the input value but **do not consume the newline character** that the user types when pressing Enter. If you then call `nextLine()` immediately afterward, `nextLine()` will read that leftover newline character as its input, resulting in an empty string and potentially skipping the actual line you wanted to read.\n\nTo fix this, you can add an extra `inputScanner.nextLine();` call to consume the leftover newline character after reading a numerical value or a single word, before you intend to read a full line of text.\n\n**Example:**\n```java\nimport java.util.Scanner;\n\npublic class DataTypeInput {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.print(\"Enter your age (integer): \");\n        int age = scanner.nextInt(); // Reads an int\n\n        // IMPORTANT: Consume the leftover newline character after nextInt()\n        scanner.nextLine();\n\n        System.out.print(\"Enter your favorite color (single word): \");\n        String color = scanner.next(); // Reads a single word\n\n        // IMPORTANT: Consume the leftover newline character after next()\n        scanner.nextLine();\n\n        System.out.print(\"Enter your full address (full line): \");\n        String address = scanner.nextLine(); // Reads the whole line\n\n        System.out.print(\"Enter your height in meters (decimal): \");\n        double height = scanner.nextDouble(); // Reads a double\n\n        System.out.println(\"\\n--- Your Info ---\");\n        System.out.println(\"Age: \" + age);\n        System.out.println(\"Color: \" + color);\n        System.out.println(\"Address: \" + address);\n        System.out.println(\"Height: \" + height + \" meters\");\n\n        scanner.close();\n    }\n}\n```\n\n## Displaying Output using System.out.print() and println()\n\nDisplaying information to the console is done using the `System.out` object, which represents the standard output stream. There are two primary methods for basic text output:\n\n*   **`System.out.print(value)`**: This method prints the specified `value` to the console **without adding a new line** character at the end. Subsequent output will appear on the same line.\n*   **`System.out.println(value)`**: This method prints the specified `value` to the console and then **appends a new line** character. Subsequent output will start on the next line. You can also call `System.out.println()` with no arguments to simply print a blank line.\n\nBoth methods are overloaded, meaning they can accept various data types (String, int, double, boolean, etc.) as arguments.\n\n**String Concatenation with `+`:**\nYou can combine multiple pieces of information (variables, literal strings, etc.) into a single `String` for output using the `+` operator.\n\n**Example:**\n```java\npublic class BasicOutput {\n    public static void main(String[] args) {\n        String name = \"Alice\";\n        int score = 1500;\n        double temperature = 25.5;\n\n        // Using print()\n        System.out.print(\"Hello, \");\n        System.out.print(name);\n        System.out.print(\"! Your score is \");\n        System.out.print(score);\n        System.out.print(\".\");\n        // All above will be on the same line: Hello, Alice! Your score is 1500.\n\n        // Using println()\n        System.out.println(\"\\n\"); // Prints a new line for spacing\n        System.out.println(\"Welcome to the game!\");\n        System.out.println(\"Current temperature: \" + temperature + \"°C.\"); // Concatenation\n        System.out.println(\"Have a great day, \" + name + \"!\");\n        System.out.println(); // Prints an empty line\n    }\n}\n```\n**Output of the above code:**\n```\nHello, Alice! Your score is 1500.\n\nWelcome to the game!\nCurrent temperature: 25.5°C.\nHave a great day, Alice!\n\n```\n\n## Basic Formatted Output\n\nWhile `print()` and `println()` are great for simple output, `System.out.printf()` (or using `String.format()` with `System.out.print()`) offers more control over how data is displayed, especially for numbers and alignment. The `printf()` method allows you to specify a format string that includes **format specifiers**.\n\n**Common Format Specifiers:**\n\n*   **`%s`**: For Strings\n*   **`%d`**: For integers (decimal whole numbers)\n*   **`%f`**: For floating-point numbers (decimal numbers)\n*   **`%n`**: For a platform-independent new line character (preferred over `\\n` in `printf`)\n*   **`%b`**: For boolean values\n\n**Controlling Precision for Floating-Point Numbers:**\nYou can specify the number of decimal places for `%f` using `%.<precision>f`. For example, `%.2f` will display a float with two decimal places.\n\n**Example:**\n```java\npublic class FormattedOutput {\n    public static void main(String[] args) {\n        String productName = \"Laptop\";\n        int quantity = 2;\n        double unitPrice = 1200.75;\n        double totalPrice = quantity * unitPrice;\n        boolean inStock = true;\n\n        System.out.println(\"--- Store Receipt ---\");\n\n        // Using %s for String, %d for int\n        System.out.printf(\"Product: %s%n\", productName);\n        System.out.printf(\"Quantity: %d units%n\", quantity);\n\n        // Using %.2f for double with 2 decimal places\n        System.out.printf(\"Unit Price: $%.2f%n\", unitPrice);\n        System.out.printf(\"Total Price: $%.2f%n\", totalPrice);\n\n        // Using %b for boolean\n        System.out.printf(\"In Stock: %b%n\", inStock);\n\n        System.out.println(\"---------------------\");\n\n        // Example with padding and alignment (more advanced but good to know)\n        String item1 = \"Pen\";\n        double price1 = 1.99;\n        String item2 = \"Notebook\";\n        double price2 = 5.50;\n\n        System.out.printf(\"%-10s $%.2f%n\", item1, price1); // Left-aligned string, 10 chars wide\n        System.out.printf(\"%-10s $%.2f%n\", item2, price2); // Left-aligned string, 10 chars wide\n    }\n}\n```\n\n**Output of the above code:**\n```\n--- Store Receipt ---\nProduct: Laptop\nQuantity: 2 units\nUnit Price: $1200.75\nTotal Price: $2401.50\nIn Stock: true\n---------------------\nPen        $1.99\nNotebook   $5.50\n```\n\nBy mastering these input and output techniques, you empower your Java programs to become interactive, informative, and truly useful to anyone who uses them.', 'ready', '2025-11-01 12:05:04', '2025-11-01 19:29:06');
INSERT INTO `chapters` (`id`, `book_id`, `chapter_index`, `title`, `generated_content`, `status`, `created_at`, `updated_at`) VALUES
(26, 3, 3, 'Conditional Statements (Decision Making)', 'This chapter delves into the fascinating world of **conditional statements**, also known as **decision-making structures**, which are fundamental to programming. In Java, these constructs empower your programs to execute different blocks of code based on specific conditions, making them dynamic and responsive. We\'ll explore various ways to implement decision logic, from simple `if` statements to more complex `switch` constructs and the concise ternary operator, ensuring your applications can intelligently respond to diverse scenarios.\n\n## Introduction to Decision Control Structures\n\nIn everyday life, we constantly make decisions based on certain conditions. For instance, \"If it\'s raining, I\'ll take an umbrella; otherwise, I\'ll walk.\" Similarly, in programming, we often need our applications to perform different actions depending on whether a particular condition is true or false. This is precisely where **decision control structures** come into play.\n\nThese structures allow the program\'s flow of execution to change based on the evaluation of a Boolean expression (an expression that results in either `true` or `false`). Without decision-making capabilities, programs would execute instructions sequentially, which is often insufficient for real-world applications. Java provides several powerful constructs to handle these scenarios, which we will explore in detail.\n\n## The `if` Statement and its Variants\n\nThe `if` statement is the most basic and fundamental decision-making construct. It allows a specific block of code to be executed *only if* a given condition evaluates to `true`.\n\n### Basic `if` Statement\n\nThe syntax for a basic `if` statement is as follows:\n\n```java\nif (condition) {\n    // Code to be executed if the condition is true\n}\n```\n\nHere:\n*   The `condition` inside the parentheses `()` must be a Boolean expression.\n*   If the `condition` is `true`, the code within the curly braces `{}` is executed.\n*   If the `condition` is `false`, the code within the curly braces `{}` is skipped, and the program continues with the statements following the `if` block.\n\n**Example:**\n\n```java\npublic class IfStatementDemo {\n    public static void main(String[] args) {\n        int age = 20;\n\n        if (age >= 18) {\n            System.out.println(\"You are eligible to vote.\"); // This will be printed\n        }\n        System.out.println(\"Program continues...\");\n    }\n}\n```\n\n**Note:** If the `if` block contains only a single statement, the curly braces `{}` are optional. However, it is considered a **good programming practice** to always use curly braces for improved readability and to prevent logical errors when adding more statements later.\n\n## The `if-else` and `if-else if-else` Ladder\n\nWhile the `if` statement handles a single true condition, often we need to specify an alternative action when the condition is false. This is where `if-else` and the `if-else if-else` ladder come in handy.\n\n### The `if-else` Statement\n\nThe `if-else` statement provides two distinct paths of execution: one for when the condition is `true`, and another for when it\'s `false`.\n\nSyntax:\n\n```java\nif (condition) {\n    // Code to be executed if the condition is true\n} else {\n    // Code to be executed if the condition is false\n}\n```\n\n**Example:**\n\n```java\npublic class IfElseStatementDemo {\n    public static void main(String[] args) {\n        int temperature = 25;\n\n        if (temperature > 30) {\n            System.out.println(\"It\'s a hot day, stay hydrated!\");\n        } else {\n            System.out.println(\"It\'s a pleasant day.\"); // This will be printed\n        }\n    }\n}\n```\n\n### The `if-else if-else` Ladder\n\nWhen you have multiple conditions to check, and each condition leads to a different action, the `if-else if-else` ladder is the perfect solution. It evaluates conditions sequentially from top to bottom. As soon as a condition evaluates to `true`, its corresponding block of code is executed, and the rest of the ladder is skipped. If none of the `if` or `else if` conditions are met, the `else` block (if present) is executed as a default.\n\nSyntax:\n\n```java\nif (condition1) {\n    // Code if condition1 is true\n} else if (condition2) {\n    // Code if condition2 is true (and condition1 was false)\n} else if (condition3) {\n    // Code if condition3 is true (and condition1, condition2 were false)\n} else {\n    // Code if none of the above conditions are true (optional)\n}\n```\n\n**Example:**\n\n```java\npublic class IfElseIfLadderDemo {\n    public static void main(String[] args) {\n        int score = 75;\n        char grade;\n\n        if (score >= 90) {\n            grade = \'A\';\n        } else if (score >= 80) {\n            grade = \'B\';\n        } else if (score >= 70) {\n            grade = \'C\'; // This block will be executed\n        } else if (score >= 60) {\n            grade = \'D\';\n        } else {\n            grade = \'F\';\n        }\n        System.out.println(\"Your grade is: \" + grade); // Output: Your grade is: C\n    }\n}\n```\n\n## Nested `if` Statements for Complex Conditions\n\nSometimes, a decision depends not just on one condition, but on a hierarchy of conditions. In such cases, you can place an `if` (or `if-else` or `if-else if-else`) statement inside another `if` or `else` block. This is known as **nesting `if` statements**.\n\nA nested `if` statement means that an inner `if` condition is checked only if its outer `if` condition is already `true`.\n\nSyntax:\n\n```java\nif (outerCondition) {\n    // Code for outerCondition is true\n    if (innerCondition) {\n        // Code for innerCondition is true (only if outerCondition was also true)\n    } else {\n        // Code for innerCondition is false (only if outerCondition was true)\n    }\n} else {\n    // Code for outerCondition is false\n}\n```\n\n**Example:**\n\nLet\'s say we want to check eligibility for a loan based on age and credit score.\n\n```java\npublic class NestedIfDemo {\n    public static void main(String[] args) {\n        int applicantAge = 25;\n        int creditScore = 720;\n\n        if (applicantAge >= 21) {\n            System.out.println(\"Applicant meets minimum age requirement.\");\n            if (creditScore >= 700) {\n                System.out.println(\"Applicant has an excellent credit score. Loan approved!\"); // This will be printed\n            } else if (creditScore >= 600) {\n                System.out.println(\"Applicant has a good credit score. Loan may require further review.\");\n            } else {\n                System.out.println(\"Applicant\'s credit score is too low. Loan denied.\");\n            }\n        } else {\n            System.out.println(\"Applicant is too young for a loan.\");\n        }\n    }\n}\n```\n\nWhile nested `if` statements can handle complex logic, they can sometimes make code harder to read and debug if too many levels of nesting are used. Often, **logical operators** (`&&` for AND, `||` for OR, `!` for NOT) can be used to combine multiple conditions into a single `if` statement, improving readability for certain scenarios.\n\n## The `switch` Statement and its Applications\n\nThe `switch` statement is another powerful decision-making construct in Java, particularly useful when you need to select one out of many possible code blocks to execute, based on the value of a single variable or expression. It offers a more structured and often more readable alternative to a long `if-else if-else` ladder when dealing with multiple equality checks.\n\n### How `switch` Works\n\nThe `switch` statement evaluates an expression (or variable) and then compares its value against a series of `case` labels. If a match is found, the code block associated with that `case` is executed.\n\nSyntax:\n\n```java\nswitch (expression) {\n    case value1:\n        // Code to execute if expression == value1\n        break; // Important!\n    case value2:\n        // Code to execute if expression == value2\n        break;\n    case value3:\n        // Code to execute if expression == value3\n        break;\n    default:\n        // Code to execute if no case matches (optional)\n        break; // Optional for default if it\'s the last statement\n}\n```\n\nKey points about `switch`:\n*   The `expression` inside `switch()` can be of type `byte`, `short`, `char`, `int`, `String` (since Java 7), `Enum`, or their corresponding wrapper classes (`Byte`, `Short`, `Character`, `Integer`). `long`, `float`, `double`, and `boolean` types are **not** allowed.\n*   Each `case` label must have a unique constant value.\n*   The **`break` statement** is crucial. It terminates the `switch` statement and transfers control to the statement immediately following the `switch` block. **Without `break`, the program will \"fall through\" to the next `case` statement, executing its code even if the case value doesn\'t match.** This is known as **fall-through behaviour** and is a common source of bugs if not intended.\n*   The `default` case is optional. It is executed if none of the `case` values match the `expression`.\n\n### Example:\n\nLet\'s use `switch` to determine the day of the week based on a number.\n\n```java\npublic class SwitchStatementDemo {\n    public static void main(String[] args) {\n        int day = 3;\n        String dayName;\n\n        switch (day) {\n            case 1:\n                dayName = \"Monday\";\n                break;\n            case 2:\n                dayName = \"Tuesday\";\n                break;\n            case 3:\n                dayName = \"Wednesday\"; // This block will be executed\n                break;\n            case 4:\n                dayName = \"Thursday\";\n                break;\n            case 5:\n                dayName = \"Friday\";\n                break;\n            case 6:\n                dayName = \"Saturday\";\n                break;\n            case 7:\n                dayName = \"Sunday\";\n                break;\n            default:\n                dayName = \"Invalid day\";\n                break;\n        }\n        System.out.println(\"Today is: \" + dayName); // Output: Today is: Wednesday\n    }\n}\n```\n\n### Applications of `switch`:\n*   **Menu-driven programs:** Handling user input for menu options.\n*   **State machines:** Implementing different actions based on the current state.\n*   **Categorization:** Assigning items to different categories based on a specific attribute.\n\n## Understanding the Ternary Operator\n\nThe **ternary operator**, also known as the **conditional operator**, is a compact, single-line alternative to a simple `if-else` statement. It\'s called \"ternary\" because it takes three operands.\n\nSyntax:\n\n```java\nvariable = (condition) ? valueIfTrue : valueIfFalse;\n```\n\nHere:\n*   `condition`: A Boolean expression that evaluates to `true` or `false`.\n*   `valueIfTrue`: The value assigned to `variable` if the `condition` is `true`.\n*   `valueIfFalse`: The value assigned to `variable` if the `condition` is `false`.\n\n### Example:\n\nLet\'s find the maximum of two numbers using the ternary operator.\n\n```java\npublic class TernaryOperatorDemo {\n    public static void main(String[] args) {\n        int num1 = 10;\n        int num2 = 25;\n        int max;\n\n        // Using if-else\n        // if (num1 > num2) {\n        //     max = num1;\n        // } else {\n        //     max = num2;\n        // }\n\n        // Using ternary operator (equivalent to the above if-else)\n        max = (num1 > num2) ? num1 : num2;\n\n        System.out.println(\"The maximum number is: \" + max); // Output: The maximum number is: 25\n    }\n}\n```\n\n### Advantages and Considerations:\n*   **Conciseness:** It makes your code more compact for simple conditional assignments.\n*   **Readability (for simple cases):** For straightforward conditions, it can be easier to read than a full `if-else` block.\n*   **Return value:** It always returns a value, which can be directly assigned or used in an expression.\n\nHowever, for complex conditions or multiple statements within the `if` or `else` blocks, using the full `if-else` statement is preferred for clarity and maintainability. Overusing the ternary operator for complex logic can make code harder to understand.', 'ready', '2025-11-01 12:05:04', '2025-11-01 15:03:07'),
(27, 3, 4, 'Iteration Statements (Loops)', 'Namaste students! In the realm of computer programming, we often encounter situations where a particular set of instructions needs to be executed multiple times. Imagine writing a program to print numbers from 1 to 100, or to process marks for 50 students. Writing the same instruction 100 or 50 times would be tedious and inefficient. This is precisely where **iteration statements**, commonly known as **loops**, come to our rescue. This chapter will delve into the fundamental concepts of repetition and explore the different types of iteration statements available in Java, empowering you to write concise and powerful programs for repetitive tasks.\n\n---\n\n## Concept of Repetition and Iteration\n\nIn programming, **repetition** refers to the execution of a block of code multiple times. This is a very common requirement in various programming scenarios. For instance, if you need to:\n*   Display a message five times.\n*   Calculate the sum of all elements in an array.\n*   Validate user input until a correct value is entered.\n*   Generate a series of numbers or patterns.\n\nInstead of writing the same code repeatedly, which is prone to errors and difficult to maintain, we employ **iteration statements** or **loops**.\n\nAn **iteration** refers to a single pass or execution of the statements within a loop. A loop structure automates the process of executing a block of code repeatedly until a specified condition is met. This mechanism significantly reduces code redundancy and enhances program readability and efficiency.\n\n---\n\n## The `for` Loop: Syntax and Execution Flow\n\nThe `for` loop is one of the most widely used iteration statements in Java. It is typically employed when the number of iterations is known beforehand, making it a **definite loop**.\n\n### Syntax of the `for` Loop\n\nThe general syntax for a `for` loop in Java is as follows:\n\n```java\nfor (initialization; condition; update) {\n    // Statements to be executed repeatedly\n}\n```\n\nLet\'s break down each component:\n*   **`initialization`**: This statement is executed only once at the beginning of the loop. It is commonly used to declare and initialize a loop control variable.\n*   **`condition`**: This is a boolean expression that is evaluated before each iteration. If the condition evaluates to `true`, the loop body is executed. If it evaluates to `false`, the loop terminates, and program control moves to the statement immediately following the `for` loop.\n*   **`update`**: This statement is executed after each iteration of the loop body. It is typically used to modify the loop control variable, often incrementing or decrementing it, to eventually make the condition false and terminate the loop.\n\n### Execution Flow of the `for` Loop\n\n1.  The `initialization` expression is executed (once).\n2.  The `condition` is evaluated.\n3.  If the `condition` is `true`:\n    *   The statements inside the loop body are executed.\n    *   The `update` expression is executed.\n    *   Control returns to step 2 (condition evaluation).\n4.  If the `condition` is `false`:\n    *   The loop terminates.\n    *   Program execution continues with the statement immediately after the loop.\n\n### Example: Printing Numbers from 1 to 5\n\n```java\nclass ForLoopExample {\n    public static void main(String[] args) {\n        System.out.println(\"Numbers from 1 to 5:\");\n        for (int i = 1; i <= 5; i++) {\n            System.out.println(i);\n        }\n    }\n}\n```\n\n**Output:**\n```\nNumbers from 1 to 5:\n1\n2\n3\n4\n5\n```\n\nIn this example:\n*   `int i = 1;` is the **initialization**.\n*   `i <= 5;` is the **condition**.\n*   `i++;` is the **update** (increment `i` by 1).\n\n---\n\n## The `while` Loop: Entry-Controlled Iteration\n\nThe `while` loop is another powerful iteration statement in Java. Unlike the `for` loop where the number of iterations is often known, the `while` loop is typically used when the number of iterations is unknown beforehand and depends on a certain condition being met. It is known as an **entry-controlled loop** because the condition is checked at the very beginning, before entering the loop body.\n\n### Syntax of the `while` Loop\n\nThe general syntax for a `while` loop is:\n\n```java\nwhile (condition) {\n    // Statements to be executed repeatedly\n    // Update statement (crucial to avoid infinite loop)\n}\n```\n\n### Execution Flow of the `while` Loop\n\n1.  The `condition` (a boolean expression) is evaluated.\n2.  If the `condition` is `true`:\n    *   The statements inside the loop body are executed.\n    *   The loop control variable (if any) must be updated *within* the loop body.\n    *   Control returns to step 1 (condition evaluation).\n3.  If the `condition` is `false`:\n    *   The loop terminates.\n    *   Program execution continues with the statement immediately after the loop.\n\n**Important Note:** It is crucial to ensure that the loop control variable or some factor affecting the condition is modified inside the loop body. Otherwise, if the condition remains `true` indefinitely, the loop will run forever, leading to an **infinite loop**, which is generally an undesirable situation.\n\n### Example: Printing Numbers from 1 to 5 using `while`\n\n```java\nclass WhileLoopExample {\n    public static void main(String[] args) {\n        System.out.println(\"Numbers from 1 to 5:\");\n        int i = 1; // Initialization outside the loop\n        while (i <= 5) { // Condition\n            System.out.println(i);\n            i++; // Update inside the loop\n        }\n    }\n}\n```\n\n**Output:**\n```\nNumbers from 1 to 5:\n1\n2\n3\n4\n5\n```\n\nIn this example:\n*   `int i = 1;` is the **initialization**.\n*   `i <= 5;` is the **condition**.\n*   `i++;` is the **update**, placed inside the loop body.\n\n---\n\n## The `do-while` Loop: Exit-Controlled Iteration\n\nThe `do-while` loop is another type of indefinite loop, similar to the `while` loop, but with a significant difference: it is an **exit-controlled loop**. This means that the condition is evaluated *after* the loop body has been executed at least once. Therefore, the `do-while` loop guarantees that its statements will be executed at least one time, regardless of whether the initial condition is `true` or `false`.\n\n### Syntax of the `do-while` Loop\n\nThe general syntax for a `do-while` loop is:\n\n```java\ndo {\n    // Statements to be executed repeatedly\n    // Update statement\n} while (condition); // Note the semicolon here!\n```\n\n### Execution Flow of the `do-while` Loop\n\n1.  The statements inside the `do` block (loop body) are executed *first*.\n2.  After the body\'s execution, the `condition` (a boolean expression) is evaluated.\n3.  If the `condition` is `true`:\n    *   Control returns to step 1 (execute the `do` block again).\n4.  If the `condition` is `false`:\n    *   The loop terminates.\n    *   Program execution continues with the statement immediately after the loop.\n\n### Example: Printing Numbers from 1 to 5 using `do-while`\n\n```java\nclass DoWhileLoopExample {\n    public static void main(String[] args) {\n        System.out.println(\"Numbers from 1 to 5:\");\n        int i = 1; // Initialization\n        do {\n            System.out.println(i);\n            i++; // Update\n        } while (i <= 5); // Condition check after execution\n    }\n}\n```\n\n**Output:**\n```\nNumbers from 1 to 5:\n1\n2\n3\n4\n5\n```\n\n### Key Difference: `while` vs. `do-while`\n\n*   **`while` loop (Entry-Controlled)**: The condition is checked *before* the loop body executes. If the condition is initially `false`, the loop body will **never** execute.\n*   **`do-while` loop (Exit-Controlled)**: The loop body executes *at least once*, and then the condition is checked. If the condition is initially `false`, the loop body will still execute one time.\n\nThis makes `do-while` loops suitable for scenarios like menu-driven programs where you always want to display the menu to the user at least once before checking their input, or for input validation where you prompt for input until valid data is provided.\n\n---\n\n## Nested Loops for Pattern Generation and More\n\nSometimes, a programming problem requires one loop to be placed inside another. Such a construct is known as a **nested loop**. In a nested loop, the **inner loop** completes all its iterations for *each single iteration* of the **outer loop**.\n\n### Understanding Nested Loops\n\nConsider an outer loop that iterates `N` times, and an inner loop that iterates `M` times. For every single iteration of the outer loop, the inner loop will execute `M` times. Hence, the total number of times the innermost statements are executed will be `N * M`.\n\n### Common Use Cases for Nested Loops\n\n*   **Pattern Generation**: This is a very popular application of nested loops in CBSE Class 10, often involving printing stars, numbers, or characters in various geometrical shapes (e.g., squares, triangles, pyramids).\n*   **Matrix Operations**: Processing two-dimensional arrays (matrices) often involves nested loops, where the outer loop iterates through rows and the inner loop iterates through columns.\n*   **Searching and Sorting Algorithms**: Some algorithms, especially for multi-dimensional data, may employ nested loops.\n\n### Example: Generating a Square Pattern of Stars\n\nLet\'s generate a 3x3 square pattern of asterisks (`*`).\n\n```java\nclass SquarePattern {\n    public static void main(String[] args) {\n        int rows = 3;\n        int cols = 3;\n\n        System.out.println(\"3x3 Square Pattern:\");\n        for (int i = 1; i <= rows; i++) { // Outer loop for rows\n            for (int j = 1; j <= cols; j++) { // Inner loop for columns\n                System.out.print(\"* \"); // Print a star, followed by a space\n            }\n            System.out.println(); // Move to the next line after each row\n        }\n    }\n}\n```\n\n**Output:**\n```\n3x3 Square Pattern:\n* * * \n* * * \n* * * \n```\n\n**Explanation:**\n1.  The outer loop (`for (int i = 1; i <= rows; i++)`) controls the number of rows.\n2.  For `i = 1` (first row), the inner loop (`for (int j = 1; j <= cols; j++)`) executes `cols` (3) times, printing `* ` three times.\n3.  `System.out.println();` then moves the cursor to the next line.\n4.  This process repeats for `i = 2` and `i = 3`, thereby constructing the 3x3 pattern.\n\n### Example: Generating a Right-Angled Triangle Pattern\n\n```java\nclass TrianglePattern {\n    public static void main(String[] args) {\n        int height = 5;\n\n        System.out.println(\"Right-Angled Triangle Pattern:\");\n        for (int i = 1; i <= height; i++) { // Outer loop for rows\n            for (int j = 1; j <= i; j++) { // Inner loop for columns, printing \'i\' stars\n                System.out.print(\"* \");\n            }\n            System.out.println(); // New line after each row\n        }\n    }\n}\n```\n\n**Output:**\n```\nRight-Angled Triangle Pattern:\n* \n* * \n* * * \n* * * * \n* * * * * \n```\n\nHere, the inner loop\'s condition (`j <= i`) depends on the outer loop\'s variable `i`, causing the number of stars to increase with each row, forming a triangle.\n\n---\n\n## Using `break` and `continue` Statements\n\nJava provides two important statements, `break` and `continue`, which offer more control over the execution flow of loops. These statements allow you to alter the normal sequential execution of loop iterations.\n\n### The `break` Statement\n\nThe `break` statement is used to terminate a loop immediately. When a `break` statement is encountered inside a loop, the loop is exited, and program control resumes at the statement immediately following the loop.\n\n**Usage Scenarios:**\n*   Exiting a loop early when a specific condition is met, such as finding a target element in a search operation.\n*   Terminating an infinite loop based on user input or a specific event.\n\n### Example with `break`\n\n```java\nclass BreakExample {\n    public static void main(String[] args) {\n        System.out.println(\"Using break statement:\");\n        for (int i = 1; i <= 10; i++) {\n            if (i == 5) {\n                System.out.println(\"Found 5, breaking loop!\");\n                break; // Exit the loop when i becomes 5\n            }\n            System.out.println(i);\n        }\n        System.out.println(\"Loop terminated.\");\n    }\n}\n```\n\n**Output:**\n```\nUsing break statement:\n1\n2\n3\n4\nFound 5, breaking loop!\nLoop terminated.\n```\n\nAs you can observe, the loop was intended to run from 1 to 10, but when `i` became 5, the `break` statement caused it to exit prematurely.\n\n### The `continue` Statement\n\nThe `continue` statement is used to skip the rest of the current iteration of a loop and immediately proceed to the next iteration. When `continue` is encountered, the statements remaining in the current iteration of the loop body are skipped, and the loop proceeds to its update expression (for `for` loops) or condition check (for `while`/`do-while` loops).\n\n**Usage Scenarios:**\n*   Skipping certain iterations based on a condition, e.g., processing only even numbers and ignoring odd ones.\n*   Bypassing specific code within a loop body for particular values.\n\n### Example with `continue`\n\n```java\nclass ContinueExample {\n    public static void main(String[] args) {\n        System.out.println(\"Using continue statement (printing odd numbers):\");\n        for (int i = 1; i <= 10; i++) {\n            if (i % 2 == 0) { // If \'i\' is an even number\n                continue; // Skip the rest of this iteration, go to the next \'i\'\n            }\n            System.out.println(i); // This will only execute for odd numbers\n        }\n        System.out.println(\"Loop finished.\");\n    }\n}\n```\n\n**Output:**\n```\nUsing continue statement (printing odd numbers):\n1\n3\n5\n7\n9\nLoop finished.\n```\n\nIn this example, when `i` is an even number, the `continue` statement causes the `System.out.println(i);` line to be skipped for that specific iteration, effectively printing only the odd numbers.\n\nBoth `break` and `continue` statements provide fine-grained control over loop execution, enabling you to handle complex logic efficiently.', 'ready', '2025-11-01 12:05:04', '2025-11-01 15:23:20'),
(28, 3, 5, 'Introduction to Strings', '## Introduction to Strings\n\nIn the world of programming, we don\'t just work with numbers; a vast amount of data comes in the form of text. This chapter introduces **strings**, a fundamental data type used to represent and manipulate sequences of characters. You\'ll learn what strings are, how to declare and initialize them, and explore a variety of powerful methods that allow you to compare, extract, modify, and transform text data with ease.\n\n### What are Strings? Representation and Immutability\n\nAt its core, a **string** is a sequence of characters, such as letters, numbers, symbols, and spaces. Think of it as a word, a sentence, or even an entire paragraph. In most programming languages, including Java, strings are treated as objects, offering rich functionality beyond simple character arrays.\n\n*   **Representation**: Strings typically store characters using character encoding standards like **Unicode**. This allows them to represent a vast array of characters from different languages and scripts worldwide. Each character in a string has an associated index, starting from `0` for the first character, `1` for the second, and so on.\n*   **Immutability**: A crucial concept for strings in many languages (like Java) is **immutability**. This means that once a string object is created, its content **cannot be changed**. If you perform an operation that seems to modify a string (e.g., converting to uppercase or concatenating with another string), the original string remains untouched. Instead, a *new* string object is created with the modified content, and the reference to this new string is typically returned. This immutability provides benefits such as thread safety and improved performance in certain scenarios.\n\n### Declaring and Initializing String Variables\n\nDeclaring and initializing string variables is straightforward. You typically use the `String` keyword followed by the variable name.\n\nThere are a few common ways to initialize a string:\n\n*   **String Literal**: This is the most common and recommended way. You assign a sequence of characters enclosed in double-quotes directly to the variable.\n    ```java\n    String message = \"Hello, World!\";\n    ```\n    When using string literals, Java employs a mechanism called the **String Pool**. If the string literal already exists in the pool, a reference to the existing string is returned instead of creating a new object. This optimizes memory usage.\n*   **Using the `new` Keyword**: You can explicitly create a new `String` object using the `new` operator.\n    ```java\n    String name = new String(\"Alice\");\n    ```\n    Using `new String()` always creates a new object in memory, even if an identical string literal exists in the String Pool. For most practical purposes, using string literals is preferred.\n\n### Common String Methods: length(), charAt(), concat()\n\nStrings come equipped with a rich set of methods to help you work with text data. Here are some of the most frequently used ones:\n\n*   **`length()`**: This method returns the **number of characters** in the string.\n    ```java\n    String greeting = \"Welcome\";\n    int len = greeting.length(); // len will be 7\n    ```\n    Note that `length()` is a method (followed by parentheses), unlike an array\'s `length` *field*.\n*   **`charAt(int index)`**: This method returns the **character at the specified index**. Remember that string indices are zero-based.\n    ```java\n    String word = \"Programming\";\n    char firstChar = word.charAt(0); // firstChar will be \'P\'\n    char thirdChar = word.charAt(2); // thirdChar will be \'o\'\n    // char invalidChar = word.charAt(20); // This would throw an IndexOutOfBoundsException\n    ```\n*   **`concat(String str)`**: This method appends the specified string to the end of the current string. Due to immutability, it **returns a new string** that is the result of the concatenation.\n    ```java\n    String firstName = \"John\";\n    String lastName = \"Doe\";\n    String fullName = firstName.concat(\" \").concat(lastName); // fullName will be \"John Doe\"\n    // A more common way to concatenate is using the \'+\' operator:\n    String fullAddress = \"123 Main St\" + \", Anytown\"; // fullAddress will be \"123 Main St, Anytown\"\n    ```\n\n### Comparing Strings: equals(), equalsIgnoreCase(), compareTo()\n\nComparing strings for their content is a critical operation. It\'s important to **never use the `==` operator** to compare string content, as `==` checks if two references point to the *exact same object* in memory, not if their contents are identical.\n\n*   **`equals(Object obj)`**: This method performs a **case-sensitive comparison** of the content of two strings. It returns `true` if the strings have the same sequence of characters, and `false` otherwise.\n    ```java\n    String s1 = \"Apple\";\n    String s2 = \"Apple\";\n    String s3 = \"apple\";\n\n    System.out.println(s1.equals(s2)); // true\n    System.out.println(s1.equals(s3)); // false (due to case difference)\n    ```\n*   **`equalsIgnoreCase(String anotherString)`**: This method performs a **case-insensitive comparison** of the content of two strings. It returns `true` if the strings are equal, ignoring differences in case.\n    ```java\n    String s1 = \"Java\";\n    String s2 = \"java\";\n    String s3 = \"JAVA\";\n\n    System.out.println(s1.equalsIgnoreCase(s2)); // true\n    System.out.println(s1.equalsIgnoreCase(s3)); // true\n    ```\n*   **`compareTo(String anotherString)`**: This method compares two strings lexicographically (based on their Unicode values) and returns an integer value:\n    *   A **negative integer** if the current string is lexicographically less than `anotherString`.\n    *   **`0`** if the strings are lexicographically equal.\n    *   A **positive integer** if the current string is lexicographically greater than `anotherString`.\n    ```java\n    String fruit1 = \"Apple\";\n    String fruit2 = \"Banana\";\n    String fruit3 = \"apple\";\n\n    System.out.println(fruit1.compareTo(fruit2)); // A negative number (Apple comes before Banana)\n    System.out.println(fruit2.compareTo(fruit1)); // A positive number (Banana comes after Apple)\n    System.out.println(fruit1.compareTo(fruit1)); // 0\n    System.out.println(fruit1.compareTo(fruit3)); // A negative number (Uppercase \'A\' comes before lowercase \'a\')\n    ```\n\n### Extracting and Modifying Substrings: substring(), indexOf()\n\nOften, you\'ll need to work with only a portion of a string or locate specific characters within it.\n\n*   **`substring(int beginIndex)`**: This method returns a **new string** that is a substring of the current string, starting from the `beginIndex` (inclusive) and extending to the end of the string.\n    ```java\n    String message = \"Hello, World!\";\n    String part1 = message.substring(7); // part1 will be \"World!\"\n    ```\n*   **`substring(int beginIndex, int endIndex)`**: This method returns a **new string** that is a substring of the current string, starting from the `beginIndex` (inclusive) and extending up to, but **not including**, the `endIndex`.\n    ```java\n    String sentence = \"The quick brown fox.\";\n    String word = sentence.substring(4, 9); // word will be \"quick\" (characters at index 4, 5, 6, 7, 8)\n    ```\n*   **`indexOf(int ch)` / `indexOf(String str)`**: These methods return the **index within the current string of the first occurrence** of the specified character or substring. If the character or substring is not found, it returns `-1`.\n    ```java\n    String data = \"product_id_123\";\n    int underscoreIndex = data.indexOf(\'_\'); // underscoreIndex will be 8\n    int idIndex = data.indexOf(\"id\");       // idIndex will be 9\n    int nonExistent = data.indexOf(\"xyz\");  // nonExistent will be -1\n    ```\n    There are also overloaded versions of `indexOf()` that allow you to specify a starting index for the search.\n\n### Case Conversion and Trimming: toUpperCase(), toLowerCase(), trim()\n\nThese methods are useful for standardizing text data, especially for comparisons or display.\n\n*   **`toUpperCase()`**: This method returns a **new string** with all the characters in the current string converted to uppercase.\n    ```java\n    String text = \"hello world\";\n    String upperText = text.toUpperCase(); // upperText will be \"HELLO WORLD\"\n    ```\n*   **`toLowerCase()`**: This method returns a **new string** with all the characters in the current string converted to lowercase.\n    ```java\n    String productName = \"Laptop Pro X\";\n    String lowerProductName = productName.toLowerCase(); // lowerProductName will be \"laptop pro x\"\n    ```\n*   **`trim()`**: This method returns a **new string** with leading and trailing whitespace removed. Whitespace includes spaces, tabs, and newline characters.\n    ```java\n    String userInput = \"   Some data with spaces   \";\n    String cleanedInput = userInput.trim(); // cleanedInput will be \"Some data with spaces\"\n    ```\n    This is particularly useful when processing user input, which often includes unintentional leading or trailing spaces.', 'ready', '2025-11-01 12:05:04', '2025-11-01 19:29:04');
INSERT INTO `chapters` (`id`, `book_id`, `chapter_index`, `title`, `generated_content`, `status`, `created_at`, `updated_at`) VALUES
(29, 3, 6, 'Arrays: Storing Multiple Values', 'This chapter delves into one of the most fundamental and widely used data structures in programming: **arrays**. Until now, we\'ve focused on variables that hold a single piece of data. However, many real-world scenarios require handling collections of related data, such as a list of student scores, a series of temperature readings, or a collection of product names. Arrays provide an elegant and efficient solution for storing multiple values of the same type under a single variable name, enabling organized data management and streamlined processing.\n\n## Introduction to Arrays and Their Need\n\nImagine you need to store the scores of 50 students in a class. If you were to use individual variables, you\'d end up declaring `score1`, `score2`, `score3`, and so on, all the way to `score50`. This approach is not only tedious and error-prone but also makes it incredibly difficult to perform common operations like calculating the average score or finding the highest score, as you\'d have to write repetitive code for each variable.\n\nThis is where **arrays** come in. An array is a data structure that allows you to store a fixed-size sequential collection of elements of the **same data type** under a single variable name. Think of an array as a row of mailboxes, where each mailbox holds a piece of information (an element), and all mailboxes belong to the same address (the array name). Each mailbox also has a unique number (its position or index) to distinguish it from the others.\n\nThe need for arrays arises from the desire to:\n*   **Organize related data:** Group similar items together.\n*   **Simplify code:** Process many values with fewer lines of code, often using loops.\n*   **Efficiently manage collections:** Perform operations across entire datasets easily.\n\n## Declaring and Initializing One-Dimensional Arrays\n\nBefore you can use an array, you must declare it and then create (instantiate) it.\n\n### Declaring an Array\nDeclaring an array variable simply tells the compiler the type of elements the array will hold and gives the array a name. It doesn\'t actually create the array in memory yet.\n\nThe syntax for declaring an array is:\n*   `dataType[] arrayName;` (Preferred style)\n*   `dataType arrayName[];`\n\nHere, `dataType` specifies the type of data the array will store (e.g., `int`, `double`, `String`), and `arrayName` is the name you choose for the array variable. The `[]` brackets indicate that it\'s an array.\n\n**Example:**\n```java\nint[] numbers;        // Declares an array variable named \'numbers\' that will hold integers\nString[] names;       // Declares an array variable named \'names\' that will hold strings\ndouble[] temperatures; // Declares an array variable named \'temperatures\' that will hold double values\n```\n\n### Instantiating (Creating) an Array\nAfter declaring the array variable, you must create the array object itself using the `new` keyword and specify its size. The **size** of an array determines how many elements it can hold. Once created, an array\'s size cannot be changed.\n\nThe syntax for creating an array is:\n`arrayName = new dataType[size];`\n\n**Example:**\n```java\nnumbers = new int[5]; // Creates an array named \'numbers\' that can hold 5 integer elements\nnames = new String[10]; // Creates an array named \'names\' that can hold 10 String elements\n```\n\nYou can combine declaration and instantiation into a single line:\n`dataType[] arrayName = new dataType[size];`\n\n**Example:**\n```java\nint[] scores = new int[7]; // Declares and creates an array named \'scores\' to hold 7 integers\n```\n\nWhen an array is created, its elements are automatically initialized to **default values**:\n*   Numeric types (`byte`, `short`, `int`, `long`, `float`, `double`): `0`\n*   Boolean type: `false`\n*   Character type (`char`): `\\u0000` (null character)\n*   Reference types (`String`, custom objects): `null`\n\n### Initializing an Array\nYou can assign values to array elements in several ways:\n\n1.  **After Creation:** Assign values to individual elements using their index.\n    ```java\n    int[] grades = new int[3]; // grades array: {0, 0, 0}\n    grades[0] = 85;           // grades array: {85, 0, 0}\n    grades[1] = 92;           // grades array: {85, 92, 0}\n    grades[2] = 78;           // grades array: {85, 92, 78}\n    ```\n\n2.  **During Declaration with an Initializer List:** If you know the values at the time of declaration, you can use an initializer list. The compiler automatically determines the size of the array based on the number of values provided.\n    ```java\n    int[] primeNumbers = {2, 3, 5, 7, 11}; // Declares, creates, and initializes an array of size 5\n    String[] fruits = {\"Apple\", \"Banana\", \"Cherry\"}; // Declares, creates, and initializes a String array of size 3\n    ```\n\n## Accessing Elements of an Array\n\nEach element in an array is identified by a unique number called an **index** (or subscript). Array indices are **zero-based**, meaning the first element is at index `0`, the second at index `1`, and so on.\n\nTo access an element, you use the array name followed by the index in square brackets:\n`arrayName[index]`\n\n**Example:**\n```java\nint[] numbers = {10, 20, 30, 40, 50};\n\nSystem.out.println(numbers[0]); // Output: 10 (the first element)\nSystem.out.println(numbers[3]); // Output: 40 (the fourth element)\n\nnumbers[1] = 25; // Change the value of the second element\nSystem.out.println(numbers[1]); // Output: 25\n```\n\n### Array Length\nEvery array in Java has a built-in property called **`length`** that returns the number of elements it can hold. This is extremely useful for iterating through arrays.\n\n**Example:**\n```java\nint[] data = new int[10];\nSystem.out.println(\"The array has \" + data.length + \" elements.\"); // Output: The array has 10 elements.\n\nString[] weekdays = {\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"};\nSystem.out.println(\"Number of weekdays: \" + weekdays.length); // Output: Number of weekdays: 5\n```\nThe last valid index for an array is `arrayName.length - 1`.\n\n### `ArrayIndexOutOfBoundsException`\nA common error when working with arrays is trying to access an element using an index that is outside the valid range (i.e., less than `0` or greater than or equal to `arrayName.length`). This results in a **`ArrayIndexOutOfBoundsException`** at runtime.\n\n**Example (will cause an error):**\n```java\nint[] values = {1, 2, 3};\nSystem.out.println(values[3]); // Error! Valid indices are 0, 1, 2.\n```\nUnderstanding array bounds is crucial for preventing such errors.\n\n## Traversing Arrays: Input and Output\n\n**Traversing** an array means visiting each element, typically to perform an operation like reading input, displaying output, or performing calculations. Loops are essential for array traversal.\n\n### Using the `for` Loop for Traversal\nThe traditional `for` loop is the most versatile way to traverse an array, especially when you need to access elements by their index (e.g., for input, modification, or processing elements in a specific order).\n\n**Inputting elements into an array:**\n```java\nimport java.util.Scanner;\n\npublic class ArrayInput {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int[] numbers = new int[4]; // An array to hold 4 integers\n\n        System.out.println(\"Enter 4 integers:\");\n        for (int i = 0; i < numbers.length; i++) {\n            System.out.print(\"Enter number \" + (i + 1) + \": \");\n            numbers[i] = input.nextInt(); // Read input and store at index i\n        }\n        input.close();\n\n        // Now you can work with the \'numbers\' array\n        System.out.println(\"Numbers entered:\");\n        for (int i = 0; i < numbers.length; i++) {\n            System.out.print(numbers[i] + \" \");\n        }\n        System.out.println();\n    }\n}\n```\n\n**Outputting elements from an array:**\n```java\nString[] names = {\"Alice\", \"Bob\", \"Charlie\", \"David\"};\n\nSystem.out.println(\"List of names:\");\nfor (int i = 0; i < names.length; i++) {\n    System.out.println(\"Name at index \" + i + \": \" + names[i]);\n}\n```\n\n### Using the Enhanced `for` Loop (For-Each Loop)\nJava provides an enhanced `for` loop, also known as the \"for-each\" loop, which simplifies iterating through collections like arrays when you don\'t need the index. It\'s concise and less prone to off-by-one errors.\n\nThe syntax is:\n`for (dataType element : arrayName)`\n\n**Example for Output:**\n```java\ndouble[] grades = {88.5, 92.0, 75.5, 95.0};\n\nSystem.out.println(\"Student Grades:\");\nfor (double grade : grades) { // For each \'grade\' in the \'grades\' array\n    System.out.println(grade);\n}\n```\n**Important Note:** The enhanced `for` loop is read-only for primitive types. You cannot use it to modify the elements of an array directly (e.g., `grade = grade + 5;` inside the loop would only change the local `grade` variable, not the element in the `grades` array). If you need to modify elements or access their index, use the traditional `for` loop.\n\n## Basic Array Operations: Sum, Average, Search\n\nArrays are frequently used for performing common data manipulations. Let\'s look at some basic operations.\n\n### Calculating the Sum of Elements\nTo find the sum of all elements in a numeric array, you iterate through the array and add each element to a running total.\n\n```java\nint[] scores = {85, 90, 78, 92, 88};\nint sum = 0;\n\nfor (int i = 0; i < scores.length; i++) {\n    sum += scores[i]; // Add current element to sum\n}\n// Or using enhanced for loop:\n// for (int score : scores) {\n//     sum += score;\n// }\n\nSystem.out.println(\"Sum of scores: \" + sum); // Output: Sum of scores: 433\n```\n\n### Calculating the Average of Elements\nOnce you have the sum, calculating the average is straightforward: divide the sum by the number of elements (`array.length`). Remember to handle potential integer division if necessary.\n\n```java\nint[] scores = {85, 90, 78, 92, 88};\nint sum = 0;\n\nfor (int score : scores) {\n    sum += score;\n}\n\ndouble average = (double) sum / scores.length; // Cast sum to double for accurate division\n\nSystem.out.println(\"Average score: \" + average); // Output: Average score: 86.6\n```\n\n### Searching for an Element (Linear Search)\nTo find if a specific value exists in an array, or to find its position, you can perform a **linear search**. This involves checking each element one by one from the beginning until the target is found or the end of the array is reached.\n\n```java\nint[] numbers = {12, 34, 56, 78, 90, 45};\nint target = 78;\nboolean found = false;\nint index = -1; // To store the index if found\n\nfor (int i = 0; i < numbers.length; i++) {\n    if (numbers[i] == target) {\n        found = true;\n        index = i;\n        break; // Exit loop once found\n    }\n}\n\nif (found) {\n    System.out.println(target + \" found at index \" + index); // Output: 78 found at index 3\n} else {\n    System.out.println(target + \" not found in the array.\");\n}\n```\n\n## Practical Examples of Array Usage\n\nArrays are indispensable for many programming tasks. Let\'s look at a few common scenarios.\n\n### 1. Storing and Analyzing Student Scores\nThis is a classic use case. An array can easily manage a list of scores for a class.\n\n```java\nimport java.util.Scanner;\n\npublic class StudentGrades {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numStudents = 5;\n        int[] studentScores = new int[numStudents];\n        int totalScore = 0;\n\n        System.out.println(\"Enter scores for \" + numStudents + \" students:\");\n        for (int i = 0; i < numStudents; i++) {\n            System.out.print(\"Student \" + (i + 1) + \" score: \");\n            studentScores[i] = scanner.nextInt();\n            totalScore += studentScores[i];\n        }\n        scanner.close();\n\n        double averageScore = (double) totalScore / numStudents;\n\n        System.out.println(\"\\n--- Grade Report ---\");\n        for (int i = 0; i < numStudents; i++) {\n            System.out.println(\"Student \" + (i + 1) + \": \" + studentScores[i]);\n        }\n        System.out.println(\"Total Score: \" + totalScore);\n        System.out.printf(\"Average Score: %.2f%n\", averageScore); // Format to 2 decimal places\n    }\n}\n```\n\n### 2. Managing a List of Product Names\nArrays can store `String` data, making them useful for lists of items.\n\n```java\npublic class ProductList {\n    public static void main(String[] args) {\n        String[] productNames = {\"Laptop\", \"Mouse\", \"Keyboard\", \"Monitor\", \"Webcam\"};\n        double[] productPrices = {1200.00, 25.50, 75.00, 300.00, 49.99};\n\n        System.out.println(\"--- Our Products ---\");\n        for (int i = 0; i < productNames.length; i++) {\n            System.out.printf(\"%s: $%.2f%n\", productNames[i], productPrices[i]);\n        }\n\n        // Find the most expensive product\n        double maxPrice = productPrices[0];\n        String expensiveProduct = productNames[0];\n\n        for (int i = 1; i < productPrices.length; i++) {\n            if (productPrices[i] > maxPrice) {\n                maxPrice = productPrices[i];\n                expensiveProduct = productNames[i];\n            }\n        }\n        System.out.println(\"\\nMost expensive product: \" + expensiveProduct + \" ($\" + maxPrice + \")\");\n    }\n}\n```\n\n### 3. Tracking Daily Temperatures\nArrays are perfect for storing sequential data like daily readings.\n\n```java\npublic class DailyTemperatures {\n    public static void main(String[] args) {\n        double[] dailyTemps = {22.5, 24.1, 21.9, 23.0, 25.2, 20.8, 22.0}; // 7 days of temperatures\n        double sumTemps = 0;\n        double highestTemp = dailyTemps[0];\n        double lowestTemp = dailyTemps[0];\n\n        System.out.println(\"--- Weekly Temperature Report ---\");\n        for (int i = 0; i < dailyTemps.length; i++) {\n            System.out.println(\"Day \" + (i + 1) + \": \" + dailyTemps[i] + \"°C\");\n            sumTemps += dailyTemps[i];\n            if (dailyTemps[i] > highestTemp) {\n                highestTemp = dailyTemps[i];\n            }\n            if (dailyTemps[i] < lowestTemp) {\n                lowestTemp = dailyTemps[i];\n            }\n        }\n\n        double averageTemp = sumTemps / dailyTemps.length;\n        System.out.printf(\"\\nAverage Temperature: %.1f°C%n\", averageTemp);\n        System.out.printf(\"Highest Temperature: %.1f°C%n\", highestTemp);\n        System.out.printf(\"Lowest Temperature: %.1f°C%n\", lowestTemp);\n    }\n}\n```\n\nThese examples demonstrate how arrays provide a powerful and flexible way to store, organize, and process collections of data, making your programs more efficient and manageable.', 'ready', '2025-11-01 12:05:04', '2025-11-01 19:29:36'),
(30, 3, 7, 'Methods (Functions): Modular Programming', '## Methods (Functions): Modular Programming\n\nThis chapter introduces a fundamental concept in programming: **methods**, often referred to as **functions**. Methods are self-contained blocks of code designed to perform specific tasks, enabling us to organize our programs into smaller, manageable, and reusable units. By embracing methods, we move towards **modular programming**, a powerful paradigm that enhances code readability, maintainability, and efficiency.\n\n## Understanding Modular Programming Concepts\n\nModular programming is an approach to software design that emphasizes dividing a program into independent, interchangeable modules. Instead of writing one long, monolithic piece of code, we break down complex problems into smaller, more manageable sub-problems, each handled by its own module. In many programming languages, methods (or functions) serve as these modules.\n\n### Benefits of Modular Programming:\n\n*   **Reusability:** A method written once can be called multiple times from different parts of the program, or even in different programs, without needing to rewrite the code.\n*   **Maintainability:** When a program is modular, changes or fixes to one part of the code are less likely to affect other parts, simplifying updates and debugging.\n*   **Readability:** Breaking a large program into smaller, named methods makes the overall code easier to understand and follow. Each method\'s name can clearly indicate its purpose.\n*   **Collaboration:** In team environments, different developers can work on different modules concurrently, speeding up development.\n*   **Debugging:** Isolating problems becomes easier when each module performs a specific task. If an error occurs, you can narrow down the search to the relevant method.\n\n## Defining Methods: Structure and Components\n\nA method is essentially a named block of code that performs a specific operation. When defining a method, you specify its structure, including its name, what type of value it might return, and any inputs it might need.\n\nThe basic structure of a method definition typically includes:\n\n```java\n[Access Modifier] [Optional Modifiers] ReturnType MethodName (ParameterType1 parameter1, ParameterType2 parameter2, ...)\n{\n    // Method body: statements that perform the task\n    // Optional: return statement if ReturnType is not \'void\'\n}\n```\n\nLet\'s break down each component:\n\n*   **Access Modifier (e.g., `public`, `private`):** Controls the visibility and accessibility of the method from other parts of the program.\n*   **Optional Modifiers (e.g., `static`):** Provide additional characteristics. For instance, `static` methods belong to the class itself rather than to an instance of the class.\n*   **Return Type:** Specifies the data type of the value that the method will send back to the caller. If a method does not return any value, its return type is `void`.\n*   **Method Name:** A unique identifier that describes the method\'s purpose. It should be descriptive and follow naming conventions (e.g., `calculateSum`, `printMessage`).\n*   **Parameters:** A comma-separated list of variable declarations enclosed in parentheses `()`. These are placeholders for the values (arguments) that will be passed into the method when it\'s called. Parameters allow methods to receive input and operate on different data. If a method requires no input, the parentheses are empty: `()`.\n*   **Method Body:** The block of code enclosed in curly braces `{}` that contains the statements to be executed when the method is called.\n\n## Method Signature, Return Type, and Parameters\n\nUnderstanding these three key aspects is crucial for defining and using methods effectively.\n\n### Method Signature\n\nThe **method signature** is a unique identifier for a method within its scope. It consists of the **method name** and the **number, type, and order of its parameters**. The return type is NOT part of the method signature.\n\n*   Example: `calculateSum(int num1, int num2)` is a signature.\n*   Example: `printMessage()` is another signature.\n\nThe signature is vital because it allows the compiler to distinguish between different methods that might share the same name (a concept known as method overloading, discussed later).\n\n### Return Type\n\nThe **return type** specifies the type of value a method sends back to the part of the code that called it.\n\n*   If a method performs a calculation and needs to provide the result, its return type would be the data type of that result (e.g., `int`, `double`, `String`).\n*   A method uses the `return` keyword followed by the value to be returned.\n*   If a method performs actions but does not need to send back any value, its return type is `void`. Methods with a `void` return type do not use the `return` keyword unless it\'s to exit the method prematurely.\n\n```java\npublic int add(int a, int b) { // Returns an integer\n    return a + b;\n}\n\npublic void displayMessage(String message) { // Returns nothing\n    System.out.println(message);\n}\n```\n\n### Parameters\n\n**Parameters** are variables declared in the method definition that act as placeholders for the data a method expects to receive. They define the type and name of the input values.\n\n*   When you define a method, you specify its **formal parameters**.\n*   Each parameter must have a **data type** and a **name**.\n*   Parameters allow methods to be flexible and perform operations on different sets of data without being rewritten.\n\n```java\npublic double calculateArea(double radius) { // \'radius\' is a formal parameter\n    // ...\n}\n```\n\n## Calling Methods: Passing Arguments\n\nTo execute the code inside a method, you must **call** or **invoke** it. When calling a method, you provide the actual values that correspond to its parameters; these values are known as **arguments**.\n\n### How to Call a Method:\n\n1.  **For `static` methods (like `main` method or utility methods):**\n    `ClassName.methodName(argument1, argument2, ...);`\n    If calling from within the same class, `ClassName.` can be omitted.\n2.  **For non-`static` methods (instance methods):**\n    First, you need an object (an instance of the class).\n    `objectName.methodName(argument1, argument2, ...);`\n\n### Arguments vs. Parameters:\n\n*   **Parameters:** Variables in the method *definition* that specify the *type* of input expected.\n*   **Arguments:** The *actual values* passed to the method when it is *called*.\n\nThe data types and number of arguments passed must match the data types and number of parameters defined in the method\'s signature.\n\n```java\npublic class Calculator {\n    // Method to add two integers (returns an int)\n    public static int sum(int num1, int num2) { // num1, num2 are parameters\n        return num1 + num2;\n    }\n\n    // Method to display a greeting (returns void)\n    public static void greet(String name) { // name is a parameter\n        System.out.println(\"Hello, \" + name + \"!\");\n    }\n\n    public static void main(String[] args) {\n        // Calling the sum method\n        int result = sum(10, 5); // 10, 5 are arguments\n        System.out.println(\"Sum: \" + result); // Output: Sum: 15\n\n        // Calling the greet method\n        greet(\"Alice\"); // \"Alice\" is an argument\n        // Output: Hello, Alice!\n\n        // Calling a method without parameters\n        printSeparator(); // No arguments needed\n    }\n\n    public static void printSeparator() { // No parameters\n        System.out.println(\"-----\");\n    }\n}\n```\n\n## User-Defined Methods: Practical Implementation\n\nUser-defined methods are methods that you, the programmer, write to perform specific tasks. They are the building blocks for modular programming. Let\'s look at a complete example illustrating various types of user-defined methods within a simple program.\n\n```java\npublic class MyUtilities {\n\n    // Method 1: No parameters, no return value (void)\n    public static void printWelcomeMessage() {\n        System.out.println(\"*****************************\");\n        System.out.println(\" Welcome to My Utilities App \");\n        System.out.println(\"*****************************\");\n    }\n\n    // Method 2: With parameters, no return value (void)\n    public static void displayStudentInfo(String name, int age, double grade) {\n        System.out.println(\"Student Name: \" + name);\n        System.out.println(\"Student Age: \" + age + \" years old\");\n        System.out.println(\"Student Grade: \" + grade);\n    }\n\n    // Method 3: With parameters, with a return value (int)\n    public static int multiply(int a, int b) {\n        int product = a * b;\n        return product; // Returns the calculated product\n    }\n\n    // Method 4: With parameters, with a return value (boolean)\n    public static boolean isEven(int number) {\n        if (number % 2 == 0) {\n            return true; // The number is even\n        } else {\n            return false; // The number is odd\n        }\n    }\n\n    public static void main(String[] args) {\n        // Calling Method 1\n        printWelcomeMessage();\n        System.out.println(); // Add a blank line for spacing\n\n        // Calling Method 2\n        displayStudentInfo(\"John Doe\", 20, 85.5);\n        System.out.println();\n\n        // Calling Method 3 and storing its return value\n        int resultOfMultiplication = multiply(7, 4);\n        System.out.println(\"7 multiplied by 4 is: \" + resultOfMultiplication);\n        System.out.println();\n\n        // Calling Method 4 and using its return value in a conditional statement\n        int checkNumber = 17;\n        if (isEven(checkNumber)) {\n            System.out.println(checkNumber + \" is an even number.\");\n        } else {\n            System.out.println(checkNumber + \" is an odd number.\");\n        }\n    }\n}\n```\n\nThis example demonstrates how different methods encapsulate distinct functionalities:\n*   `printWelcomeMessage` simply displays text.\n*   `displayStudentInfo` takes data and formats it for output.\n*   `multiply` performs a calculation and provides the result.\n*   `isEven` performs a check and returns a true/false outcome.\n\nBy breaking down the program into these methods, the `main` method becomes cleaner and easier to read, as it primarily orchestrates the calls to these specialized functions.\n\n## Introduction to Method Overloading\n\n**Method overloading** is a powerful feature that allows a class to have multiple methods with the same name, provided they have different **method signatures**. The compiler uses the method signature (the method name plus the number, type, and order of its parameters) to determine which specific version of the method to call.\n\n### How Method Overloading Works:\n\nFor methods to be overloaded, they must satisfy one or more of these conditions:\n\n*   **Different number of parameters:** Two methods named `add` can exist if one takes two integers and another takes three integers.\n*   **Different types of parameters:** Two methods named `print` can exist if one takes a `String` and another takes an `int`.\n*   **Different order of parameters:** Two methods named `display` can exist if one takes `(int, String)` and another takes `(String, int)`.\n\n**Important Note:** The **return type alone is not sufficient** to overload a method. If two methods have the exact same signature but different return types, it will result in a compile-time error.\n\n### Benefits of Method Overloading:\n\n*   **Improved Readability:** You can use a single, intuitive method name for operations that are conceptually the same but apply to different types or numbers of inputs (e.g., `add` for integers, `add` for doubles, `add` for three numbers).\n*   **Code Flexibility:** It makes APIs easier to use by allowing callers to invoke the same logical operation with varying arguments.\n\n### Example of Method Overloading:\n\n```java\npublic class CalculatorOverload {\n\n    // Method 1: Adds two integers\n    public static int add(int a, int b) {\n        System.out.println(\"Adding two integers.\");\n        return a + b;\n    }\n\n    // Method 2: Adds three integers (different number of parameters)\n    public static int add(int a, int b, int c) {\n        System.out.println(\"Adding three integers.\");\n        return a + b + c;\n    }\n\n    // Method 3: Adds two doubles (different types of parameters)\n    public static double add(double a, double b) {\n        System.out.println(\"Adding two doubles.\");\n        return a + b;\n    }\n\n    // Method 4: Concatenates two strings (different types of parameters, different operation)\n    public static String add(String s1, String s2) {\n        System.out.println(\"Concatenating two strings.\");\n        return s1 + s2;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Result 1: \" + add(10, 20));             // Calls Method 1\n        System.out.println(\"Result 2: \" + add(10, 20, 30));         // Calls Method 2\n        System.out.println(\"Result 3: \" + add(10.5, 20.5));         // Calls Method 3\n        System.out.println(\"Result 4: \" + add(\"Hello, \", \"World!\")); // Calls Method 4\n    }\n}\n```\nIn this example, the compiler automatically chooses the correct `add` method based on the types and number of arguments provided during the method call. This demonstrates how overloading allows for a consistent naming convention while supporting diverse functionalities.', 'ready', '2025-11-01 12:05:04', '2025-11-01 19:29:09'),
(31, 3, 8, 'Fundamentals of Classes and Objects (OOP)', '## Fundamentals of Classes and Objects (OOP)\n\nThis chapter introduces the foundational concepts of Object-Oriented Programming (OOP): classes and objects. Understanding these core building blocks is crucial for writing modular, reusable, and maintainable code in many modern programming languages. We will explore what classes are, how objects are created from them, and how to define their characteristics and behaviors.\n\n---\n\n### Introduction to Object-Oriented Programming (OOP)\n\n**Object-Oriented Programming (OOP)** is a programming paradigm that organizes software design around **objects** rather than functions and logic. Instead of focusing on \"how to do\" things, OOP focuses on \"what\" an object is and \"what it can do.\" This approach aims to model real-world entities and their interactions more intuitively within code.\n\nKey benefits of OOP include:\n*   **Modularity:** Code is organized into self-contained units (objects).\n*   **Reusability:** Objects can be reused in different parts of a program or in new programs.\n*   **Maintainability:** Changes in one part of the code are less likely to affect others.\n*   **Scalability:** Easier to manage large and complex systems.\n\nThe core principles of OOP are **encapsulation**, **inheritance**, and **polymorphism**, which we will explore in detail in later chapters. For now, we\'ll focus on the fundamental concepts: classes and objects.\n\n---\n\n### Classes: Blueprints for Objects\n\nImagine you want to build many houses. You don\'t redraw the entire house plan every time; you use a **blueprint**. In OOP, a **class** serves as that blueprint.\n\nA **class** is a user-defined data type that acts as a template or blueprint for creating objects. It defines the structure and behavior that its objects will possess. Think of it as a logical entity that describes the common characteristics and actions shared by a group of similar items.\n\nA class typically contains:\n*   **Data Members (Attributes):** Variables that define the characteristics or state of an object. For a `Car` class, these might be `color`, `make`, `model`, `speed`.\n*   **Member Methods (Behaviors):** Functions that define the actions an object can perform or the operations that can be done to it. For a `Car` class, these might be `startEngine()`, `accelerate()`, `brake()`.\n\nCrucially, a class is merely a definition; it **does not occupy memory** by itself. It\'s like the idea of a car, not an actual car driving on the road.\n\n---\n\n### Objects: Instances of a Class\n\nIf a class is a blueprint, then an **object** is the actual house built from that blueprint. An object is a concrete, real-world entity created from a class.\n\nAn **object** is an instance of a class. When you create an object, you are essentially bringing the blueprint to life. Each object has its own unique identity, state (values for its data members), and behavior (methods it can execute).\n\nConsider the `Car` class blueprint again:\n*   From this `Car` class, you can create multiple `Car` objects: `myRedCar`, `yourBlueCar`, `deliveryVan`.\n*   Each of these objects is a `Car`, but they can have different characteristics (e.g., `myRedCar.color` might be \"Red\", while `yourBlueCar.color` is \"Blue\").\n*   Each object exists independently in memory and can interact with other objects.\n\n---\n\n### Defining a Class: Data Members and Member Methods\n\nTo define a class, you specify its name, followed by its data members and member methods. The specific syntax varies by programming language (e.g., Java, C++, Python), but the conceptual structure remains the same.\n\nHere\'s a conceptual example of a `Book` class:\n\n```\n// Conceptual Class Definition\nclass Book {\n    // --- Data Members (Attributes) ---\n    String title;      // To store the book\'s title\n    String author;     // To store the author\'s name\n    int pages;         // To store the number of pages\n\n    // --- Member Methods (Behaviors) ---\n    // Method to display book information\n    void displayInfo() {\n        // ... code to print title, author, pages\n    }\n\n    // Method to simulate reading the book\n    void read() {\n        // ... code to indicate reading action\n    }\n}\n```\n\n*   **Data Members:** `title`, `author`, and `pages` are variables that will hold specific information for each `Book` object. They define the *state* of a book.\n*   **Member Methods:** `displayInfo()` and `read()` are functions that define what a `Book` object *can do* or how it can be interacted with. They define the *behavior* of a book. These methods often operate on the object\'s own data members.\n\n---\n\n### Creating Objects and Accessing Class Members\n\nOnce a class is defined, you can create objects (instances) from it. This process is called **instantiation**.\n\nTo create an object, you typically use a keyword like `new` (in languages like Java or C++) followed by the class name.\n\n```\n// Conceptual Object Creation\n// 1. Declare a variable of the class type\n// 2. Use \'new\' to allocate memory and create the object\nBook myNovel = new Book();\nBook textbook = new Book();\n```\nIn this example:\n*   `myNovel` and `textbook` are **objects** (instances) of the `Book` class.\n*   Each object (`myNovel`, `textbook`) gets its own copy of the `title`, `author`, and `pages` data members.\n\nTo interact with an object\'s data members or call its methods, you use the **dot operator (`.`)**.\n\n```\n// Accessing Data Members and Methods\n// Set values for myNovel\'s data members\nmyNovel.title = \"The Secret Garden\";\nmyNovel.author = \"Frances Hodgson Burnett\";\nmyNovel.pages = 288;\n\n// Call myNovel\'s method\nmyNovel.displayInfo(); // Output: \"Title: The Secret Garden, Author: F.H. Burnett, Pages: 288\"\nmyNovel.read();        // Output: \"Reading \'The Secret Garden\'...\"\n\n// Set values for textbook\'s data members\ntextbook.title = \"Calculus Essentials\";\ntextbook.author = \"John Doe\";\ntextbook.pages = 800;\n\n// Call textbook\'s method\ntextbook.displayInfo(); // Output: \"Title: Calculus Essentials, Author: John Doe, Pages: 800\"\n```\nNotice that `myNovel` and `textbook` are distinct objects. Changing the `title` of `myNovel` does not affect the `title` of `textbook`. Each object maintains its own independent state.\n\n---\n\n### Understanding Constructors (Basic)\n\nWhen an object is created, it\'s often desirable to initialize its data members with meaningful values right away, rather than assigning them one by one after creation. This is where **constructors** come in.\n\nA **constructor** is a special type of member method that is automatically called when an object of a class is created (instantiated). Its primary purpose is to **initialize the object\'s data members**.\n\nKey characteristics of constructors:\n*   **Same Name as the Class:** The constructor\'s name must be identical to the class name.\n*   **No Return Type:** Constructors do not have a return type, not even `void`.\n*   **Automatic Invocation:** They are called automatically by the system when `new` is used.\n\n#### Default Constructor\n\nIf you don\'t explicitly define any constructors in your class, most programming languages provide a **default constructor** automatically. This constructor typically:\n*   Takes no arguments (parameters).\n*   Initializes data members to their default values (e.g., `0` for numbers, `null` for objects, `false` for booleans).\n\n```\n// Implicit Default Constructor (if none defined)\nBook myEmptyBook = new Book(); // Calls the default constructor\n// At this point, myEmptyBook.title is null, myEmptyBook.pages is 0\n```\n\n#### Parameterized Constructors\n\nYou can define your own constructors that accept parameters. These are called **parameterized constructors** and allow you to initialize an object with specific values at the time of its creation.\n\n```\n// Conceptual Class with a Parameterized Constructor\nclass Book {\n    String title;\n    String author;\n    int pages;\n\n    // Parameterized Constructor\n    // Takes arguments to initialize the object\'s data members\n    Book(String initialTitle, String initialAuthor, int initialPages) {\n        this.title = initialTitle;       // \'this\' refers to the current object\n        this.author = initialAuthor;\n        this.pages = initialPages;\n    }\n\n    void displayInfo() {\n        System.out.println(\"Title: \" + title + \", Author: \" + author + \", Pages: \" + pages);\n    }\n}\n```\n\nNow, when creating objects, you can pass initial values directly:\n\n```\n// Creating objects using the Parameterized Constructor\nBook historyBook = new Book(\"Sapiens\", \"Yuval Noah Harari\", 443);\nBook codingManual = new Book(\"Clean Code\", \"Robert C. Martin\", 464);\n\nhistoryBook.displayInfo();  // Output: \"Title: Sapiens, Author: Yuval Noah Harari, Pages: 443\"\ncodingManual.displayInfo(); // Output: \"Title: Clean Code, Author: Robert C. Martin, Pages: 464\"\n```\nConstructors streamline object creation and ensure that objects start in a valid, well-defined state. We will explore more advanced constructor concepts, such as constructor overloading, in a later chapter.', 'ready', '2025-11-01 12:05:04', '2025-11-01 19:29:05'),
(32, 4, 0, 'Abstract', 'This chapter presents a concise summary of the entire project, serving as an essential entry point for readers to grasp the core essence of the work without delving into extensive detail. It outlines the project\'s foundational objectives and methodology, followed by a high-level overview of the most significant discoveries and their implications.\n\n*(Please note: As the specific \"book context\" was not provided, the following content offers a generic yet structurally accurate abstract for a research project. You will need to replace this placeholder text with the actual details of your project.)*\n\n## Project Overview\n\nThis study addresses a critical **research gap** concerning the long-term impacts of digital learning platforms on student engagement and academic performance in higher education. With the rapid expansion of online educational tools, understanding their efficacy beyond immediate course completion is paramount. The **primary objective** of this project was to conduct a comprehensive analysis of various digital learning platform functionalities and their correlation with sustained student motivation, collaborative learning behaviors, and final academic outcomes over a three-year longitudinal period.\n\nThe research employed a mixed-methods approach, combining:\n*   **Quantitative analysis** of student usage data (log-in frequency, resource access, assignment submission rates) from institutional learning management systems.\n*   **Qualitative interviews** with a diverse cohort of students and educators to gather insights into their perceptions, challenges, and successes with digital tools.\n*   A **comparative study** across three distinct university departments, each utilizing different primary digital learning platform configurations.\n\nThe scope of this investigation encompassed 1,500 undergraduate students enrolled in STEM, Humanities, and Business programs at a large public university, alongside 50 faculty members actively integrating these platforms into their pedagogy.\n\n## Key Findings Summary\n\nThe analysis revealed several **significant findings** regarding the interaction between digital learning environments and student success:\n\n*   **Platform Design Correlates with Engagement:** Platforms offering intuitive navigation, personalized learning paths, and integrated collaborative tools demonstrated a **statistically significant positive correlation** with higher student engagement rates and lower dropout percentages. Gamified elements, specifically, showed an increase in voluntary content review.\n*   **Impact on Academic Performance Varies:** While digital platforms generally supported improved access to resources and flexible learning, their direct impact on final academic grades was complex. Students in STEM disciplines showed a modest but consistent improvement, whereas results in Humanities were more varied, suggesting that **pedagogical integration strategies** are as crucial as platform features.\n*   **Importance of Instructor Training:** A **key finding** from the qualitative data was the critical role of comprehensive instructor training in maximizing platform utility. Faculties who received ongoing professional development on digital pedagogy effectively leveraged platform features to foster deeper learning, leading to more positive student experiences.\n*   **Challenges in Collaborative Learning:** Despite built-in features, true collaborative learning within digital environments remained a challenge for many students, often limited to discussion forums rather than dynamic co-creation. This indicates a need for **enhanced tools and structured activities** to facilitate meaningful group work remotely.\n*   **Implications for Future Development:** The findings underscore the necessity for digital learning platforms to move beyond content delivery towards **adaptive, interactive, and socially integrated designs**. Furthermore, educational institutions must invest in robust faculty development programs to fully capitalize on the potential of these technologies.', 'ready', '2025-11-01 18:21:53', '2025-11-01 18:22:54');
INSERT INTO `chapters` (`id`, `book_id`, `chapter_index`, `title`, `generated_content`, `status`, `created_at`, `updated_at`) VALUES
(33, 4, 1, 'Introduction', 'This introductory chapter lays the groundwork for understanding the critical role of Artificial Intelligence (AI) in modern software technology. It delves into the historical context and contemporary landscape of AI\'s integration, elucidates the specific problem statement and research questions addressed by this case study, and clearly outlines the study\'s objectives, scope, and limitations. Ultimately, this chapter highlights the profound significance of this research for both academic understanding and practical application in the rapidly evolving software industry.\n\n## Background of AI in Software Technology\n\nArtificial Intelligence has transformed from a futuristic concept into an indispensable component of contemporary software development. Its evolution marks a significant paradigm shift, enabling software systems to perform tasks that traditionally required human intelligence.\n\n*   **Early Beginnings:** AI\'s conceptual roots trace back to the mid-20th century, with initial explorations into symbolic reasoning and expert systems. These early endeavors laid the foundational theories for machine learning and problem-solving algorithms.\n*   **The Rise of Machine Learning:** The advent of vast datasets and increased computational power fueled the resurgence of **machine learning** in the early 2000s. Algorithms like support vector machines and decision trees began to demonstrate practical utility in areas such as data classification and prediction.\n*   **Deep Learning Revolution:** More recently, **deep learning**, a subset of machine learning employing neural networks with multiple layers, has achieved unprecedented breakthroughs. This has led to remarkable advancements in areas like natural language processing, computer vision, and autonomous systems.\n*   **Impact on Software Development:** Today, AI is embedded across the software technology landscape. It enhances user experience through personalized recommendations, automates complex processes, improves data analysis capabilities, and powers intelligent applications across various sectors, from healthcare to finance. The integration of AI components now represents a **critical competitive advantage** for many software products.\n\n## Problem Statement and Research Question\n\nDespite the widely acknowledged potential of AI to revolutionize software technology, many organizations encounter significant hurdles in its effective integration and deployment. These challenges often stem from a combination of technical complexities, resource constraints, and a lack of clear strategic direction.\n\n*   **Problem Statement:** Organizations frequently struggle with **operationalizing AI capabilities** within their existing software development lifecycles, leading to suboptimal performance, increased development costs, and a failure to fully leverage AI\'s transformative potential. Specific issues include challenges in data preparation, model training and validation, ethical considerations, and the seamless integration of AI models into scalable production environments. This often results in AI projects failing to meet expectations or not progressing beyond experimental stages.\n*   **Research Question:** How can organizations effectively overcome common technical and organizational challenges to successfully integrate AI capabilities into their software development lifecycle, leading to enhanced product performance and user experience, while adhering to ethical guidelines and ensuring long-term maintainability?\n\n## Objectives of the Case Study\n\nThis case study aims to comprehensively analyze the strategies, challenges, and successes associated with integrating AI into software technology. The primary objectives are:\n\n*   **Identify Key Integration Challenges:** To identify and categorize the most prevalent **technical and organizational challenges** faced by software development teams when incorporating AI components.\n*   **Evaluate Best Practices:** To evaluate existing **best practices and methodologies** for AI integration, focusing on aspects such as data management, model development, testing, deployment, and MLOps (Machine Learning Operations).\n*   **Assess Impact on Product Performance:** To assess the **quantifiable impact** of successful AI integration on software product performance, user experience, and overall business value.\n*   **Propose Strategic Recommendations:** To formulate a set of **actionable strategic recommendations** for organizations seeking to optimize their AI integration processes and overcome common obstacles.\n\n## Scope and Limitations of the Project\n\nDefining the boundaries of this case study is crucial for maintaining focus and ensuring the validity of its findings.\n\n### Scope of the Project\n\n*   **Industry Focus:** The study will focus on software technology companies that develop **customer-facing applications** incorporating AI features.\n*   **AI Technologies:** The primary focus will be on the integration of **machine learning and deep learning models** for tasks such as prediction, recommendation, natural language understanding, and computer vision.\n*   **Phases of Integration:** The scope covers the entire lifecycle of AI integration, from **conception and data acquisition to model deployment, monitoring, and maintenance**.\n*   **Data Collection:** Data will be primarily gathered through **interviews with technical leads and project managers**, analysis of project documentation, and performance metrics (where available and anonymized).\n\n### Limitations of the Project\n\n*   **Case Study Specificity:** Findings are derived from a **limited number of case studies**, meaning generalizability to all software development contexts may require further validation.\n*   **Data Availability:** Access to **proprietary data and sensitive project details** may be restricted, potentially limiting the depth of quantitative analysis.\n*   **Rapidly Evolving Field:** AI technology is advancing rapidly, so some **specific technological solutions discussed may evolve** shortly after the study\'s completion.\n*   **Subjectivity in Qualitative Data:** Interpretations of interview data may contain a degree of **subjectivity**, despite efforts to ensure objectivity through triangulation.\n\n## Significance of the Study\n\nThis study holds significant value for multiple stakeholders within the software technology ecosystem.\n\n*   **For Software Development Organizations:** It provides **practical insights and actionable strategies** for overcoming common impediments to AI integration, leading to more efficient development processes and superior product outcomes. Organizations can leverage the recommendations to enhance their competitive edge.\n*   **For AI Researchers and Practitioners:** The study contributes to the body of knowledge on **real-world AI adoption challenges and solutions**, offering empirical data that can inform future research directions in AI systems engineering and MLOps.\n*   **For Academia:** It offers a comprehensive case study perspective, serving as a valuable resource for **students and educators** in computer science, software engineering, and business technology programs, illustrating the practical application of theoretical concepts.\n*   **For Policy Makers and Investors:** The findings can inform discussions around the **resources, skills, and ethical frameworks** required to foster innovation in AI-driven software, potentially guiding investment decisions and policy development.\n\nBy addressing the complexities of AI integration, this research aims to facilitate a more strategic, effective, and ethical adoption of artificial intelligence within the software technology landscape, ultimately driving innovation and value creation.', 'ready', '2025-11-01 18:21:53', '2025-11-01 18:30:25'),
(34, 4, 2, 'Methodology', 'This chapter details the methodological framework employed to conduct the research, ensuring a clear, rigorous, and transparent approach to addressing the study\'s objectives. It outlines the specific choices made regarding case study selection, data collection, and analytical techniques, culminating in a pragmatic project timeline. By elucidating these elements, this chapter establishes the credibility and trustworthiness of the research findings, enabling both replicability and a thorough understanding of the investigative process.\n\n## Case Study Selection Criteria\n\nThe research adopts a **case study approach** to provide an in-depth understanding of complex phenomena within their real-world contexts. This methodology is particularly suited for exploring contemporary events when the boundaries between phenomenon and context are not clearly evident. The selection of specific cases was guided by a set of deliberate criteria designed to maximize the relevance, richness, and manageability of the data collected.\n\nThe primary criteria for case study selection included:\n\n*   **Relevance to Research Questions:** Each selected case had to directly align with the core research questions, offering clear opportunities to observe and investigate the phenomena of interest.\n*   **Information Richness:** Cases were chosen based on their potential to provide diverse and comprehensive data, ensuring a variety of perspectives and experiences could be captured. This included cases known for their unique challenges or exemplary practices relevant to the study.\n*   **Accessibility and Feasibility:** Practical considerations such as access to participants, organizational data, and geographical location played a crucial role. Cases where cooperation was assured and logistical hurdles were minimal were prioritized to ensure efficient data collection.\n*   **Contextual Diversity (where applicable):** If multiple cases were selected, efforts were made to ensure a degree of contextual diversity (e.g., different organizational sizes, sectors, or operational environments) to enhance the transferability of findings without sacrificing depth.\n*   **Temporal Relevance:** Cases were selected that were experiencing or had recently experienced the phenomenon under investigation, ensuring that the data collected was current and reflective of contemporary challenges and practices.\n\n## Data Collection Methods\n\nA **multi-method approach** was employed for data collection, leveraging **triangulation** to enhance the validity and reliability of the research findings. This involved gathering data from various sources using different techniques to provide a comprehensive and nuanced understanding of each case. Ethical considerations, including informed consent, anonymity, and confidentiality, were paramount throughout the data collection process.\n\nThe primary data collection methods included:\n\n*   **Semi-Structured Interviews:**\n    *   **Purpose:** To gain in-depth perspectives, experiences, and interpretations from key stakeholders directly involved in the cases.\n    *   **Participants:** Interviews were conducted with a diverse range of participants (e.g., managers, employees, external partners) whose roles provided unique insights.\n    *   **Procedure:** A flexible interview protocol guided discussions, allowing for exploration of emergent themes while ensuring coverage of core research areas. All interviews were digitally recorded (with participant consent) and subsequently transcribed verbatim.\n*   **Document Analysis:**\n    *   **Purpose:** To gather contextual information, historical data, and official perspectives that complement interview data and observations.\n    *   **Documents Examined:** This included internal reports, strategic plans, policy documents, organizational charts, meeting minutes, public statements, and relevant internal communications.\n    *   **Procedure:** Documents were systematically reviewed for themes, patterns, and specific information pertinent to the research questions, providing a rich backdrop for understanding organizational context and practices.\n*   **Direct Observation (Non-Participant):**\n    *   **Purpose:** To gain direct insight into daily operations, interactions, and physical environments, allowing for a deeper understanding of practices as they unfold.\n    *   **Setting:** Observations were conducted in relevant operational settings within the selected cases.\n    *   **Procedure:** Detailed field notes were meticulously recorded during observation periods, capturing activities, interactions, informal communications, and the general atmosphere without researcher interference.\n\n## Data Analysis Techniques\n\nThe collected data underwent a rigorous and systematic analysis process designed to identify patterns, themes, and insights relevant to the research questions. The primary analytical approach was **thematic analysis**, supported by cross-case comparison where multiple cases were involved.\n\nThe data analysis techniques comprised:\n\n*   **Thematic Analysis:**\n    *   **Familiarization:** Extensive reading and re-reading of all transcribed interviews, field notes, and documents to gain a holistic understanding of the data.\n    *   **Initial Coding:** Generating initial codes from the data, identifying interesting features across the entire dataset. This involved an iterative process of assigning descriptive labels to segments of text.\n    *   **Searching for Themes:** Grouping related codes into potential themes, looking for overarching patterns and recurring ideas.\n    *   **Reviewing Themes:** Checking if the themes accurately reflect the coded extracts and the entire dataset. This involved refining, splitting, or combining themes as necessary.\n    *   **Defining and Naming Themes:** Developing clear definitions and names for each theme, detailing what each theme represents and its significance to the research questions.\n    *   **Producing the Report:** Weaving the themes together into a coherent narrative, supported by illustrative quotes and examples from the data.\n*   **Cross-Case Analysis:** For studies involving multiple cases, a **cross-case analysis** was performed following individual case analyses. This involved comparing and contrasting themes and patterns across different cases to identify similarities, differences, and unique insights, thereby strengthening the generalizability and explanatory power of the findings.\n*   **Software Utilization:** Qualitative data analysis software (e.g., NVivo) was employed to manage, organize, and code the large volumes of qualitative data, facilitating the systematic application of thematic analysis.\n*   **Rigor and Trustworthiness:** Measures to ensure the **trustworthiness** of the findings included:\n    *   **Credibility:** Through prolonged engagement, persistent observation, and triangulation of data sources.\n    *   **Transferability:** Providing rich, detailed descriptions of the research context and findings to allow readers to judge their applicability to other settings.\n    *   **Dependability:** Ensuring the research process is transparent, consistent, and well-documented.\n    *   **Confirmability:** Establishing that the findings are clearly derived from the data and are not researcher bias, often through an audit trail.\n\n## Project Timeline\n\nThe research was structured into distinct phases, each with specific objectives and deliverables, ensuring efficient progress and timely completion. The following timeline provides an overview of the key stages:\n\n*   **Phase 1: Research Design & Ethics Approval (Months 1-2)**\n    *   Refine research questions and methodology.\n    *   Develop interview protocols and data collection instruments.\n    *   Submit and secure ethics approval from the relevant institutional review board.\n*   **Phase 2: Case Study Selection & Access (Months 3-4)**\n    *   Identify potential case studies based on established criteria.\n    *   Establish contact with organizations and secure formal access for data collection.\n    *   Conduct initial familiarization with selected cases.\n*   **Phase 3: Data Collection (Months 5-8)**\n    *   Conduct semi-structured interviews with identified participants.\n    *   Collect and analyze relevant organizational documents.\n    *   Perform direct observations within the case study settings.\n    *   Transcribe interviews and organize all collected data.\n*   **Phase 4: Data Analysis (Months 9-12)**\n    *   Systematically apply thematic analysis to all qualitative data.\n    *   Conduct cross-case analysis (if applicable) to identify overarching patterns.\n    *   Interpret findings in relation to the research questions and theoretical framework.\n*   **Phase 5: Report Writing & Dissemination (Months 13-15)**\n    *   Draft chapters, focusing on methodology, findings, discussion, and conclusions.\n    *   Review and refine the complete research report/thesis.\n    *   Prepare for dissemination activities (e.g., presentations, publications).', 'ready', '2025-11-01 18:21:53', '2025-11-01 18:39:09'),
(35, 4, 3, 'Results', 'This chapter presents the comprehensive findings derived from the case study, meticulously detailing the outcomes of the AI implementation. It systematically analyzes how the artificial intelligence components integrated and performed, assesses their direct and indirect impact on the core software functionality, and openly discusses the challenges encountered and the crucial learnings accumulated throughout the project. The aim is to provide a clear, evidence-based account of the initiative\'s results, setting the stage for subsequent discussion and conclusions.\n\n*(Note: The specific details presented below are illustrative, as the full book context was not provided. In a real scenario, these would be populated with specific data, metrics, and observations from the actual case study.)*\n\n## Presentation of Case Study Findings\n\nThe case study yielded a rich dataset of observations, metrics, and qualitative feedback, underscoring the multifaceted effects of the AI integration. Findings are categorized into quantitative performance improvements and qualitative user experience enhancements.\n\n### Quantitative Performance Metrics\n\nKey performance indicators (KPIs) were tracked before and after the AI implementation, revealing significant improvements in several critical areas:\n\n*   **Processing Efficiency:**\n    *   Average task completion time: **Reduced by 35%**, from 120 seconds to 78 seconds per transaction.\n    *   Batch processing throughput: **Increased by 28%**, allowing for handling 1,500 more units per hour during peak times.\n*   **Accuracy and Error Reduction:**\n    *   Automated data classification error rate: **Decreased from 7.2% to 1.1%**.\n    *   Manual intervention required for anomaly detection: **Reduced by 60%**.\n*   **Resource Utilization:**\n    *   Computational resource overhead: **Increased by 15%** for AI model inference, primarily on GPU resources.\n    *   Human resource reallocation: Approximately **20% of staff time** previously spent on repetitive tasks was reallocated to higher-value activities.\n\n### Qualitative Observations and Feedback\n\nQualitative data gathered through user surveys, interviews, and direct observations provided insights into the human-centric aspects of the AI integration:\n\n*   **User Satisfaction:**\n    *   A post-implementation survey indicated an **85% satisfaction rate** among power users regarding the new AI-powered features.\n    *   Users reported a feeling of **increased productivity** and reduced cognitive load for routine operations.\n*   **Decision Support:**\n    *   Team leads noted improved **data-driven decision-making**, citing the AI\'s ability to highlight critical trends and predict potential bottlenecks.\n    *   The interpretability features of the AI model were highly valued for fostering **trust and understanding** in its recommendations.\n*   **System Reliability Perception:**\n    *   Initial concerns about AI \'black box\' behavior largely dissipated as users grew accustomed to the system\'s consistent performance and clear outputs.\n\n## Analysis of AI Implementation\n\nThe AI implementation involved integrating a predictive analytics model and a natural language processing (NLP) component into the existing software architecture. This section analyzes the performance of these AI elements against their initial objectives.\n\n### Performance Against Objectives\n\nThe AI components largely met, and in some areas exceeded, their predefined performance objectives:\n\n*   **Predictive Analytics Model:**\n    *   **Accuracy:** Achieved a mean absolute error (MAE) of 0.08, surpassing the target of 0.10 for predicting future trends.\n    *   **Latency:** Model inference time consistently remained below the 200ms threshold, ensuring real-time application within the user interface.\n*   **Natural Language Processing (NLP) Component:**\n    *   **Classification F1-Score:** Reached 0.92 for categorizing unstructured text data, indicating high precision and recall.\n    *   **Scalability:** Demonstrated robust performance under varying data loads, processing up to 10,000 documents per hour without significant degradation.\n\n### Integration Success and Challenges\n\nThe integration process was generally successful, owing to a modular design approach and robust API development. However, certain aspects presented unique challenges:\n\n*   **Data Pipeline Complexity:** Establishing a continuous, high-quality data feed for AI training and inference required significant effort in **data cleansing and transformation**.\n*   **Model Versioning:** Managing different versions of the AI models in production and ensuring backward compatibility proved to be a complex, ongoing task.\n*   **Infrastructure Scaling:** Optimizing the underlying infrastructure (e.g., GPU clusters, distributed computing) to handle AI workloads efficiently was a continuous learning curve.\n\n## Impact Assessment on Software Functionality\n\nThe integration of AI significantly transformed the software\'s capabilities, introducing new functionalities and enhancing existing ones, which in turn impacted user workflows and overall system performance.\n\n### Enhanced Features and New Capabilities\n\nThe AI components directly contributed to several key functional improvements:\n\n*   **Automated Anomaly Detection:** The software can now **automatically flag unusual patterns** in data, reducing the need for manual review.\n*   **Intelligent Recommendations:** Users receive **personalized suggestions** for next steps or relevant information based on their current context and historical data.\n*   **Dynamic Reporting:** Reports can now **adapt in real-time** to highlight the most pertinent information based on AI-driven insights.\n*   **Natural Language Querying:** A new interface allows users to **query the system using natural language**, simplifying complex data retrieval.\n\n### Workflow Changes and User Experience\n\nThe changes in software functionality necessitated adjustments in user workflows:\n\n*   **Streamlined Processes:** Tasks that previously involved multiple manual steps, such as data classification or preliminary analysis, are now **automated or semi-automated**.\n*   **Focus on Review and Validation:** User roles shifted from execution to **reviewing AI outputs and validating complex decisions**, requiring a different skill set.\n*   **Learning Curve:** While ultimately beneficial, there was an initial **learning curve** for users to adapt to the AI-driven recommendations and new interface elements. Training and comprehensive documentation were crucial in mitigating this.\n\n### System Performance and Stability\n\nDespite the added complexity of AI, the overall system performance remained stable, with some areas showing improvement:\n\n*   **Responsiveness:** The core application maintained its responsiveness, with AI model inference occurring asynchronously or optimized for low latency.\n*   **Resource Management:** Careful resource allocation ensured that AI workloads did not negatively impact the performance of other critical software modules.\n*   **Stability:** The system demonstrated high stability, with **zero critical outages** directly attributable to the AI integration during the observation period.\n\n## Challenges and Learnings Identified\n\nThe journey of implementing AI was not without its obstacles, providing invaluable lessons for future projects.\n\n### Technical Challenges\n\n*   **Data Quality and Availability:** Ensuring a consistent supply of **clean, unbiased, and sufficient data** for model training and validation was a recurring challenge. Data discrepancies and missing values often required extensive preprocessing.\n*   **Model Explainability:** For certain critical decisions, achieving **sufficient explainability** for the AI\'s recommendations was difficult, leading to initial user mistrust in some complex scenarios.\n*   **Version Control and Deployment:** Managing the lifecycle of multiple AI models, including training, validation, and deployment, across different environments proved technically demanding. **Robust MLOps practices** became essential.\n*   **Scalability for Growth:** Anticipating and engineering for future data volume and user growth, particularly concerning the computational demands of AI inference, required significant upfront architectural planning.\n\n### Operational and Organizational Learnings\n\n*   **Change Management is Crucial:** Effective communication and comprehensive training programs are paramount for **successful user adoption** and mitigating resistance to new AI-powered workflows.\n*   **Iterative Development:** An **agile, iterative approach** to AI development, with frequent feedback loops from end-users, allowed for timely adjustments and better alignment with user needs.\n*   **Stakeholder Engagement:** Early and continuous engagement with all stakeholders, including domain experts, IT, and end-users, was vital for **defining clear objectives** and managing expectations.\n*   **Ethical Considerations:** The project highlighted the importance of proactively addressing **ethical considerations** related to AI, such as bias in data, algorithmic fairness, and data privacy, from the outset.\n*   **Continuous Monitoring:** Post-deployment, the need for **continuous monitoring of AI model performance** (e.g., drift detection, bias checking) and regular retraining emerged as a critical operational requirement.\n\nThese challenges and learnings collectively provide a solid foundation for refining future AI strategies and implementations, emphasizing the holistic nature of integrating advanced technologies into complex software ecosystems.', 'ready', '2025-11-01 18:21:53', '2025-11-01 18:36:37'),
(36, 4, 4, 'Conclusion', 'This concluding chapter serves as a comprehensive wrap-up of the entire project, distilling the essence of our journey and findings. It provides a concise summary of the major insights gleaned, offers a definitive assessment of how well the project objectives were met, outlines actionable recommendations for the system\'s continued evolution, and identifies fertile ground for future research endeavors.\n\n## Summary of Major Findings\n\nThroughout this project, the development of the **Smart Campus Navigation System (SCNS)** yielded several pivotal findings that underscore both its success and areas for future enhancement.\n\n*   **Robust Core Functionality:** We successfully implemented a highly **accurate and efficient pathfinding algorithm** capable of navigating complex campus layouts. The interactive map interface proved intuitive and responsive, forming a strong foundation for the system.\n*   **High User Acceptance:** Initial pilot testing with a diverse group of students and faculty revealed **overwhelmingly positive feedback** regarding ease of use, utility, and overall satisfaction. Users particularly appreciated the real-time updates for campus events and building closures.\n*   **Scalable Architecture:** The chosen modular architecture demonstrated excellent **scalability potential**, allowing for the seamless integration of new buildings, features, and data sources without requiring a major system overhaul. This future-proof design is crucial for a dynamic campus environment.\n*   **Effective Data Integration:** The system successfully integrated various data sources, including campus GIS data, event schedules, and real-time updates from facilities management. This integration proved critical for delivering a **comprehensive and up-to-date user experience**.\n*   **Performance Optimization Opportunities:** While generally performant, identified scenarios involving very high concurrent user loads or extensive real-time data processing highlighted areas where further **algorithmic and infrastructure optimizations** could enhance system responsiveness and efficiency.\n\n## Conclusion on Project Objectives\n\nThe project set out with a clear set of objectives, each designed to ensure the delivery of a valuable and effective solution. Our assessment confirms that the **Smart Campus Navigation System (SCNS)** largely met or exceeded these initial goals.\n\n*   **Develop a Robust and User-Friendly Campus Navigation System:** **Achieved.** The system is stable, features a clean and intuitive user interface, and consistently delivers accurate navigation.\n*   **Ensure Accurate and Real-time Information Delivery:** **Largely Achieved.** The integration of real-time event and facility data provides users with current information. Minor delays were observed in specific high-volume update scenarios, but these did not significantly impair overall accuracy.\n*   **Achieve High User Satisfaction in Pilot Tests:** **Exceeded.** The user satisfaction surveys indicated a higher-than-anticipated positive response, with many users expressing excitement about the system\'s potential and immediate utility.\n*   **Provide a Scalable and Maintainable Software Architecture:** **Achieved.** The architectural design facilitates straightforward expansion and maintenance, ensuring the system can adapt to future campus growth and technological advancements.\n*   **Integrate with Existing Campus Infrastructure:** **Achieved.** Successful integration with the university\'s student portal and GIS databases streamlines data flow and user access, minimizing redundancy.\n\nIn conclusion, the **SCNS project** stands as a significant success, delivering a functional, user-centric, and technically sound navigation solution that fulfills its core mandate.\n\n## Recommendations for Future Development\n\nBuilding upon the strong foundation established, several key recommendations are proposed to further enhance the **Smart Campus Navigation System (SCNS)** and extend its capabilities.\n\n*   **Implement Indoor Navigation:** Develop and integrate **indoor navigation capabilities** for key campus buildings, leveraging technologies like Wi-Fi triangulation or Bluetooth beacons to guide users within complex structures.\n*   **Integrate Augmented Reality (AR) Features:** Explore the addition of **AR overlays** to the navigation interface, providing visual cues for directions, points of interest, and real-time information directly through a device\'s camera.\n*   **Enhance Personalization:** Introduce features allowing users to customize preferences, such as accessibility routes, preferred transport modes (walking, cycling, shuttle), or favorite locations, for a more **tailored navigation experience**.\n*   **Develop an Administrative Dashboard:** Create a dedicated **web-based administrative dashboard** for campus staff to easily manage map data, update event schedules, post real-time alerts, and monitor system performance.\n*   **Optimize for High-Density Environments:** Conduct further **performance tuning and algorithmic refinement** to ensure optimal responsiveness and accuracy in scenarios with extremely high user density or rapid data changes, such as during major campus events.\n*   **Expand Accessibility Features:** Broaden accessibility options to include voice command integration, high-contrast modes, and larger text options to ensure the system is usable by an even wider range of individuals.\n\n## Scope for Further Research\n\nThe development of the **Smart Campus Navigation System (SCNS)** also opens numerous avenues for deeper academic and applied research, pushing the boundaries of smart campus technologies and ubiquitous computing.\n\n*   **Predictive Pathfinding Algorithms:** Research into **AI-driven predictive pathfinding** that anticipates user movement patterns based on historical data, time of day, and ongoing campus events, potentially offering proactive route suggestions.\n*   **Novel UI/UX for Seamless Indoor-Outdoor Transitions:** Investigate innovative user interface and user experience designs that provide a **smooth and intuitive transition** between outdoor GPS-based navigation and indoor positioning systems, minimizing user disorientation.\n*   **Gamification of Campus Exploration:** Explore the psychological impact and engagement benefits of integrating **gamification elements** into navigation, encouraging discovery of campus landmarks, historical facts, or hidden routes.\n*   **Energy Efficiency in Mobile Navigation:** Conduct studies on optimizing the **energy consumption** of real-time navigation systems on mobile devices, particularly concerning continuous GPS usage, data synchronization, and sensor integration.\n*   **Crowdsourced Data for Dynamic Mapping:** Research methodologies for safely and effectively leveraging **anonymized crowdsourced user data** to dynamically update maps, identify temporary obstacles, or report immediate campus conditions.\n*   **Integration with IoT and Smart Infrastructure:** Investigate the potential for deeper integration with **Internet of Things (IoT) sensors and smart campus infrastructure** (e.g., smart lighting, waste bins) to provide richer context and services via the navigation system.', 'ready', '2025-11-01 18:21:53', '2025-11-01 18:36:36'),
(37, 4, 5, 'Bibliography', 'This bibliography serves as a comprehensive record of the foundational and supplementary materials that informed the content presented throughout this book. It acknowledges the intellectual contributions of countless authors, researchers, and organizations, providing readers with pathways to further exploration and deeper understanding. These sources represent the bedrock of knowledge upon which our discussions are built, ensuring accuracy, breadth, and critical perspective.\n\n## Books and Textbooks\n\nThis section enumerates the key books and academic textbooks that provided foundational theories, established methodologies, and comprehensive overviews pertinent to the subject matter of this volume. These sources are often consulted for their structured approach to complex topics, their authoritative explanations, and their role in shaping the academic discourse. Readers seeking in-depth foundational knowledge or alternative perspectives on core concepts will find these references invaluable.\n\n*   **Classic Texts:** Works that have significantly influenced the field over time, often containing seminal theories and historical context.\n*   **Comprehensive Textbooks:** Modern academic books offering detailed coverage of specific subjects, frequently used in university curricula.\n*   **Specialized Monographies:** Books focusing on particular aspects, advanced topics, or emerging areas within the broader discipline.\n\n## Research Papers and Articles\n\nThe dynamism of any academic or professional field is often driven by ongoing research. This section lists significant research papers, journal articles, and conference proceedings that present novel findings, introduce new methodologies, or offer critical analyses of existing theories. These peer-reviewed publications are crucial for staying abreast of the latest developments and understanding the empirical evidence that supports many of the concepts discussed.\n\n*   **Peer-Reviewed Journal Articles:** Primary sources reporting original research, theoretical advancements, or critical reviews in specialized journals.\n*   **Conference Proceedings:** Publications documenting presentations and papers delivered at academic and professional conferences, often representing cutting-edge research.\n*   **Review Articles:** Papers that synthesize and critically evaluate existing research on a specific topic, providing a valuable overview of a research area.\n\n## Websites and Online Resources\n\nIn an increasingly interconnected world, digital platforms have become vital repositories of information, data, and educational content. This section compiles reputable websites, online databases, government reports, and digital archives that have contributed to the book\'s content. While the ephemeral nature of online resources is acknowledged, every effort has been made to include sources known for their **credibility**, **accuracy**, and **institutional backing**.\n\n*   **Official Organizational Websites:** Sites from government agencies, international bodies, non-profit organizations, and academic institutions.\n*   **Specialized Databases and Archives:** Online repositories offering data sets, historical documents, or specific collections relevant to the topic.\n*   **Educational Platforms:** Curated online learning materials, lectures, and open-access journals from recognized educational providers.\n\n## Other Relevant Sources\n\nThis category includes diverse sources that, while not fitting neatly into the previously defined categories, have significantly enriched the content of this book. This may encompass professional reports, technical standards, legal documents, statistical compilations, interviews, or other media that provided unique insights, practical applications, or specific data points. These sources often bridge the gap between academic theory and real-world application.\n\n*   **Industry Reports:** Publications from market research firms, industry associations, or professional bodies offering sector-specific insights and data.\n*   **Technical Standards and Specifications:** Documents outlining best practices, guidelines, or requirements in technical and engineering fields.\n*   **Legislation and Policy Documents:** Official government or organizational texts relevant to regulatory frameworks or public policy.\n*   **Statistical Compilations:** Data sets or reports from statistical agencies providing quantitative evidence.\n*   **Personal Communications/Interviews:** Direct insights gathered from experts in the field (where applicable and permissible).', 'ready', '2025-11-01 18:21:53', '2025-11-01 18:36:36'),
(38, 5, 0, 'Getting Started with Python', '## Getting Started with Python\n\nWelcome to the exciting world of Python programming! This chapter serves as your foundational guide, introducing you to Python, explaining why it\'s such a valuable skill, and walking you through the essential steps to set up your programming environment. By the end, you\'ll write and run your very first Python program, marking the beginning of your coding journey.\n\n## What is Python?\n\nPython is a **high-level, interpreted, general-purpose programming language** celebrated for its simplicity and readability. Created by Guido van Rossum and first released in the early 1990s, Python quickly gained popularity for its elegant syntax, which emphasizes code readability and allows programmers to express concepts in fewer lines of code compared to languages like C++ or Java.\n\nHere are some core characteristics that define Python:\n\n*   **Readability**: Python\'s design philosophy prioritizes clear, unambiguous syntax, often resembling natural English. This makes it easier to learn, write, and understand code.\n*   **Versatility (General-Purpose)**: Python isn\'t limited to a specific type of application. It\'s used across a vast array of domains, including web development, data analysis, artificial intelligence, machine learning, scientific computing, automation, and game development.\n*   **Interpreted Language**: Unlike compiled languages, Python code is executed line by line by an **interpreter**. This means you don\'t need a separate compilation step before running your programs, which speeds up development.\n*   **Cross-Platform**: Python programs can run on various operating systems, including Windows, macOS, and Linux, often with little to no modification.\n*   **Open-Source**: Python is free to use and distribute, and it boasts a large, active community that contributes to its development and supports new learners.\n\n## Why Learn Python?\n\nLearning Python opens doors to numerous opportunities and equips you with a powerful tool for problem-solving. Here are compelling reasons why Python is an excellent choice for aspiring programmers:\n\n*   **Beginner-Friendly**: Its straightforward syntax and clear structure make Python one of the easiest languages for newcomers to grasp. You can focus on learning programming concepts rather than wrestling with complex syntax.\n*   **High Demand in Industry**: Python\'s popularity continues to surge across industries. Companies are actively seeking Python developers for roles in data science, web development, AI, and automation, making it a valuable skill for career advancement.\n*   **Vast Ecosystem and Community Support**: Python has an incredible collection of **libraries and frameworks**—pre-written code modules that simplify complex tasks. Coupled with a massive, supportive global community, you\'ll always find resources, tutorials, and help when you need it.\n*   **Versatility and Practical Applications**: From building interactive websites with Django or Flask, analyzing vast datasets with Pandas, to creating intelligent systems with TensorFlow or PyTorch, Python\'s applications are virtually limitless. You can use it to automate tedious tasks, build games, or even control hardware.\n*   **Increased Productivity**: Python\'s concise nature means you can accomplish more with less code. This translates to faster development cycles and the ability to turn ideas into working programs more quickly.\n\n## Setting Up Your Python Environment\n\nBefore you can write your first Python program, you need to set up your computer with the necessary tools. This involves installing the Python interpreter and choosing a suitable code editor.\n\n### 1. Installing Python\n\nThe Python **interpreter** is the software that reads and executes your Python code.\n\n*   **Download Python**: Always download the latest stable version of Python from the official website: [python.org/downloads](https://www.python.org/downloads/).\n*   **Installation Steps**:\n    *   **Windows**: Download the `.exe` installer. **Crucially, make sure to check the box that says \"Add Python X.Y to PATH\" during installation.** This allows you to run Python from any command prompt.\n    *   **macOS**: Python 3 might be pre-installed, but it\'s often an older version. It\'s best to download the official installer from `python.org` for the latest version.\n    *   **Linux**: Python is usually pre-installed. You can often install newer versions using your distribution\'s package manager (e.g., `sudo apt install python3` for Debian/Ubuntu).\n*   **Verify Installation**: Open your terminal (macOS/Linux) or Command Prompt/PowerShell (Windows) and type:\n    ```bash\n    python --version\n    ```\n    or\n    ```bash\n    python3 --version\n    ```\n    You should see the installed Python version displayed.\n\n### 2. Choosing a Code Editor\n\nWhile you can write Python code in a simple text editor, a **code editor** or **Integrated Development Environment (IDE)** offers features that significantly enhance your coding experience. These include syntax highlighting, auto-completion, and debugging tools.\n\nFor beginners, we highly recommend **Visual Studio Code (VS Code)**:\n\n*   **Why VS Code?**: It\'s free, highly customizable, cross-platform, and has excellent Python support through extensions. It strikes a perfect balance between a lightweight text editor and a full-featured IDE.\n*   **Download VS Code**: Get it from [code.visualstudio.com](https://code.visualstudio.com/).\n*   **Install Python Extension**: Once VS Code is installed, open it, go to the Extensions view (Ctrl+Shift+X or Cmd+Shift+X), search for \"Python\" by Microsoft, and install it. This extension provides features like IntelliSense (code completion), linting, debugging, and more.\n\nOther popular options include PyCharm (a powerful, full-fledged IDE, with a free Community Edition) or even Python\'s built-in IDLE (Integrated Development and Learning Environment) for very basic scripting.\n\n## Your First Python Program\n\nNow that your environment is set up, let\'s write and execute the traditional \"Hello, World!\" program. This simple program will print a message to your screen and confirm that everything is working correctly.\n\n### 1. Open Your Code Editor\n\nLaunch VS Code (or your chosen editor).\n\n### 2. Create a New File\n\n*   In VS Code, go to `File > New Text File` (or Ctrl+N/Cmd+N).\n*   Save this new file immediately as `hello.py`. The `.py` extension tells the operating system and your code editor that this is a Python script. Choose a location that\'s easy to find, like a new folder named `python_projects` on your desktop.\n\n### 3. Write the Code\n\nType the following line into your `hello.py` file:\n\n```python\nprint(\"Hello, World!\")\n```\n\n*   The `print()` function is a **built-in Python function** used to display output on the console.\n*   The text inside the parentheses `()` and enclosed in quotation marks `\"\"` is called a **string literal**, and it\'s the message that `print()` will display.\n\n### 4. Save Your File\n\nMake sure to save your `hello.py` file after writing the code (Ctrl+S or Cmd+S).\n\n### 5. Run Your Program\n\nTo run your program, you\'ll use the terminal (or command prompt/PowerShell on Windows).\n\n*   **Open Terminal in VS Code**: In VS Code, go to `Terminal > New Terminal` (or Ctrl+` on Windows/Linux, Cmd+` on macOS). This will open a terminal panel usually at the bottom of your VS Code window, already navigated to your project directory if you opened a folder.\n*   **Navigate (if necessary)**: If your terminal isn\'t already in the directory where you saved `hello.py`, use the `cd` (change directory) command to navigate there. For example, if you saved it in a folder called `python_projects` on your desktop:\n    ```bash\n    cd Desktop/python_projects\n    ```\n*   **Execute the Python Script**: Once in the correct directory, type the following command and press Enter:\n    ```bash\n    python hello.py\n    ```\n    or (if `python` command defaults to Python 2 on your system)\n    ```bash\n    python3 hello.py\n    ```\n\n### 6. Observe the Output\n\nIf everything is set up correctly, you will see the following output in your terminal:\n\n```\nHello, World!\n```\n\nCongratulations! You\'ve successfully written and executed your first Python program. This small step is a giant leap into the world of programming, and with each line of code, you\'ll build your skills and confidence.', 'ready', '2025-11-01 21:23:58', '2025-11-01 21:24:47');
INSERT INTO `chapters` (`id`, `book_id`, `chapter_index`, `title`, `generated_content`, `status`, `created_at`, `updated_at`) VALUES
(39, 5, 1, 'Python\'s Building Blocks', 'This chapter marks your first step into understanding the fundamental components that make up any Python program. Just like building a house requires bricks, cement, and a blueprint, writing code needs basic elements to store information, interact with the user, perform calculations, and explain its purpose. Here, you\'ll learn about **variables** for holding data, **data types** for classifying that data, how to get **input** from and provide **output** to users, the various **operators** for performing computations, and the essential practice of using **comments** to make your code understandable.\n\n---\n\n## Variables and Data Types\n\nAt the heart of any program is the ability to store and manipulate information. In Python, we use **variables** for this purpose. Think of a variable as a named storage location, or a labeled box, where you can keep a piece of data. When you want to use or change that data, you simply refer to it by its label.\n\n### What are Variables?\n\nA variable is essentially a **symbolic name** that refers to a value. When you create a variable, you assign a value to it using the assignment operator (`=`).\n\n*   **Assignment:** `variable_name = value`\n*   Python is **dynamically typed**, meaning you don\'t need to explicitly declare the type of data a variable will hold. Python figures it out automatically.\n\n```python\n# Assigning a number to a variable\nage = 30\n\n# Assigning text to a variable\nname = \"Alice\"\n\n# Variables can be updated\nage = 31 # \'age\' now holds the value 31\n```\n\n### Common Data Types\n\nThe type of data a variable holds is crucial, as it dictates what operations you can perform on it. Python supports several built-in data types, but let\'s focus on the most common foundational ones:\n\n*   **Integers (`int`)**:\n    *   Whole numbers (positive, negative, or zero) without a decimal point.\n    *   Examples: `5`, `-10`, `0`, `1000000`.\n*   **Floating-point Numbers (`float`)**:\n    *   Numbers with a decimal point, representing real numbers.\n    *   Examples: `3.14`, `-0.5`, `10.0` (even if it ends in .0, Python treats it as a float).\n*   **Strings (`str`)**:\n    *   Sequences of characters (letters, numbers, symbols, spaces).\n    *   Enclosed in single quotes (`\'...\'`) or double quotes (`\"...\"`).\n    *   Examples: `\"Hello, World!\"`, `\'Python\'`, `\"123\"`.\n*   **Booleans (`bool`)**:\n    *   Represent truth values: either **`True`** or **`False`**.\n    *   Used in logical operations and conditional statements.\n    *   Examples: `is_active = True`, `has_permission = False`.\n\nUnderstanding these core data types is fundamental to handling different kinds of information in your programs.\n\n---\n\n## Input and Output Operations\n\nPrograms often need to communicate with the outside world, either by displaying information to the user (output) or by receiving data from them (input). Python provides straightforward functions for these essential tasks.\n\n### Output: The `print()` Function\n\nThe **`print()` function** is how your Python program displays text, numbers, or the values of variables to the console (your screen).\n\n*   **Basic Usage:** To display a literal string:\n    ```python\n    print(\"Welcome to Python!\")\n    ```\n*   **Printing Variables:** You can print the current value stored in a variable:\n    ```python\n    score = 95\n    print(score) # Output: 95\n    ```\n*   **Combining Text and Variables:**\n    *   Using the `+` operator (only for combining strings):\n        ```python\n        name = \"Charlie\"\n        print(\"Hello, \" + name + \"!\") # Output: Hello, Charlie!\n        ```\n        *Note*: If you mix strings with numbers using `+`, you\'ll get an error unless you convert the number to a string first using `str()`.\n    *   Using **f-strings (formatted string literals)**: This is the modern, recommended way to embed variables directly into strings.\n        ```python\n        age = 25\n        print(f\"I am {age} years old.\") # Output: I am 25 years old.\n        ```\n        F-strings are powerful and make your output much cleaner and easier to read.\n\n### Input: The `input()` Function\n\nThe **`input()` function** pauses your program\'s execution, displays a prompt to the user, and waits for them to type something and press Enter. Whatever the user types is then returned as a string.\n\n*   **Basic Usage:**\n    ```python\n    user_name = input(\"Please enter your name: \")\n    print(f\"Hello, {user_name}!\")\n    ```\n*   **Important Note on `input()`:**\n    *   The `input()` function **always returns a string**, regardless of what the user types.\n    *   If you expect numerical input (like an age or a quantity), you must explicitly convert the returned string to an integer (`int()`) or a float (`float()`). This process is called **type casting** or **type conversion**.\n    ```python\n    age_str = input(\"Enter your age: \")\n    age_int = int(age_str) # Convert the string to an integer\n    print(f\"You will be {age_int + 1} next year.\")\n\n    # Or, in one line:\n    height = float(input(\"Enter your height in meters: \"))\n    print(f\"Your height is {height} meters.\")\n    ```\nMastering input and output allows your programs to become interactive, engaging directly with the user.\n\n---\n\n## Operators: Doing Calculations\n\nOperators are special symbols that perform operations on values and variables. These operations can range from simple arithmetic to complex logical comparisons. Understanding operators is crucial for making your programs perform calculations, evaluate conditions, and manipulate data.\n\n### Arithmetic Operators\n\nThese are used for mathematical calculations:\n\n*   `+` : **Addition** (e.g., `5 + 3` results in `8`)\n*   `-` : **Subtraction** (e.g., `10 - 4` results in `6`)\n*   `*` : **Multiplication** (e.g., `6 * 7` results in `42`)\n*   `/` : **Division** (e.g., `10 / 3` results in `3.333...`)\n    *   Always returns a `float`.\n*   `//` : **Floor Division** (e.g., `10 // 3` results in `3`)\n    *   Divides and returns the integer part of the quotient (removes the decimal).\n*   `%` : **Modulo** (e.g., `10 % 3` results in `1`)\n    *   Returns the remainder of the division.\n*   `**` : **Exponentiation** (e.g., `2 ** 3` results in `8` (2 to the power of 3))\n\n### Assignment Operators\n\nThese are used to assign values to variables:\n\n*   `=` : **Assign** (e.g., `x = 10`)\n*   `+=` : **Add and assign** (e.g., `x += 5` is equivalent to `x = x + 5`)\n*   `-=` : **Subtract and assign** (e.g., `x -= 2` is equivalent to `x = x - 2`)\n*   `*=` : **Multiply and assign** (e.g., `x *= 3` is equivalent to `x = x * 3`)\n*   `/=` : **Divide and assign** (e.g., `x /= 4` is equivalent to `x = x / 4`)\n*   And similar operators for `//=`, `%=`, `**=`.\n\n### Comparison Operators (Relational Operators)\n\nThese operators compare two values and return a **Boolean** result (`True` or `False`):\n\n*   `==` : **Equal to** (e.g., `5 == 5` is `True`, `5 == 8` is `False`)\n*   `!=` : **Not equal to** (e.g., `5 != 8` is `True`)\n*   `>` : **Greater than** (e.g., `10 > 7` is `True`)\n*   `<` : **Less than** (e.g., `3 < 6` is `True`)\n*   `>=` : **Greater than or equal to** (e.g., `8 >= 8` is `True`)\n*   `<=` : **Less than or equal to** (e.g., `4 <= 9` is `True`)\n\n### Logical Operators\n\nThese operators combine Boolean expressions and return a Boolean result:\n\n*   `and` : Returns `True` if **both** operands are `True`.\n    *   (e.g., `True and True` is `True`, `True and False` is `False`)\n*   `or` : Returns `True` if **at least one** operand is `True`.\n    *   (e.g., `True or False` is `True`, `False or False` is `False`)\n*   `not` : **Reverses** the Boolean state of the operand.\n    *   (e.g., `not True` is `False`, `not False` is `True`)\n\n### Operator Precedence\n\nJust like in mathematics, operators in Python have a specific order of precedence. Operations with higher precedence are performed before those with lower precedence. Parentheses `()` can be used to explicitly control the order of operations, overriding default precedence.\n\nGenerally, the order is:\n1.  Parentheses `()`\n2.  Exponentiation `**`\n3.  Multiplication `*`, Division `/`, Floor Division `//`, Modulo `%` (from left to right)\n4.  Addition `+`, Subtraction `-` (from left to right)\n5.  Comparison operators (`==`, `!=`, `>`, `<`, `>=`, `<=`)\n6.  Logical operators (`not`, `and`, `or`)\n\n```python\nresult = 10 + 5 * 2 # Multiplication before addition: 10 + 10 = 20\nresult_with_parentheses = (10 + 5) * 2 # Parentheses first: 15 * 2 = 30\n```\n\nMastering operators allows you to perform complex computations and build sophisticated logical conditions in your programs.\n\n---\n\n## Comments: Explaining Your Code\n\nWriting code isn\'t just about making it work; it\'s also about making it understandable – both for others who might read your code and for your future self. This is where **comments** come in. Comments are lines in your code that Python ignores during execution. Their sole purpose is to provide explanations and context.\n\n### Purpose of Comments\n\n*   **Readability:** Make your code easier to read and comprehend.\n*   **Explanation:** Explain complex logic, algorithms, or non-obvious parts of your code.\n*   **Documentation:** Document design choices, assumptions, or future improvements.\n*   **Debugging/Disabling:** Temporarily disable lines or blocks of code without deleting them.\n\n### Types of Comments in Python\n\nPython supports two main ways to add comments:\n\n1.  **Single-line Comments:**\n    *   Begin with a hash symbol (`#`).\n    *   Everything from the `#` to the end of the line is treated as a comment.\n    ```python\n    # This is a single-line comment\n    name = \"Alice\" # You can also add comments at the end of a line of code\n    ```\n\n2.  **Multi-line Comments (Docstrings):**\n    *   While Python doesn\'t have a dedicated multi-line comment syntax like some other languages, you can use **docstrings** for this purpose. Docstrings are strings enclosed in triple quotes (`\"\"\"...\"\"\"` or `\'\'\'...\'\'\'`).\n    *   They are primarily used to document modules, functions, classes, and methods, providing information about what they do, their arguments, and what they return. When placed immediately after a function or class definition, Python associates them as documentation.\n    *   You *can* use them as general multi-line comments, but it\'s generally discouraged for simple explanations *within* a code block, where `#` is preferred for clarity.\n    ```python\n    \"\"\"\n    This is a docstring.\n    It spans multiple lines and is typically used\n    for documenting code blocks like functions or classes.\n    \"\"\"\n    def greet(person_name):\n        \"\"\"\n        This function takes a name and returns a greeting string.\n        It\'s an example of a docstring for a function.\n        \"\"\"\n        return f\"Hello, {person_name}!\"\n\n    # You could also use triple quotes for a longer comment outside a definition:\n    \'\'\'\n    This is another way to write a multi-line comment,\n    using single triple quotes. Python still treats it as a string\n    that isn\'t assigned to a variable, so it\'s ignored by the interpreter.\n    \'\'\'\n    ```\n\n### Best Practices for Comments\n\n*   **Comment \"Why,\" not just \"What\":** Don\'t simply restate what the code does (e.g., `# Add 1 to x`). Instead, explain *why* a particular approach was chosen or what problem the code solves.\n*   **Keep them Up-to-Date:** Outdated comments are worse than no comments, as they can be misleading.\n*   **Be Concise:** Avoid overly verbose comments.\n*   **Don\'t Over-Comment:** Clear, self-documenting code often needs fewer comments. If your code is hard to understand without many comments, consider refactoring it to be clearer.\n\nBy consistently adding meaningful comments, you elevate your code from a mere set of instructions to a well-explained and maintainable piece of work.', 'ready', '2025-11-01 21:23:58', '2025-11-01 21:25:01'),
(40, 5, 2, 'Making Decisions with Code', '## Making Decisions with Code\n\nIn the journey of programming, not every path is linear. Just like in real life, programs often need to make choices, react to different situations, and execute specific actions based on varying conditions. This chapter introduces the fundamental concepts of **conditional logic**, empowering your code to become dynamic and responsive. You\'ll learn how to implement decision-making using `if`, `if-else`, and `if-elif-else` statements, transforming your programs from simple instructions into intelligent, adaptive tools.\n\n## The \'if\' Statement\n\nThe simplest form of decision-making in code is the `if` statement. It allows a specific block of code to execute *only if* a certain condition is met. Think of it as telling your program, \"IF this is true, THEN do that.\"\n\nAt its core, the `if` statement evaluates a **condition**, which is an expression that results in either `True` or `False`. This `True`/`False` outcome is known as a **boolean value**.\n\nThe basic syntax looks like this:\n\n```python\nif condition:\n    # Code to execute if the condition is True\n    # This code block must be indented\n```\n\nHere\'s how it works:\n*   The `if` keyword marks the start of the conditional statement.\n*   The `condition` is evaluated. This typically involves **comparison operators** like:\n    *   `==` (equal to)\n    *   `!=` (not equal to)\n    *   `<` (less than)\n    *   `>` (greater than)\n    *   `<=` (less than or equal to)\n    *   `>=` (greater than or equal to)\n*   A colon (`:`) signifies the end of the `if` statement header.\n*   The indented block of code immediately following the `if` statement will run *only if* the condition evaluates to `True`. **Indentation** is crucial in many programming languages (like Python) to define code blocks.\n\nLet\'s see an example:\n\n```python\nage = 20\n\nif age >= 18:\n    print(\"You are old enough to vote.\")\n```\n\nIn this example, since `age` (20) is indeed `>=` 18, the condition `age >= 18` evaluates to `True`, and the message \"You are old enough to vote.\" is printed. If `age` were 16, the condition would be `False`, and nothing would be printed.\n\n## Conditional Logic: \'if-else\'\n\nWhile the `if` statement lets you execute code when a condition is true, what if you want to execute *different* code when the condition is false? This is where the `if-else` statement comes in. It provides an **alternative path** for your program\'s execution.\n\nThe `if-else` structure dictates: \"IF this condition is true, THEN do this; OTHERWISE (ELSE), do that.\"\n\nThe syntax extends the `if` statement:\n\n```python\nif condition:\n    # Code to execute if the condition is True\nelse:\n    # Code to execute if the condition is False\n```\n\nKey points about `if-else`:\n*   The `else` block is executed if, and *only if*, the `if` condition evaluates to `False`.\n*   The `if` block and the `else` block are **mutually exclusive**; only one of them will ever run.\n\nConsider a common scenario like checking if a number is even or odd:\n\n```python\nnumber = 7\n\nif number % 2 == 0: # The modulo operator (%) gives the remainder of a division\n    print(\"The number is even.\")\nelse:\n    print(\"The number is odd.\")\n```\n\nHere, `7 % 2` is 1, so `1 == 0` is `False`. Consequently, the `else` block executes, and \"The number is odd.\" is printed. If `number` were 4, `4 % 2 == 0` would be `True`, and \"The number is even.\" would be printed.\n\n## Multiple Choices: \'if-elif-else\'\n\nOften, you\'ll encounter situations where you need to choose among *more than two* possible outcomes. The `if-elif-else` structure allows you to test multiple conditions sequentially and execute code based on the first condition that is true. `elif` is short for \"else if\".\n\nThe `if-elif-else` statement provides a robust way to handle multiple decision branches:\n\n```python\nif condition1:\n    # Code to execute if condition1 is True\nelif condition2:\n    # Code to execute if condition1 is False, AND condition2 is True\nelif condition3:\n    # Code to execute if condition1 and condition2 are False, AND condition3 is True\nelse:\n    # Code to execute if all preceding conditions (condition1, condition2, condition3) are False\n```\n\nHere\'s how it works:\n1.  The program first checks `condition1`. If it\'s `True`, its corresponding code block executes, and the rest of the `elif` and `else` blocks are skipped.\n2.  If `condition1` is `False`, the program moves on to check `condition2`. If `condition2` is `True`, its code block executes, and any subsequent `elif` or `else` blocks are skipped.\n3.  This process continues for all `elif` statements.\n4.  If *none* of the `if` or `elif` conditions are `True`, the `else` block (if present) will execute. The `else` block acts as a **default action** or a fallback for all other cases.\n\nA classic example is assigning a letter grade based on a score:\n\n```python\nscore = 85\n\nif score >= 90:\n    print(\"Grade: A\")\nelif score >= 80:\n    print(\"Grade: B\")\nelif score >= 70:\n    print(\"Grade: C\")\nelif score >= 60:\n    print(\"Grade: D\")\nelse:\n    print(\"Grade: F\")\n```\n\nIn this example:\n*   `score >= 90` is `False` (85 is not >= 90).\n*   The program moves to the first `elif`: `score >= 80` is `True` (85 is >= 80).\n*   Therefore, \"Grade: B\" is printed, and the remaining `elif` and `else` blocks are skipped.\n\nIt\'s important to remember that the **order of `elif` conditions matters**. Conditions are evaluated from top to bottom, and only the *first* `True` condition\'s block will execute. The `else` block is optional, but it\'s often good practice to include it to handle unexpected or default scenarios.', 'ready', '2025-11-01 21:23:58', '2025-11-01 21:24:47'),
(41, 5, 3, 'Repeating Actions with Loops', 'This chapter delves into one of programming\'s most powerful concepts: **loops**. Loops allow us to automate repetitive tasks, execute blocks of code multiple times, and process sequences of data efficiently. Understanding how to use loops is fundamental to writing concise, effective, and scalable programs, transforming tedious manual repetition into elegant automated processes.\n\n*(Note: As no specific book context was provided, this chapter assumes a general Python programming context for beginners, focusing on fundamental concepts and common usage patterns.)*\n\n## The \'for\' Loop: Iterating Over Sequences\n\nThe `for` loop is your go-to tool for iterating over sequences, such as lists, tuples, strings, or ranges of numbers. It\'s designed for situations where you know, or can determine, the number of times you need to repeat an action.\n\n*   **Core Concept:** A `for` loop iterates through each item in a sequence, executing a block of code once for each item.\n*   **Syntax:**\n    ```python\n    for item in sequence:\n        # code to execute for each item\n        # \'item\' will take on the value of each element in the sequence\n    ```\n    The `item` in the syntax is a **loop variable** that temporarily holds the value of the current element during each iteration.\n\nLet\'s look at some examples:\n\n*   **Iterating over a list:**\n    ```python\n    fruits = [\"apple\", \"banana\", \"cherry\"]\n    for fruit in fruits:\n        print(f\"I like {fruit}s.\")\n    ```\n    This will print \"I like apples.\", \"I like bananas.\", and \"I like cherrys.\"\n\n*   **Iterating over a string:**\n    ```python\n    word = \"Python\"\n    for char in word:\n        print(char)\n    ```\n    This prints each character of \"Python\" on a new line.\n\n*   **Using `range()` for numerical loops:**\n    The `range()` function generates a sequence of numbers, which is very useful for repeating an action a specific number of times.\n    *   `range(stop)`: Generates numbers from `0` up to (but not including) `stop`.\n    *   `range(start, stop)`: Generates numbers from `start` up to (but not including) `stop`.\n    *   `range(start, stop, step)`: Generates numbers from `start` up to (but not including) `stop`, incrementing by `step`.\n\n    ```python\n    # Repeating an action 5 times (from 0 to 4)\n    for i in range(5):\n        print(\"Hello!\")\n\n    # Counting from 1 to 3\n    for number in range(1, 4):\n        print(number) # Output: 1, 2, 3\n\n    # Counting by 2s\n    for num in range(0, 10, 2):\n        print(num) # Output: 0, 2, 4, 6, 8\n    ```\n    The `for` loop is ideal when you have a collection of items to process or a predetermined number of repetitions.\n\n## The \'while\' Loop: Repeating Until a Condition\n\nThe `while` loop is used to repeat a block of code as long as a specified condition remains **true**. Unlike the `for` loop, which iterates over a sequence, the `while` loop continues based on a boolean condition. This makes it suitable for situations where the number of repetitions isn\'t known beforehand, such as waiting for user input or processing data until a certain state is reached.\n\n*   **Core Concept:** A `while` loop repeatedly executes its body as long as its condition evaluates to `True`.\n*   **Syntax:**\n    ```python\n    while condition:\n        # code to execute as long as \'condition\' is true\n        # Make sure something inside the loop eventually makes \'condition\' false\n    ```\n    The `condition` is evaluated *before* each iteration. If it\'s `True`, the loop body executes. If it\'s `False`, the loop terminates.\n\nConsider these examples:\n\n*   **Counting up until a limit:**\n    ```python\n    count = 0\n    while count < 3:\n        print(f\"Count is: {count}\")\n        count += 1 # Important: increment count, so the condition eventually becomes false\n    print(\"Loop finished.\")\n    ```\n    This prints \"Count is: 0\", \"Count is: 1\", \"Count is: 2\", then \"Loop finished.\".\n\n*   **User input until a valid entry:**\n    ```python\n    password = \"\"\n    while password != \"secret\":\n        password = input(\"Enter the password: \")\n        if password != \"secret\":\n            print(\"Incorrect password. Try again.\")\n    print(\"Access granted!\")\n    ```\n    This loop will keep prompting the user until they enter \"secret\".\n\nA critical consideration with `while` loops is to ensure that the condition will eventually become `False`. If it never does, you\'ll create an **infinite loop**, which will run forever (or until your program crashes or you manually stop it). Always include code within the loop that modifies a variable used in the condition.\n\n## Controlling Loops: \'break\' and \'continue\'\n\nSometimes, you need more granular control over loop execution. Python provides two statements, `break` and `continue`, to alter the normal flow of `for` and `while` loops.\n\n### The \'break\' Statement\n\nThe `break` statement immediately **terminates the entire loop**. When `break` is encountered, the program exits the loop and continues executing the code immediately following the loop.\n\n*   **Purpose:** To exit a loop prematurely when a specific condition is met, even if the loop\'s original iteration condition hasn\'t been fully exhausted.\n*   **Example:** Searching for a specific item in a list. Once found, there\'s no need to continue checking.\n    ```python\n    items = [\"apple\", \"banana\", \"grape\", \"orange\"]\n    target = \"grape\"\n\n    for item in items:\n        if item == target:\n            print(f\"{target} found!\")\n            break # Exit the loop immediately\n        print(f\"Checking {item}...\")\n    print(\"Search complete.\")\n    ```\n    Output:\n    ```\n    Checking apple...\n    Checking banana...\n    grape found!\n    Search complete.\n    ```\n    Notice \"Checking orange...\" was not printed because `break` stopped the loop after \"grape\".\n\n### The \'continue\' Statement\n\nThe `continue` statement skips the **current iteration** of the loop and moves on to the next one. The code following `continue` in the current iteration is skipped, but the loop itself is not terminated.\n\n*   **Purpose:** To bypass processing for certain values within a loop while still continuing with the rest of the iterations.\n*   **Example:** Processing numbers, but skipping specific ones.\n    ```python\n    for number in range(1, 6):\n        if number % 2 == 0: # If the number is even\n            print(f\"Skipping even number: {number}\")\n            continue # Skip the rest of the code in this iteration\n        print(f\"Processing odd number: {number}\")\n    print(\"Loop finished.\")\n    ```\n    Output:\n    ```\n    Processing odd number: 1\n    Skipping even number: 2\n    Processing odd number: 3\n    Skipping even number: 4\n    Processing odd number: 5\n    Loop finished.\n    ```\n    Here, when `number` is 2 or 4, \"Processing odd number...\" is skipped, and the loop proceeds to the next iteration.\n\nBoth `break` and `continue` provide powerful ways to fine-tune the behavior of your loops, making your code more adaptable and efficient for various programming scenarios.', 'ready', '2025-11-01 21:23:58', '2025-11-01 21:24:47'),
(42, 5, 4, 'Organising Data with Collections', '## Organising Data with Collections\n\nIn programming, we often need to work with multiple related pieces of data. Instead of creating a separate variable for each item, Python provides powerful **collection types** that allow us to store and manage groups of values efficiently. This chapter introduces two fundamental sequence collections: **lists** and **tuples**, exploring their characteristics, how to create them, and the essential operations you can perform on them to structure your data effectively.\n\n## Lists: Mutable Sequences\n\nA **list** in Python is an **ordered**, **changeable (mutable)** collection that allows **duplicate members**. This flexibility makes lists one of the most versatile and frequently used data structures in Python.\n\n*   **Ordered**: The items in a list have a defined order, and that order will not change. New items are appended to the end.\n*   **Changeable (Mutable)**: You can change, add, and remove items after the list has been created.\n*   **Allows Duplicates**: Lists can contain multiple items with the same value.\n\n### Creating Lists\n\nLists are created using square brackets `[]`, with items separated by commas.\n\n```python\n# A list of strings\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\n# A list of integers\nnumbers = [1, 5, 7, 9, 3]\n\n# A list with mixed data types\nmixed_list = [\"hello\", 10, True, 3.14]\n\n# An empty list\nempty_list = []\n```\n\n### Accessing List Elements\n\nList items are indexed, with the first item having index `0`, the second item `1`, and so on. Negative indices can be used to access items from the end of the list (e.g., `-1` for the last item).\n\n```python\nfruits = [\"apple\", \"banana\", \"cherry\", \"orange\"]\n\nprint(fruits[0])  # Output: apple\nprint(fruits[2])  # Output: cherry\nprint(fruits[-1]) # Output: orange (the last item)\n```\n\n### Mutability of Lists\n\nThe \"changeable\" nature of lists means you can modify individual elements, add new ones, or remove existing ones.\n\n```python\nfruits = [\"apple\", \"banana\", \"cherry\"]\nprint(f\"Original list: {fruits}\")\n\n# Change an item\nfruits[1] = \"kiwi\"\nprint(f\"List after changing item: {fruits}\") # Output: [\'apple\', \'kiwi\', \'cherry\']\n\n# Add an item (using append, discussed further below)\nfruits.append(\"grape\")\nprint(f\"List after adding item: {fruits}\") # Output: [\'apple\', \'kiwi\', \'cherry\', \'grape\']\n```\n\n## Tuples: Immutable Sequences\n\nA **tuple** in Python is an **ordered**, **unchangeable (immutable)** collection that also allows **duplicate members**. The key distinction from lists is their immutability, meaning once a tuple is created, its elements cannot be modified.\n\n*   **Ordered**: Like lists, tuple items have a defined order.\n*   **Unchangeable (Immutable)**: You cannot change, add, or remove items after the tuple has been created.\n*   **Allows Duplicates**: Tuples can contain multiple items with the same value.\n\n### Creating Tuples\n\nTuples are created using parentheses `()`, with items separated by commas.\n\n```python\n# A tuple of strings\ncoordinates = (\"latitude\", \"longitude\")\n\n# A tuple of numbers\nrgb_colors = (255, 0, 0)\n\n# A tuple with mixed data types\nperson_info = (\"Alice\", 30, \"Engineer\")\n\n# An empty tuple\nempty_tuple = ()\n\n# A tuple with a single item requires a trailing comma\nsingle_item_tuple = (\"item\",)\n```\n**Note**: For a single-item tuple, the comma after the item is crucial; otherwise, Python treats it as a simple parenthesized expression.\n\n### Accessing Tuple Elements\n\nSimilar to lists, tuple items are accessed using zero-based indexing or negative indexing.\n\n```python\nperson_info = (\"Alice\", 30, \"Engineer\")\n\nprint(person_info[0])  # Output: Alice\nprint(person_info[1])  # Output: 30\nprint(person_info[-1]) # Output: Engineer\n```\n\n### Immutability of Tuples\n\nThe primary characteristic of tuples is their immutability. Once created, you cannot change, add, or remove elements. Attempting to do so will result in an error.\n\n```python\nrgb_colors = (255, 0, 0)\n# rgb_colors[0] = 200 # This would raise a TypeError: \'tuple\' object does not support item assignment\n```\nThis immutability makes tuples useful for data that should not change throughout the program\'s execution, such as database records or fixed coordinates.\n\n## Basic List and Tuple Operations\n\nMany operations are common to both lists and tuples because they are both **sequences**. However, some operations are specific to lists due to their mutable nature.\n\n### Common Operations for Both Lists and Tuples\n\n*   **Accessing Elements (Indexing)**: Retrieve individual items using their position.\n    ```python\n    my_list = [10, 20, 30]\n    my_tuple = (100, 200, 300)\n    print(my_list[1])  # Output: 20\n    print(my_tuple[2]) # Output: 300\n    ```\n*   **Slicing**: Extract a sub-sequence of items. `[start:end:step]`\n    ```python\n    data = [1, 2, 3, 4, 5, 6]\n    print(data[1:4])   # Output: [2, 3, 4] (items from index 1 up to, but not including, index 4)\n    print(data[:3])    # Output: [1, 2, 3] (from the beginning up to index 3)\n    print(data[3:])    # Output: [4, 5, 6] (from index 3 to the end)\n    print(data[::2])   # Output: [1, 3, 5] (every second item)\n    ```\n*   **Length**: The `len()` function returns the number of items.\n    ```python\n    fruits = [\"apple\", \"banana\", \"cherry\"]\n    print(len(fruits)) # Output: 3\n    ```\n*   **Checking for Membership**: The `in` and `not in` operators check if an item exists.\n    ```python\n    colors = (\"red\", \"green\", \"blue\")\n    print(\"red\" in colors)    # Output: True\n    print(\"yellow\" not in colors) # Output: True\n    ```\n*   **Concatenation**: Use the `+` operator to combine two sequences.\n    ```python\n    list1 = [1, 2]\n    list2 = [3, 4]\n    combined_list = list1 + list2 # Output: [1, 2, 3, 4]\n\n    tuple1 = (5, 6)\n    tuple2 = (7, 8)\n    combined_tuple = tuple1 + tuple2 # Output: (5, 6, 7, 8)\n    ```\n*   **Repetition**: Use the `*` operator to repeat a sequence.\n    ```python\n    zeros = [0] * 5       # Output: [0, 0, 0, 0, 0]\n    repeated_tuple = (\"a\",) * 3 # Output: (\'a\', \'a\', \'a\')\n    ```\n\n### List-Specific Operations (Mutating)\n\nThese operations change the list in place.\n\n*   `append(item)`: Adds an `item` to the end of the list.\n    ```python\n    fruits = [\"apple\", \"banana\"]\n    fruits.append(\"cherry\") # fruits is now [\"apple\", \"banana\", \"cherry\"]\n    ```\n*   `insert(index, item)`: Inserts an `item` at a specified `index`.\n    ```python\n    fruits = [\"apple\", \"cherry\"]\n    fruits.insert(1, \"banana\") # fruits is now [\"apple\", \"banana\", \"cherry\"]\n    ```\n*   `remove(item)`: Removes the first occurrence of a specified `item`.\n    ```python\n    fruits = [\"apple\", \"banana\", \"cherry\", \"banana\"]\n    fruits.remove(\"banana\") # fruits is now [\"apple\", \"cherry\", \"banana\"]\n    ```\n*   `pop(index)`: Removes and returns the item at a specified `index`. If no index is given, removes and returns the last item.\n    ```python\n    fruits = [\"apple\", \"banana\", \"cherry\"]\n    removed_item = fruits.pop(1) # removed_item is \"banana\", fruits is [\"apple\", \"cherry\"]\n    last_item = fruits.pop()    # last_item is \"cherry\", fruits is [\"apple\"]\n    ```\n*   `del` keyword: Deletes items by index, slices, or the entire list.\n    ```python\n    my_list = [10, 20, 30, 40]\n    del my_list[1]     # my_list is now [10, 30, 40]\n    del my_list[1:3]   # my_list is now [10]\n    # del my_list        # Deletes the entire list object\n    ```\n*   `sort()`: Sorts the list in ascending order in place.\n    ```python\n    numbers = [3, 1, 4, 1, 5, 9]\n    numbers.sort()     # numbers is now [1, 1, 3, 4, 5, 9]\n    numbers.sort(reverse=True) # numbers is now [9, 5, 4, 3, 1, 1]\n    ```\n*   `reverse()`: Reverses the order of elements in place.\n    ```python\n    letters = [\'c\', \'b\', \'a\']\n    letters.reverse()  # letters is now [\'a\', \'b\', \'c\']\n    ```\n\n### Tuple-Specific Operations (Non-Mutating)\n\nSince tuples are immutable, they have fewer methods than lists, mainly focused on information retrieval.\n\n*   `count(item)`: Returns the number of times a specified `item` appears in the tuple.\n    ```python\n    my_tuple = (1, 2, 2, 3, 2, 4)\n    print(my_tuple.count(2)) # Output: 3\n    ```\n*   `index(item)`: Returns the index of the first occurrence of a specified `item`. Raises a `ValueError` if the item is not found.\n    ```python\n    my_tuple = (\"a\", \"b\", \"c\")\n    print(my_tuple.index(\"b\")) # Output: 1\n    ```', 'ready', '2025-11-01 21:23:58', '2025-11-01 21:24:49'),
(43, 5, 5, 'Building Your Own Functions', 'This chapter marks a pivotal step in your programming journey: learning to build your own functions. Up until now, you\'ve primarily used functions provided by Python or its libraries. Now, you\'ll discover how to encapsulate your own logic into reusable blocks, transforming your code from a linear script into an organized, efficient, and much more readable program. Mastering functions is key to writing professional and maintainable software.\n\n## Defining and Calling Functions\n\nAt its core, a **function** is a named, reusable block of code designed to perform a specific task. Think of it as a mini-program within your main program. Instead of writing the same sequence of instructions repeatedly, you define it once as a function and then *call* that function whenever you need it.\n\n### Why Use Functions?\n\nFunctions are fundamental to good programming for several compelling reasons:\n\n*   **Modularity:** They help break down complex problems into smaller, manageable, and independent units. This makes the overall program easier to understand and debug.\n*   **Reusability:** You write the code once and can execute it multiple times from different parts of your program, saving time and reducing redundancy (the DRY principle: **D**on\'t **R**epeat **Y**ourself).\n*   **Readability:** Giving a meaningful name to a block of code makes the main program flow much clearer, improving its comprehension for both you and others.\n*   **Maintainability:** If a piece of logic needs to be changed or fixed, you only need to modify it in one place (inside the function definition), rather than searching for and updating every instance where that logic was used.\n\n### Defining a Function\n\nIn Python, you define a function using the `def` keyword, followed by the function name, parentheses `()`, and a colon `:`. The code block that constitutes the function\'s body must be indented.\n\nHere\'s the basic syntax:\n\n```python\ndef function_name():\n    # This is the function body\n    # All code inside here must be indented\n    print(\"This code is inside the function.\")\n    print(\"It runs when the function is called.\")\n```\n\nLet\'s create a simple function:\n\n```python\ndef say_hello():\n    \"\"\"This function prints a simple greeting.\"\"\" # This is a docstring\n    print(\"Hello, programmer!\")\n    print(\"Welcome to the world of functions!\")\n```\n\nA quick note on **docstrings**: The triple-quoted string right after the `def` line is called a **docstring**. It\'s a best practice to include these to explain what the function does. It serves as documentation for your code.\n\n### Calling a Function\n\nDefining a function doesn\'t execute its code. It merely tells Python that this block of code exists and can be run later. To execute the code inside a function, you must **call** (or invoke) it. You do this by typing the function\'s name followed by parentheses `()`.\n\n```python\n# Calling our previously defined function\nsay_hello()\n\nprint(\"--- End of first call ---\")\n\n# We can call it again whenever we need it\nsay_hello()\n```\n\n**Output:**\n```\nHello, programmer!\nWelcome to the world of functions!\n--- End of first call ---\nHello, programmer!\nWelcome to the world of functions!\n```\n\nAs you can see, the `say_hello()` function\'s code block executed each time it was called.\n\n## Function Arguments and Parameters\n\nThe `say_hello()` function is useful, but it\'s a bit rigid—it always says the same thing. What if we want our function to greet a specific person? This is where **arguments** and **parameters** come in. They allow functions to accept input, making them far more flexible and powerful.\n\n### Parameters vs. Arguments\n\nWhile often used interchangeably, there\'s a subtle but important distinction:\n\n*   **Parameters:** These are the placeholders or variables listed inside the parentheses in the function **definition**. They define what kind of input the function expects.\n*   **Arguments:** These are the actual values passed to the function when it is **called**.\n\nLet\'s illustrate:\n\n```python\n# \'name\' is a parameter\ndef greet_person(name):\n    print(f\"Hello, {name}!\")\n\n# \"Alice\" is an argument\ngreet_person(\"Alice\")\n\n# \"Bob\" is another argument\ngreet_person(\"Bob\")\n```\n\n**Output:**\n```\nHello, Alice!\nHello, Bob!\n```\n\nIn the `greet_person` definition, `name` is a parameter. When we call `greet_person(\"Alice\")`, the string `\"Alice\"` is an argument that gets assigned to the `name` parameter for that specific call.\n\n### Multiple Parameters\n\nFunctions can accept multiple parameters, separated by commas. The order in which you pass arguments usually matters, as they are matched positionally to the parameters.\n\n```python\ndef describe_pet(animal_type, pet_name):\n    \"\"\"Describes a pet with its type and name.\"\"\"\n    print(f\"I have a {animal_type}.\")\n    print(f\"Its name is {pet_name}.\")\n\n# Passing arguments in the order of parameters\ndescribe_pet(\"dog\", \"Buddy\")\n\nprint(\"---\")\n\n# The order matters: this changes the meaning!\ndescribe_pet(\"Whiskers\", \"cat\") # This will output \"I have a Whiskers.\" which is incorrect\n```\n\n**Output:**\n```\nI have a dog.\nIts name is Buddy.\n---\nI have a Whiskers.\nIts name is cat.\n```\n\nThe second call to `describe_pet` shows why positional order is crucial. Python assigns arguments to parameters based on their position.\n\n### Default Parameter Values\n\nSometimes, a function parameter might have a common or typical value. You can provide a **default value** for a parameter in the function definition. If an argument is provided for that parameter during the function call, it overrides the default. If no argument is provided, the default value is used.\n\n```python\ndef describe_pet_default(pet_name, animal_type=\"dog\"):\n    \"\"\"Describes a pet, with \'dog\' as the default animal type.\"\"\"\n    print(f\"I have a {animal_type}.\")\n    print(f\"Its name is {pet_name}.\")\n\n# Using the default animal_type \"dog\"\ndescribe_pet_default(\"Buddy\")\n\nprint(\"---\")\n\n# Overriding the default animal_type\ndescribe_pet_default(\"Whiskers\", \"cat\")\n```\n\n**Output:**\n```\nI have a dog.\nIts name is Buddy.\n---\nI have a cat.\nIts name is Whiskers.\n```\n\nDefault arguments make functions more flexible by allowing callers to omit arguments they don\'t need to specify. Parameters with default values must be listed *after* all parameters without default values.\n\n## Returning Values from Functions\n\nSo far, our functions have performed actions, like printing a greeting or describing a pet. But what if we want a function to *calculate* something and then give that result back to the part of the program that called it? This is where the **`return` statement** comes in.\n\nThe `return` statement allows a function to send a value (or values) back to the caller. When a `return` statement is executed, the function immediately stops running, and the specified value is sent back.\n\n### Using the `return` Statement\n\nConsider a function that adds two numbers. Instead of just printing the sum, we want the function to *give* us the sum so we can use it in further calculations.\n\n```python\ndef add_numbers(num1, num2):\n    \"\"\"Adds two numbers and returns their sum.\"\"\"\n    sum_result = num1 + num2\n    return sum_result # The function sends sum_result back to the caller\n\n# Call the function and store its returned value in a variable\ntotal = add_numbers(10, 5)\nprint(f\"The sum is: {total}\")\n\n# We can use the returned value directly in an expression\nfinal_value = add_numbers(total, 20)\nprint(f\"The final value is: {final_value}\")\n```\n\n**Output:**\n```\nThe sum is: 15\nThe final value is: 35\n```\n\nWithout `return`, `add_numbers(10, 5)` would just execute its internal `print` (if it had one) or do nothing visible. With `return`, the function becomes a powerful calculation engine whose output can be assigned to a variable, passed to another function, or used in any expression.\n\n### Why `return` is Important\n\n*   **Function Composition:** Allows you to build complex operations by combining simpler functions. The output of one function can become the input of another.\n*   **Separation of Concerns:** Functions can focus purely on computing a result, while the calling code decides how to use or display that result.\n*   **Flexibility:** The returned value can be used in various ways, not just printed, making your code more adaptable.\n\n### Functions Without Explicit `return`\n\nIf a function doesn\'t have an explicit `return` statement, it implicitly returns the special value **`None`**. `None` is a unique Python constant used to represent the absence of a value.\n\n```python\ndef print_message(message):\n    print(message)\n    # No return statement here\n\nresult = print_message(\"This function only prints.\")\nprint(f\"The return value of print_message is: {result}\")\n```\n\n**Output:**\n```\nThis function only prints.\nThe return value of print_message is: None\n```\n\nThis demonstrates that `print_message` did its job (printing) but didn\'t hand back any specific data.\n\n### Returning Multiple Values\n\nPython functions can conveniently return multiple values. When you `return` several items separated by commas, Python packs them into a **tuple** and returns the tuple. You can then unpack this tuple into separate variables when you receive it.\n\n```python\ndef calculate_stats(numbers):\n    \"\"\"Calculates sum, average, and count of a list of numbers.\"\"\"\n    total = sum(numbers)\n    count = len(numbers)\n    average = total / count if count > 0 else 0\n    return total, average, count # Returns three values\n\nmy_data = [10, 20, 30, 40, 50]\ndata_sum, data_avg, data_count = calculate_stats(my_data) # Unpacking the returned tuple\n\nprint(f\"Sum: {data_sum}\")\nprint(f\"Average: {data_avg}\")\nprint(f\"Count: {data_count}\")\n```\n\n**Output:**\n```\nSum: 150\nAverage: 30.0\nCount: 5\n```\n\nThis capability to return multiple values elegantly simplifies many common programming tasks where you need to compute several related results from a single operation.\n\nBy mastering the definition, calling, arguments, and return values of functions, you\'ve gained a foundational tool for writing structured, efficient, and sophisticated Python programs. This chapter provides the bedrock upon which much of your future programming will be built.', 'ready', '2025-11-01 21:23:58', '2025-11-01 21:24:54');
INSERT INTO `chapters` (`id`, `book_id`, `chapter_index`, `title`, `generated_content`, `status`, `created_at`, `updated_at`) VALUES
(44, 5, 6, 'Working with Text (Strings)', '# Working with Text (Strings)\n\nTextual data is fundamental in programming, from displaying messages to processing user input and managing complex information. In this chapter, we dive into **strings**, which are Python\'s way of handling text. You\'ll learn how to create, manipulate, and format strings effectively, equipping you with essential skills for building robust and user-friendly applications.\n\n## String Basics: Creating and Accessing\n\nA **string** is an ordered sequence of characters, such as letters, numbers, symbols, and spaces. In Python, strings are **immutable**, meaning once a string is created, its contents cannot be changed. Any operation that seems to \"modify\" a string actually creates a *new* string.\n\n### Creating Strings\n\nYou can create strings using single, double, or triple quotes:\n\n*   **Single quotes:** `\'Hello, Python!\'`\n*   **Double quotes:** `\"Python is great.\"`\n    *   Using different quotes allows you to include quotes of the other type directly in your string without needing to escape them. For example, `\"He said, \'Hello!\'\"`.\n*   **Triple quotes:** Used for multi-line strings or docstrings.\n    ```python\n    multi_line_string = \"\"\"This is a string\n    that spans multiple\n    lines.\"\"\"\n    ```\n    Triple double quotes (`\"\"\"`) and triple single quotes (`\'\'\'`) work identically.\n\n### Accessing Characters (Indexing)\n\nStrings are **indexed sequences**, meaning each character has a numerical position. Python uses **zero-based indexing**, where the first character is at index `0`.\n\n*   **Positive indexing:** Starts from the beginning (left to right).\n    ```python\n    my_string = \"Python\"\n    print(my_string[0]) # Output: P\n    print(my_string[3]) # Output: h\n    ```\n*   **Negative indexing:** Starts from the end (right to left), with `-1` representing the last character.\n    ```python\n    my_string = \"Python\"\n    print(my_string[-1]) # Output: n\n    print(my_string[-3]) # Output: h\n    ```\n    Attempting to access an index that is out of the string\'s bounds will result in an `IndexError`.\n\n### Slicing Strings\n\n**Slicing** allows you to extract a portion (a substring) from a string. The syntax for slicing is `[start:end:step]`:\n\n*   `start`: The index where the slice begins (inclusive).\n*   `end`: The index where the slice ends (exclusive).\n*   `step`: The increment between characters (optional, default is 1).\n\nHere are some common slicing patterns:\n\n*   `my_string[start:end]`: Extracts characters from `start` up to (but not including) `end`.\n    ```python\n    word = \"Programming\"\n    print(word[0:4])  # Output: Prog\n    print(word[3:7])  # Output: gram\n    ```\n*   `my_string[start:]`: Extracts characters from `start` to the end of the string.\n    ```python\n    print(word[7:])   # Output: ming\n    ```\n*   `my_string[:end]`: Extracts characters from the beginning up to (but not including) `end`.\n    ```python\n    print(word[:5])   # Output: Progr\n    ```\n*   `my_string[:]`: Creates a complete copy of the string.\n*   `my_string[::step]`: Extracts characters with a specified step.\n    ```python\n    print(word[::2])  # Output: Pogamn (every second character)\n    ```\n*   `my_string[::-1]`: Reverses the string.\n    ```python\n    print(word[::-1]) # Output: gnimmargorP\n    ```\n\n### String Length\n\nThe built-in `len()` function returns the number of characters in a string.\n\n```python\nsentence = \"Hello world!\"\nprint(len(sentence)) # Output: 12\n```\n\n## String Operations and Methods\n\nPython provides a rich set of operations and methods for manipulating strings. Remember that due to string immutability, these methods always return a *new* string rather than modifying the original.\n\n### Basic String Operations\n\n*   **Concatenation (`+`)**: Joins two or more strings together.\n    ```python\n    greeting = \"Hello\"\n    name = \"Alice\"\n    full_message = greeting + \", \" + name + \"!\"\n    print(full_message) # Output: Hello, Alice!\n    ```\n*   **Repetition (`*`)**: Repeats a string a specified number of times.\n    ```python\n    pattern = \"abc\" * 3\n    print(pattern) # Output: abcabcabc\n    ```\n*   **Membership (`in`, `not in`)**: Checks if a substring is present within a string. Returns `True` or `False`.\n    ```python\n    text = \"The quick brown fox\"\n    print(\"quick\" in text)    # Output: True\n    print(\"lazy\" not in text) # Output: True\n    ```\n\n### Common String Methods\n\nPython\'s `str` type offers many useful methods:\n\n*   `str.lower()`: Returns a copy of the string with all characters converted to lowercase.\n    ```python\n    \"PYTHON\".lower() # Output: \"python\"\n    ```\n*   `str.upper()`: Returns a copy of the string with all characters converted to uppercase.\n    ```python\n    \"python\".upper() # Output: \"PYTHON\"\n    ```\n*   `str.capitalize()`: Returns a copy of the string with only the first character capitalized.\n    ```python\n    \"hello world\".capitalize() # Output: \"Hello world\"\n    ```\n*   `str.title()`: Returns a copy of the string where the first letter of each word is capitalized.\n    ```python\n    \"learn python programming\".title() # Output: \"Learn Python Programming\"\n    ```\n*   `str.strip()`: Returns a copy of the string with leading and trailing whitespace removed. `lstrip()` and `rstrip()` remove only left or right whitespace, respectively.\n    ```python\n    \"  Python rocks!  \".strip() # Output: \"Python rocks!\"\n    ```\n*   `str.replace(old, new)`: Returns a copy of the string with all occurrences of `old` substring replaced by `new` substring.\n    ```python\n    \"I like cats. Cats are cute.\".replace(\"Cats\", \"Dogs\") # Output: \"I like dogs. Dogs are cute.\"\n    ```\n*   `str.find(sub)`: Returns the lowest index in the string where `sub` is found. Returns `-1` if `sub` is not found.\n    ```python\n    \"apple pie\".find(\"pie\") # Output: 6\n    \"apple pie\".find(\"tart\") # Output: -1\n    ```\n*   `str.count(sub)`: Returns the number of non-overlapping occurrences of `sub` in the string.\n    ```python\n    \"banana\".count(\"a\") # Output: 3\n    ```\n*   `str.startswith(prefix)`: Returns `True` if the string starts with `prefix`, `False` otherwise.\n*   `str.endswith(suffix)`: Returns `True` if the string ends with `suffix`, `False` otherwise.\n    ```python\n    filename = \"report.pdf\"\n    print(filename.startswith(\"report\")) # Output: True\n    print(filename.endswith(\".txt\"))    # Output: False\n    ```\n*   `str.split(sep=None)`: Splits the string into a **list of substrings** using `sep` as the delimiter. If `sep` is not provided, it splits by any whitespace and removes empty strings from the result.\n    ```python\n    data = \"apple,banana,cherry\"\n    fruits = data.split(\",\") # Output: [\'apple\', \'banana\', \'cherry\']\n\n    sentence = \"This is a test.\"\n    words = sentence.split() # Output: [\'This\', \'is\', \'a\', \'test.\']\n    ```\n*   `str.join(iterable)`: This is the \"reverse\" of `split()`. It concatenates the elements of an `iterable` (e.g., a list of strings) using the string itself as a separator.\n    ```python\n    words = [\"Hello\", \"World\", \"Python\"]\n    joined_string = \" \".join(words) # Output: \"Hello World Python\"\n\n    path_parts = [\"user\", \"local\", \"bin\"]\n    full_path = \"/\".join(path_parts) # Output: \"user/local/bin\"\n    ```\n\n## String Formatting\n\nString formatting is crucial for creating dynamic, readable, and structured output. Python offers several ways to achieve this, each with its own advantages.\n\n### Old Style: `%` Operator (printf-style)\n\nThis method, inherited from C-like languages, uses placeholders like `%s` for strings, `%d` for integers, and `%f` for floats. While still functional, it\'s generally considered less flexible than newer methods.\n\n```python\nname = \"Charlie\"\nage = 28\nmessage = \"My name is %s and I am %d years old.\" % (name, age)\nprint(message) # Output: My name is Charlie and I am 28 years old.\n```\n\n### `str.format()` Method\n\nIntroduced in Python 2.6, `str.format()` uses curly braces `{}` as placeholders. It\'s more versatile and readable than the `%` operator.\n\n*   **Positional arguments**: Values are inserted in the order they appear.\n    ```python\n    print(\"The {} of {} is {}.\".format(\"capital\", \"France\", \"Paris\"))\n    # Output: The capital of France is Paris.\n    ```\n*   **Numbered arguments**: You can explicitly specify argument indices.\n    ```python\n    print(\"The {0} of {1} is {2}.\".format(\"capital\", \"France\", \"Paris\"))\n    ```\n*   **Keyword arguments**: Refer to arguments by name for clarity.\n    ```python\n    print(\"Hello, {name}! You are {age} years old.\".format(name=\"David\", age=30))\n    # Output: Hello, David! You are 30 years old.\n    ```\n*   **Formatting options**: Control alignment, padding, and precision.\n    ```python\n    pi = 3.14159\n    print(\"Pi is approximately {:.2f}.\".format(pi)) # Output: Pi is approximately 3.14.\n    ```\n\n### F-Strings (Formatted String Literals)\n\nIntroduced in Python 3.6, **f-strings** (formatted string literals) are the most modern and recommended way to format strings. They provide a concise and readable way to embed expressions inside string literals by prefixing the string with `f` or `F`.\n\n*   **Direct embedding**: Variables and expressions are placed directly inside curly braces.\n    ```python\n    city = \"London\"\n    population = 8982000\n    print(f\"The population of {city} is {population:,} people.\")\n    # Output: The population of London is 8,982,000 people.\n    ```\n    (Note the `,` inside the `{}` for number formatting.)\n*   **Expressions**: You can include any valid Python expression.\n    ```python\n    a = 10\n    b = 5\n    print(f\"The sum of {a} and {b} is {a + b}.\") # Output: The sum of 10 and 5 is 15.\n    ```\n*   **Method calls**: String methods can be called directly within the f-string.\n    ```python\n    product = \"laptop\"\n    print(f\"I bought a new {product.upper()}.\") # Output: I bought a new LAPTOP.\n    ```\n*   **Formatting specifiers**: Similar to `str.format()`, you can apply various formatting mini-language specifiers.\n    ```python\n    price = 199.998\n    print(f\"Price: ${price:.2f}\") # Output: Price: $200.00 (rounds up)\n\n    percentage = 0.75\n    print(f\"Completion: {percentage:.0%}\") # Output: Completion: 75%\n    ```\n\nF-strings are generally preferred due to their excellent readability and performance. Mastering them will make your string output much cleaner and more efficient.', 'ready', '2025-11-01 21:23:58', '2025-11-01 21:25:14'),
(45, 5, 7, 'Using Python Libraries (Modules)', 'Python\'s true power lies not just in its fundamental syntax but in its extensive collection of **modules**, often referred to as **libraries**. These are pre-written files of code that you can import into your own programs to add a vast array of functionality without having to write it all from scratch. This chapter will introduce you to what modules are, how to effectively import and use them, and explore two popular examples: `math` for mathematical operations and `random` for generating randomness.\n\n## What are Modules?\n\nAt its core, a **module** is simply a file containing Python code. Think of it as a toolbox filled with specialized tools (functions, classes, variables) that are designed to perform specific tasks. When you create a Python script and save it with a `.py` extension, that file itself can be considered a module.\n\nThe primary benefits of using modules are:\n\n*   **Code Reusability:** Instead of writing the same function or class multiple times in different programs, you can write it once in a module and then reuse it whenever needed.\n*   **Organization:** Modules help break down large programs into smaller, manageable, and logically organized files. This makes your code easier to read, understand, and maintain.\n*   **Namespace Isolation:** Each module has its own **namespace**, which helps prevent naming conflicts between different parts of your code.\n*   **Collaboration:** Multiple developers can work on different modules of a larger project simultaneously.\n\nModules can contain:\n\n*   **Functions:** Reusable blocks of code that perform a specific task (e.g., `sqrt()` in the `math` module).\n*   **Variables:** Values that can be used by the module\'s functions or by programs that import the module (e.g., `pi` in the `math` module).\n*   **Classes:** Blueprints for creating objects (we\'ll cover classes in more detail later).\n*   **Other Python statements:** Any valid Python code.\n\n## Importing and Using Modules\n\nTo use the code contained within a module, you must first **import** it into your current Python script or interactive session. Python provides several ways to do this.\n\nThe most common way to import a module is using the `import` statement:\n\n```python\nimport module_name\n```\n\nOnce imported, you can access its contents (functions, variables, etc.) using the **dot notation**: `module_name.item_name`.\n\n**Example:**\n\n```python\nimport math # Imports the entire \'math\' module\n\nprint(math.pi)       # Accesses the \'pi\' variable from the \'math\' module\nprint(math.sqrt(16)) # Calls the \'sqrt\' function from the \'math\' module\n```\n\nHere are other ways to import modules:\n\n*   **Importing specific items:** If you only need a few specific functions or variables from a module, you can import them directly using the `from...import` statement. This allows you to use them without the `module_name.` prefix.\n\n    ```python\n    from math import pi, sqrt # Imports only \'pi\' and \'sqrt\' from \'math\'\n\n    print(pi)       # No need for math.pi\n    print(sqrt(25)) # No need for math.sqrt()\n    ```\n\n*   **Importing with an alias:** You can give a module a shorter, more convenient alias (nickname) using the `import...as` statement. This is especially useful for modules with long names or to avoid name clashes.\n\n    ```python\n    import math as m # Imports \'math\' and gives it the alias \'m\'\n\n    print(m.pi)\n    print(m.floor(3.7))\n    ```\n\n*   **Importing all items (generally discouraged):** You can import all public items from a module directly into your current namespace using `from module import *`. While convenient, this can lead to **name conflicts** if multiple modules have items with the same name, or if your own code uses names already present in the module. It also makes it harder to tell where functions are coming from.\n\n    ```python\n    from math import * # Imports everything from \'math\' directly\n\n    print(pi)       # Can use \'pi\' directly\n    print(cos(0))   # Can use \'cos()\' directly\n    ```\n    For clarity and to prevent potential issues, it\'s generally best to avoid `import *` in production code.\n\n## Popular Modules: \'math\' and \'random\'\n\nPython comes with a vast **Standard Library**, which is a collection of modules included with the Python installation. Let\'s look at two of the most commonly used modules from this library.\n\n### The \'math\' Module\n\nThe `math` module provides access to common mathematical functions and constants. It\'s essential for any program that requires complex calculations.\n\nHere are some frequently used items from the `math` module:\n\n*   `math.pi`: The mathematical constant π (pi).\n*   `math.e`: The mathematical constant e (Euler\'s number).\n*   `math.sqrt(x)`: Returns the square root of `x`.\n*   `math.ceil(x)`: Returns the smallest integer greater than or equal to `x` (rounds up).\n*   `math.floor(x)`: Returns the largest integer less than or equal to `x` (rounds down).\n*   `math.pow(x, y)`: Returns `x` raised to the power of `y`.\n*   `math.sin(x)`, `math.cos(x)`, `math.tan(x)`: Trigonometric functions (expect angles in radians).\n*   `math.degrees(x)`, `math.radians(x)`: Convert angles between radians and degrees.\n\n**Example Usage:**\n\n```python\nimport math\n\nradius = 5\narea = math.pi * (radius ** 2)\nprint(f\"The area of a circle with radius {radius} is: {area:.2f}\")\n\nnumber = 10.7\nprint(f\"Ceiling of {number}: {math.ceil(number)}\")\nprint(f\"Floor of {number}: {math.floor(number)}\")\n\nangle_deg = 90\nangle_rad = math.radians(angle_deg)\nprint(f\"Sine of {angle_deg} degrees: {math.sin(angle_rad):.2f}\")\n\nprint(f\"Square root of 81: {math.sqrt(81)}\")\n```\n\n### The \'random\' Module\n\nThe `random` module provides functions for generating pseudo-random numbers. This is useful for simulations, games, data anonymization, and many other applications where unpredictability is desired.\n\nKey functions in the `random` module include:\n\n*   `random.random()`: Returns a random floating-point number in the range `[0.0, 1.0)` (inclusive of 0.0, exclusive of 1.0).\n*   `random.randint(a, b)`: Returns a random integer `N` such that `a <= N <= b` (inclusive of both `a` and `b`).\n*   `random.randrange(start, stop, step)`: Returns a randomly selected element from `range(start, stop, step)`. Often used as `random.randrange(stop)` to get a number from `0` up to `stop-1`.\n*   `random.choice(sequence)`: Returns a randomly selected element from a non-empty sequence (like a list or string).\n*   `random.shuffle(list)`: Shuffles the elements of a list **in place** (modifies the original list).\n*   `random.uniform(a, b)`: Returns a random floating-point number `N` such that `a <= N <= b`.\n\n**Example Usage:**\n\n```python\nimport random\n\n# Generate a random float between 0.0 and 1.0\nprint(f\"Random float: {random.random()}\")\n\n# Generate a random integer between 1 and 10 (inclusive)\nprint(f\"Random integer (1-10): {random.randint(1, 10)}\")\n\n# Simulate a dice roll (1 to 6)\nprint(f\"Dice roll: {random.randint(1, 6)}\")\n\n# Choose a random element from a list\nchoices = [\"Rock\", \"Paper\", \"Scissors\"]\nprint(f\"Computer\'s choice: {random.choice(choices)}\")\n\n# Shuffle a list\nmy_list = [1, 2, 3, 4, 5]\nprint(f\"Original list: {my_list}\")\nrandom.shuffle(my_list) # Modifies my_list directly\nprint(f\"Shuffled list: {my_list}\")\n\n# Generate a random number from a specific range (e.g., 0 to 9)\nprint(f\"Random from range(10): {random.randrange(10)}\")\n```', 'ready', '2025-11-01 21:23:58', '2025-11-01 21:25:03'),
(46, 5, 8, 'Storing Data in Files', 'In computing, data often needs to persist beyond the immediate execution of a program or be shared across different applications. While variables hold data in memory, their contents are lost once a program terminates. This chapter explores how programs store and retrieve data directly from files on a computer\'s storage system, enabling **data persistence** and facilitating **data exchange**. We\'ll cover the fundamental operations: establishing a connection to a file, reading its contents, and writing new information to it.\n\n## Opening and Closing Files\n\nBefore a program can interact with a file on disk—whether to read from it or write to it—it must first **open** the file. This process establishes a connection between the program and the operating system\'s file system, allowing for subsequent operations. Once all necessary operations are complete, the file should always be **closed** to release system resources and ensure data integrity.\n\n### The `open()` Function\n\nThe primary way to open a file is using the built-in `open()` function. It returns a **file object** (also known as a file handle) that your program will use to perform read/write operations.\n\nThe `open()` function typically takes two main arguments:\n1.  **`filename`**: A string representing the path to the file.\n2.  **`mode`**: A string specifying how the file will be used (e.g., read, write, append).\n\nHere are the most common file modes:\n*   **`\'r\'` (read mode)**: Opens the file for reading. This is the **default mode**. If the file doesn\'t exist, an error will occur.\n*   **`\'w\'` (write mode)**: Opens the file for writing. If the file already exists, its contents will be **truncated (emptied)**. If the file doesn\'t exist, a new one will be created.\n*   **`\'a\'` (append mode)**: Opens the file for writing. If the file exists, new data is written to the **end of the file**. If the file doesn\'t exist, a new one will be created.\n*   **`\'x\'` (exclusive creation mode)**: Creates a new file and opens it for writing. If the file already exists, an error will occur.\n*   **`\'b\'` (binary mode)**: Used for handling non-text files (like images, audio, or executable files). It\'s combined with other modes, e.g., `\'rb\'` or `\'wb\'`.\n*   **`\'t\'` (text mode)**: Used for handling text files. This is the **default mode** for `open()`. It handles encoding and decoding of characters. You can combine it, e.g., `\'rt\'` or `\'wt\'`, though `\'r\'` and `\'w\'` implicitly use text mode.\n\n**Example:**\n```python\n# Open a file for reading in text mode\nfile_obj = open(\'my_document.txt\', \'r\')\n\n# Open a file for writing, creating it if it doesn\'t exist, or overwriting if it does\nnew_file_obj = open(\'new_data.txt\', \'w\')\n\n# Open an image file for reading in binary mode\nimage_file_obj = open(\'picture.jpg\', \'rb\')\n```\n\n### The `close()` Method\n\nAfter you\'re finished with a file, it\'s crucial to call the `close()` method on the file object. This performs several important tasks:\n*   It releases the file handle from the operating system, freeing up resources.\n*   It ensures that any buffered writes are **flushed** to disk, meaning all data intended for the file is actually saved.\n*   It prevents data corruption, especially if the program crashes or terminates unexpectedly.\n\n**Example:**\n```python\nfile_obj = open(\'my_document.txt\', \'r\')\n# ... perform operations ...\nfile_obj.close()\n```\n\n### The `with` Statement (Context Manager)\n\nFor robust and clean file handling, the `with` statement is highly recommended. It acts as a **context manager** that ensures files are automatically closed, even if errors occur during file operations. This eliminates the need to explicitly call `close()`.\n\n**Example:**\n```python\nwith open(\'my_document.txt\', \'r\') as file_obj:\n    # Operations on file_obj go here\n    # The file will be automatically closed when exiting the \'with\' block,\n    # regardless of whether an error occurred.\n    data = file_obj.read()\n    print(data)\n\nprint(\"File is now closed.\")\n```\n\n## Reading Data from Files\n\nOnce a file is open in a read-compatible mode (`\'r\'`, `\'rb\'`, etc.), you can retrieve its contents using various methods provided by the file object.\n\n### Reading Methods\n\nHere are the common methods for reading data from a file object:\n\n*   **`read(size=-1)`**:\n    *   Reads the entire content of the file and returns it as a single string (in text mode) or bytes (in binary mode).\n    *   If an optional `size` argument is provided, it reads up to `size` characters/bytes from the file.\n    *   Subsequent calls to `read()` will continue from where the previous read left off.\n    *   Returns an **empty string** (or empty bytes) when the **end of file (EOF)** is reached.\n\n    ```python\n    with open(\'sample.txt\', \'r\') as f:\n        content = f.read()\n        print(\"Entire file content:\\n\", content)\n    ```\n\n*   **`readline(size=-1)`**:\n    *   Reads a single line from the file, including the newline character (`\\n`) if present at the end of the line.\n    *   If an optional `size` argument is provided, it reads up to `size` characters/bytes of the line.\n    *   Returns an **empty string** (or empty bytes) when the **end of file (EOF)** is reached.\n\n    ```python\n    with open(\'sample.txt\', \'r\') as f:\n        line1 = f.readline()\n        line2 = f.readline()\n        print(\"First line:\", line1.strip()) # .strip() removes whitespace, including newline\n        print(\"Second line:\", line2.strip())\n    ```\n\n*   **`readlines()`**:\n    *   Reads all lines from the file and returns them as a **list of strings**, where each string represents a line and includes the newline character.\n\n    ```python\n    with open(\'sample.txt\', \'r\') as f:\n        all_lines = f.readlines()\n        print(\"All lines as a list:\", all_lines)\n        for line in all_lines:\n            print(line.strip())\n    ```\n\n### Iterating Over a File Object\n\nFor large files, reading the entire content into memory using `read()` or `readlines()` might not be efficient or even possible. The most memory-efficient way to process a file line by line is to **iterate directly over the file object** itself.\n\n```python\nwith open(\'sample.txt\', \'r\') as f:\n    print(\"Reading line by line using iteration:\")\n    for line in f:\n        print(line.strip()) # Process each line as it\'s read\n```\nEach iteration of the `for` loop reads one line from the file, making it ideal for processing files of any size without consuming excessive memory.\n\n## Writing Data to Files\n\nWriting data to files involves putting strings (in text mode) or bytes (in binary mode) into the file system. As discussed earlier, the file must be opened in a write-compatible mode (`\'w\'`, `\'a\'`, `\'x\'`, `\'wb\'`, `\'ab\'`, etc.).\n\n### Writing Methods\n\n*   **`write(string)`**:\n    *   Writes the specified `string` to the file.\n    *   It **does not automatically add a newline character (`\\n`)**. You must explicitly include it if you want new lines.\n    *   Returns the number of characters (or bytes) written.\n\n    ```python\n    with open(\'output.txt\', \'w\') as f:\n        f.write(\"Hello, world!\\n\")\n        f.write(\"This is a new line.\\n\")\n        f.write(\"And this is the end.\")\n    ```\n    If `output.txt` existed, its content is now replaced. If it didn\'t exist, it\'s created.\n\n*   **`writelines(list_of_strings)`**:\n    *   Writes a sequence (like a list or tuple) of strings to the file.\n    *   Similar to `write()`, it **does not add newline characters automatically** between the strings. Each string in the sequence must contain its own newline if desired.\n\n    ```python\n    lines_to_write = [\n        \"First entry\\n\",\n        \"Second entry\\n\",\n        \"Third entry (no newline here)\"\n    ]\n\n    with open(\'list_output.txt\', \'w\') as f:\n        f.writelines(lines_to_write)\n    ```\n\n### Understanding Write Modes: `\'w\'` vs. `\'a\'`\n\nThe choice between `\'w\'` (write) and `\'a\'` (append) mode is crucial when writing to files:\n\n*   **`\'w\'` (Write Mode)**:\n    *   If the file **does not exist**, it creates a new file.\n    *   If the file **already exists**, it **truncates** (empties) the file before writing. Any previous content is permanently lost.\n    *   Use `\'w\'` when you want to create a new file or completely replace the content of an existing one.\n\n*   **`\'a\'` (Append Mode)**:\n    *   If the file **does not exist**, it creates a new file.\n    *   If the file **already exists**, new data is written to the **end** of the file, preserving its existing content.\n    *   Use `\'a\'` when you want to add new data to an existing file without deleting what\'s already there.\n\n**Example of Append Mode:**\n```python\n# First run: create or overwrite\nwith open(\'log.txt\', \'w\') as f:\n    f.write(\"Log started: Program started successfully.\\n\")\n\n# Second run: append to the existing log.txt\nwith open(\'log.txt\', \'a\') as f:\n    f.write(\"Log update: Task A completed.\\n\")\n    f.write(\"Log update: Task B failed.\\n\")\n```\nAfter both operations, `log.txt` would contain:\n```\nLog started: Program started successfully.\nLog update: Task A completed.\nLog update: Task B failed.\n```\n\nMastering these file operations is a cornerstone of building applications that can store, retrieve, and manage data effectively, extending their utility far beyond the lifespan of a single program execution.', 'ready', '2025-11-01 21:23:58', '2025-11-01 21:25:08'),
(47, 5, 9, 'Handling Errors Like a Pro', 'Errors are an inevitable part of programming, but encountering them doesn\'t have to halt your progress or crash your applications. This chapter will equip you with the essential skills to anticipate, detect, and gracefully handle errors in your code, transforming potential pitfalls into opportunities for more robust and user-friendly software. By understanding different error types and mastering Python\'s powerful `try-except` mechanism, you\'ll learn to write programs that can recover from unexpected situations and guide users effectively.\n\n## Understanding Different Types of Errors\n\nIn programming, an **error** signifies that something went wrong during the execution of your code. Not all errors are created equal, and understanding their distinctions is the first step toward effective handling.\n\nPython generally categorizes errors into two main types:\n\n*   **Syntax Errors:** These are errors in the structure of your code. They occur when the Python interpreter cannot understand your code because it violates the language\'s grammatical rules.\n    *   **When they occur:** Before the program even starts executing, during the parsing phase. The interpreter will refuse to run the code.\n    *   **Examples:**\n        *   Missing a colon (`:`) at the end of an `if` statement or `function` definition.\n        *   Mismatched parentheses or quotes.\n        *   Incorrect keywords (e.g., `whiel` instead of `while`).\n    *   **How to fix:** Syntax errors must be corrected in your code before it can run. The interpreter usually points to the line where the error occurred, making them relatively straightforward to debug.\n\n*   **Exceptions:** These are errors that occur *during* the execution of your program, even if the code is syntactically correct. Exceptions disrupt the normal flow of the program.\n    *   **When they occur:** At runtime, when the program is already executing.\n    *   **Examples:**\n        *   **`ZeroDivisionError`**: Trying to divide a number by zero.\n        *   **`ValueError`**: A function receives an argument of the correct type but an inappropriate value (e.g., `int(\"hello\")`).\n        *   **`TypeError`**: An operation or function is applied to an object of an inappropriate type (e.g., trying to add a string and an integer directly `5 + \"text\"`).\n        *   **`IndexError`**: Trying to access an index that is out of bounds for a list, tuple, or string.\n        *   **`FileNotFoundError`**: Trying to open a file that does not exist.\n        *   **`KeyError`**: Trying to access a dictionary key that doesn\'t exist.\n    *   **How to fix:** While you can fix the underlying logical mistake that causes an exception, the power of **exception handling** lies in writing code that can *anticipate* these runtime problems and react to them gracefully, preventing the program from crashing.\n\n## The \'try-except\' Block\n\nThe core mechanism for handling exceptions in Python is the **`try-except` block**. This construct allows you to \"try\" to execute a block of code and, if an exception occurs within that block, \"catch\" it and execute a different block of code to handle the situation.\n\nThe basic structure of a `try-except` block is as follows:\n\n```python\ntry:\n    # Code that might raise an exception\n    # This block is executed first.\nexcept:\n    # Code to execute if an exception occurs in the \'try\' block\n    # This block is executed only if an exception is caught.\n```\n\nLet\'s break down its components and execution flow:\n\n*   **`try` block:** You place the code that you suspect might raise an exception inside this block. Python attempts to execute this code normally.\n*   **`except` block:** If an exception occurs during the execution of the `try` block, the rest of the `try` block is immediately skipped, and Python jumps to the `except` block. The code within the `except` block is then executed, providing a way to handle the error gracefully.\n*   **Execution Flow:**\n    *   If no exception occurs in the `try` block, the `except` block is completely skipped, and the program continues executing normally after the `try-except` structure.\n    *   If an exception *does* occur, the `try` block\'s execution stops, the `except` block executes, and then the program continues after the `try-except` structure.\n\n**Example:**\n\n```python\nprint(\"Starting the division program...\")\ntry:\n    num1 = int(input(\"Enter the numerator: \"))\n    num2 = int(input(\"Enter the denominator: \"))\n    result = num1 / num2\n    print(f\"The result of the division is: {result}\")\nexcept: # This catches ANY exception\n    print(\"Oops! Something went wrong. Please ensure you entered numbers and the denominator is not zero.\")\nprint(\"Program finished.\")\n```\n\nIn this example, if the user enters non-numeric input for `num1` or `num2`, or if `num2` is `0`, an exception will occur. Instead of crashing, the program will print the error message from the `except` block.\n\nWhile a bare `except` (catching all exceptions) can prevent crashes, it\'s generally **not recommended** in production code. It can mask unexpected issues and make debugging harder because you don\'t know *which* specific error occurred. A better practice is to handle specific exceptions.\n\n## Handling Specific Exceptions\n\nTo write more robust and informative error handlers, you should specify *which* types of exceptions your `except` blocks are designed to catch. This allows you to provide tailored responses for different error scenarios.\n\n### Catching a Single Specific Exception\n\nYou can specify the type of exception you want to catch directly after the `except` keyword.\n\n**Example:**\n\n```python\nprint(\"Starting numeric conversion...\")\ntry:\n    user_input = input(\"Please enter a whole number: \")\n    number = int(user_input)\n    print(f\"You entered the number: {number}\")\nexcept ValueError: # Catches only ValueError\n    print(f\"That\'s not a valid whole number! \'{user_input}\' cannot be converted.\")\nprint(\"Conversion attempt finished.\")\n```\n\nHere, if the user enters \"hello\", a `ValueError` is caught. If they were to cause a `TypeError` (e.g., in a different scenario), this `except` block wouldn\'t catch it.\n\n### Catching Multiple Specific Exceptions\n\nIf you anticipate several different types of exceptions in a `try` block, you can catch them with multiple `except` blocks or by listing them in a tuple.\n\n**Using multiple `except` blocks:**\n\n```python\ntry:\n    numerator = int(input(\"Enter the numerator: \"))\n    denominator = int(input(\"Enter the denominator: \"))\n    result = numerator / denominator\n    print(f\"Division result: {result}\")\nexcept ZeroDivisionError:\n    print(\"Error: You cannot divide by zero!\")\nexcept ValueError:\n    print(\"Error: Invalid input. Please enter only numbers.\")\n```\n\nPython will try each `except` block in order. The first one that matches the raised exception will be executed.\n\n**Using a tuple for multiple exceptions:**\n\n```python\ntry:\n    data = [1, 2, 3]\n    index = int(input(\"Enter an index (0-2): \"))\n    value = data[index]\n    print(f\"Value at index {index}: {value}\")\n    # Assume another operation could raise a ValueError\n    some_number = int(\"abc\") # This will raise a ValueError if it was not commented out\nexcept (IndexError, ValueError) as e: # Catches either IndexError or ValueError\n    print(f\"An input or indexing error occurred: {e}\")\n```\n\n### Accessing the Exception Object (`as e`)\n\nYou can also assign the exception object itself to a variable (conventionally `e` or `err`) within the `except` block. This allows you to access information about the exception, such as its error message, which can be very helpful for debugging or providing more detailed feedback to the user.\n\n```python\ntry:\n    filename = \"non_existent_file.txt\"\n    with open(filename, \'r\') as file:\n        content = file.read()\n        print(content)\nexcept FileNotFoundError as e: # \'e\' now holds the FileNotFoundError object\n    print(f\"Error: The file \'{filename}\' was not found. Details: {e}\")\nexcept Exception as e: # A general catch-all for any other unexpected exception\n    print(f\"An unexpected error occurred: {e}\")\n```\nIt\'s a good practice to put more specific exception handlers *before* more general ones (`Exception` catches everything, so it should be last).\n\n### The `else` and `finally` Blocks (Briefly)\n\n*   **`else` block:** An optional `else` block can be added to a `try-except` statement. The code inside the `else` block is executed *only if no exception occurred* in the `try` block. This is useful for code that should only run if the `try` block was entirely successful.\n*   **`finally` block:** An optional `finally` block is guaranteed to be executed, *regardless of whether an exception occurred or not*. This is commonly used for cleanup operations, such as closing files or network connections, ensuring resources are released even if an error disrupts normal execution.\n\nBy mastering `try-except` and its variations, you gain the power to write resilient Python applications that can gracefully handle the unpredictable nature of user input and runtime conditions.', 'ready', '2025-11-01 21:23:58', '2025-11-01 21:25:11'),
(48, 5, 10, 'Fun Python Projects', 'This chapter is your gateway to applying the Python skills you\'ve learned to create genuinely interactive and fun programs. We\'ll move beyond simple scripts to build four classic projects: a basic calculator, a number guessing game, a Rock-Paper-Scissors challenge against the computer, and a simple story generator. Each project is designed to reinforce fundamental concepts like user input, conditional logic, loops, and random number generation, transforming abstract knowledge into tangible, working applications. Get ready to code some creativity!\n\n## Simple Calculator\n\nOur first project is a straightforward calculator that performs basic arithmetic operations. This is an excellent way to practice handling user input, converting data types, and using conditional statements.\n\n**Core Concepts:**\n\n*   **`input()`**: To get numbers and the desired operation from the user.\n*   **Type Conversion**: Using `int()` or `float()` to convert string input into numerical data for calculations.\n*   **`if`/`elif`/`else`**: To determine which operation to perform based on user input.\n*   **Arithmetic Operators**: `+`, `-`, `*`, `/` for addition, subtraction, multiplication, and division.\n\n**Project Code:**\n\n```python\n# Simple Calculator\n\nprint(\"--- Simple Python Calculator ---\")\n\n# Get the first number\nnum1_str = input(\"Enter the first number: \")\nnum1 = float(num1_str) # Convert input string to a floating-point number\n\n# Get the second number\nnum2_str = input(\"Enter the second number: \")\nnum2 = float(num2_str) # Convert input string to a floating-point number\n\n# Get the operation\noperation = input(\"Choose an operation (+, -, *, /): \")\n\n# Perform the calculation based on the chosen operation\nif operation == \'+\':\n    result = num1 + num2\n    print(f\"Result: {num1} + {num2} = {result}\")\nelif operation == \'-\':\n    result = num1 - num2\n    print(f\"Result: {num1} - {num2} = {result}\")\nelif operation == \'*\':\n    result = num1 * num2\n    print(f\"Result: {num1} * {num2} = {result}\")\nelif operation == \'/\':\n    if num2 != 0: # Prevent division by zero error\n        result = num1 / num2\n        print(f\"Result: {num1} / {num2} = {result}\")\n    else:\n        print(\"Error: Cannot divide by zero!\")\nelse:\n    print(\"Invalid operation. Please choose from +, -, *, /.\")\n```\n\n**How to Run:**\n\n1.  Save the code in a file named `calculator.py`.\n2.  Open your terminal or command prompt.\n3.  Navigate to the directory where you saved the file.\n4.  Run the script using: `python calculator.py`\n5.  Follow the prompts to enter numbers and an operation.\n\n**Enhancements:**\n\n*   Add more operations like exponentiation (`**`) or modulo (`%`).\n*   Implement a loop so the user can perform multiple calculations without restarting.\n*   Include error handling for non-numeric input (e.g., using a `try-except` block).\n\n## Guess the Number Game\n\nThis classic game challenges the player to guess a secret number generated by the computer. It\'s a fantastic way to understand **loops**, **conditional logic**, and using the **`random` module**.\n\n**Core Concepts:**\n\n*   **`import random`**: To bring in Python\'s random number generation capabilities.\n*   **`random.randint(a, b)`**: Generates a random integer between `a` and `b` (inclusive).\n*   **`while` Loop**: To keep the game going until the correct number is guessed.\n*   **`if`/`elif`/`else`**: To provide hints (too high, too low) and determine if the guess is correct.\n*   **Counter Variable**: To track how many guesses the player takes.\n\n**Project Code:**\n\n```python\n# Guess the Number Game\n\nimport random\n\nprint(\"--- Guess the Number Game ---\")\nprint(\"I\'m thinking of a number between 1 and 100.\")\nprint(\"Can you guess it?\")\n\n# Generate a random secret number\nsecret_number = random.randint(1, 100)\n\nguesses_taken = 0\nfound = False # Flag to control the loop\n\nwhile not found:\n    guesses_taken += 1\n    guess_str = input(f\"Guess #{guesses_taken}: Enter your guess: \")\n\n    try:\n        guess = int(guess_str) # Convert guess to an integer\n    except ValueError:\n        print(\"Invalid input. Please enter a whole number.\")\n        continue # Skip to the next iteration of the loop\n\n    if guess < secret_number:\n        print(\"Your guess is too low. Try again!\")\n    elif guess > secret_number:\n        print(\"Your guess is too high. Try again!\")\n    else:\n        print(f\"Congratulations! You guessed the number ({secret_number}) in {guesses_taken} guesses!\")\n        found = True # Set flag to exit the loop\n```\n\n**How to Run:**\n\n1.  Save the code as `guess_number.py`.\n2.  Run from your terminal: `python guess_number.py`\n3.  The game will prompt you for guesses.\n\n**Enhancements:**\n\n*   Set a limited number of guesses.\n*   Allow the user to choose the range of numbers (e.g., 1-100, 1-1000).\n*   Add a \"play again\" option.\n\n## Rock-Paper-Scissors Game\n\nPlay the classic game of Rock-Paper-Scissors against the computer! This project reinforces **conditional logic**, **random choices from a list**, and **string comparison**.\n\n**Core Concepts:**\n\n*   **`import random`**: Again, for making random choices.\n*   **`random.choice(list)`**: Selects a random item from a given list.\n*   **Lists**: To store the possible game choices (`\'rock\'`, `\'paper\'`, `\'scissors\'`).\n*   **`if`/`elif`/`else`**: To implement the game\'s rules and determine the winner.\n*   **String Comparison**: Comparing the player\'s choice with the computer\'s choice.\n\n**Project Code:**\n\n```python\n# Rock-Paper-Scissors Game\n\nimport random\n\nprint(\"--- Rock-Paper-Scissors ---\")\nprint(\"Enter your choice: rock, paper, or scissors.\")\n\nchoices = [\'rock\', \'paper\', \'scissors\']\n\nplayer_choice = input(\"Your choice: \").lower() # Get input and convert to lowercase\ncomputer_choice = random.choice(choices) # Computer makes a random choice\n\nprint(f\"You chose: {player_choice}\")\nprint(f\"Computer chose: {computer_choice}\")\n\n# Determine the winner\nif player_choice not in choices:\n    print(\"Invalid choice. Please choose \'rock\', \'paper\', or \'scissors\'.\")\nelif player_choice == computer_choice:\n    print(\"It\'s a tie!\")\nelif (player_choice == \'rock\' and computer_choice == \'scissors\') or \\\n     (player_choice == \'paper\' and computer_choice == \'rock\') or \\\n     (player_choice == \'scissors\' and computer_choice == \'paper\'):\n    print(\"You win!\")\nelse:\n    print(\"Computer wins!\")\n```\n\n**How to Run:**\n\n1.  Save the code as `rps_game.py`.\n2.  Run from your terminal: `python rps_game.py`\n3.  Enter your choice when prompted.\n\n**Enhancements:**\n\n*   Implement a scoring system over multiple rounds.\n*   Allow the player to play multiple rounds.\n*   Add input validation to ensure the user enters a valid choice.\n\n## Story Generator\n\nUnleash your creativity with a simple story generator! This project focuses on gathering **user input** and dynamically creating text using **f-strings** or **string formatting**. It demonstrates how variables can be combined to form more complex outputs.\n\n**Core Concepts:**\n\n*   **`input()`**: To gather various pieces of information from the user (nouns, verbs, adjectives).\n*   **Variables**: To store the user\'s inputs.\n*   **f-strings** (formatted string literals): A powerful way to embed expressions inside string literals for cleaner, more readable string formatting.\n*   **String Concatenation**: Combining multiple strings and variables into a larger story.\n\n**Project Code:**\n\n```python\n# Story Generator (Mad Libs style)\n\nprint(\"--- Python Story Generator ---\")\nprint(\"Let\'s create a silly story!\")\n\n# Get inputs from the user\nname = input(\"Enter a name: \")\nadjective = input(\"Enter an adjective: \")\nnoun = input(\"Enter a noun: \")\nverb = input(\"Enter a verb (past tense): \")\nplace = input(\"Enter a place: \")\nadverb = input(\"Enter an adverb: \")\n\n# Generate the story using an f-string\nstory = f\"\"\"\nOne day, a brave adventurer named {name} was exploring a {adjective} forest.\nSuddenly, a giant {noun} {verb} right in front of them!\n{name} quickly {adverb} ran to the {place} to escape.\nWhat an exciting, albeit scary, day for {name}!\n\"\"\"\n\nprint(\"\\n--- Your Amazing Story ---\")\nprint(story)\n```\n\n**How to Run:**\n\n1.  Save the code as `story_generator.py`.\n2.  Run from your terminal: `python story_generator.py`\n3.  Answer the prompts to fill in the story\'s blanks.\n\n**Enhancements:**\n\n*   Create multiple story templates to choose from.\n*   Ask for more detailed inputs to generate longer or more complex stories.\n*   Store lists of adjectives, nouns, etc., and let the computer randomly pick if the user wants.', 'ready', '2025-11-01 21:23:58', '2025-11-01 21:25:14'),
(61, 7, 0, 'ভূমিকা ও প্রস্তুতি কৌশল', NULL, 'idle', '2025-11-04 17:57:38', '2025-11-04 17:57:38');
INSERT INTO `chapters` (`id`, `book_id`, `chapter_index`, `title`, `generated_content`, `status`, `created_at`, `updated_at`) VALUES
(62, 7, 1, 'সংখ্যা পদ্ধতি ও মৌলিক ধারণা', '## সংখ্যা পদ্ধতি ও মৌলিক ধারণা\n\nগণিতশাস্ত্রের মূল ভিত্তি হলো সংখ্যা। যে কোনো প্রতিযোগিতামূলক পরীক্ষায় গণিত অংশে ভালো করার জন্য সংখ্যার বিভিন্ন প্রকারভেদ, তাদের বৈশিষ্ট্য এবং মৌলিক গাণিতিক প্রক্রিয়াগুলি সম্পর্কে সুস্পষ্ট ধারণা থাকা অত্যাবশ্যক। এই অধ্যায়ে আমরা সংখ্যার মৌলিক ধারণা, তাদের শ্রেণিবিভাগ, বিভাজ্যতার নিয়মাবলী এবং লসাগু-গসাগু ও দশমিক-ভগ্নাংশ সম্পর্কিত অপরিহার্য বিষয়গুলি বিস্তারিতভাবে আলোচনা করব, যা আপনার গাণিতিক ভিত্তিকে মজবুত করবে।\n\n### সংখ্যার প্রকারভেদ\n\nসংখ্যা পদ্ধতির জগতে বিভিন্ন ধরনের সংখ্যা রয়েছে, যাদের নিজস্ব বৈশিষ্ট্য রয়েছে। এই প্রকারভেদগুলি জানা গণিতের সমস্যা সমাধানে অত্যন্ত গুরুত্বপূর্ণ।\n\n*   **স্বাভাবিক সংখ্যা (Natural Numbers):** গণনার জন্য ব্যবহৃত সকল ধনাত্মক পূর্ণ সংখ্যাকে **স্বাভাবিক সংখ্যা** বলে।\n    *   উদাহরণ: 1, 2, 3, 4, ...\n*   **পূর্ণ সংখ্যা (Whole Numbers):** শূন্য (0) সহ সকল স্বাভাবিক সংখ্যাকে **পূর্ণ সংখ্যা** বলে।\n    *   উদাহরণ: 0, 1, 2, 3, 4, ...\n*   **অখণ্ড সংখ্যা (Integers):** সকল ধনাত্মক ও ঋণাত্মক পূর্ণ সংখ্যা এবং শূন্যকে একত্রে **অখণ্ড সংখ্যা** বলে।\n    *   উদাহরণ: ..., -3, -2, -1, 0, 1, 2, 3, ...\n*   **মূলদ সংখ্যা (Rational Numbers):** যে সকল সংখ্যাকে $p/q$ আকারে প্রকাশ করা যায়, যেখানে $p$ ও $q$ অখণ্ড সংখ্যা এবং $q \\ne 0$, তাদের **মূলদ সংখ্যা** বলে।\n    *   উদাহরণ: 1/2, 3, -4/5, 0.75 (যা 3/4), 5 (যা 5/1)।\n*   **অমূলদ সংখ্যা (Irrational Numbers):** যে সকল সংখ্যাকে $p/q$ আকারে প্রকাশ করা যায় না, তাদের **অমূলদ সংখ্যা** বলে। এদের দশমিক রূপ অসীম ও অনাবৃত (non-terminating and non-repeating) হয়।\n    *   উদাহরণ: $\\sqrt{2}$, $\\sqrt{3}$, $\\pi$ (পাই)।\n*   **বাস্তব সংখ্যা (Real Numbers):** সকল মূলদ ও অমূলদ সংখ্যাকে একত্রে **বাস্তব সংখ্যা** বলে। সংখ্যা রেখায় অবস্থিত সকল সংখ্যাই বাস্তব সংখ্যা।\n*   **মৌলিক সংখ্যা (Prime Numbers):** 1-এর চেয়ে বড় যে সকল সংখ্যা 1 এবং সেই সংখ্যাটি ছাড়া অন্য কোনো সংখ্যা দ্বারা বিভাজ্য নয়, তাদের **মৌলিক সংখ্যা** বলে।\n    *   উদাহরণ: 2, 3, 5, 7, 11, 13, ... (উল্লেখ্য, 2 হলো একমাত্র জোড় মৌলিক সংখ্যা)।\n*   **যৌগিক সংখ্যা (Composite Numbers):** 1-এর চেয়ে বড় যে সকল সংখ্যা মৌলিক নয়, অর্থাৎ যাদের 1 এবং সেই সংখ্যাটি ছাড়া অন্য গুণনীয়ক আছে, তাদের **যৌগিক সংখ্যা** বলে।\n    *   উদাহরণ: 4, 6, 8, 9, 10, 12, ... (উল্লেখ্য, 1 মৌলিকও নয়, যৌগিকও নয়)।\n*   **জোড় সংখ্যা (Even Numbers):** যে সকল পূর্ণ সংখ্যা 2 দ্বারা সম্পূর্ণভাবে বিভাজ্য, তাদের **জোড় সংখ্যা** বলে।\n    *   উদাহরণ: ..., -4, -2, 0, 2, 4, 6, ...\n*   **বিজোড় সংখ্যা (Odd Numbers):** যে সকল পূর্ণ সংখ্যা 2 দ্বারা সম্পূর্ণভাবে বিভাজ্য নয়, তাদের **বিজোড় সংখ্যা** বলে।\n    *   উদাহরণ: ..., -3, -1, 1, 3, 5, 7, ...\n\n### বিভাজ্যতা নিয়ম\n\nকোনো সংখ্যাকে ভাগ না করেই সেটি অন্য কোনো সংখ্যা দ্বারা বিভাজ্য কিনা তা দ্রুত নির্ণয় করার জন্য কিছু সহজ নিয়ম রয়েছে। এই নিয়মগুলি পরীক্ষার সময় দ্রুত উত্তর দিতে সহায়ক।\n\n*   **2 দ্বারা বিভাজ্যতা:** কোনো সংখ্যার **শেষ অঙ্কটি 0, 2, 4, 6, বা 8** হলে সংখ্যাটি 2 দ্বারা বিভাজ্য হবে।\n    *   উদাহরণ: 48, 130, 256।\n*   **3 দ্বারা বিভাজ্যতা:** কোনো সংখ্যার **অঙ্কগুলির যোগফল 3 দ্বারা বিভাজ্য** হলে সংখ্যাটি 3 দ্বারা বিভাজ্য হবে।\n    *   উদাহরণ: 123 (1+2+3=6, যা 3 দ্বারা বিভাজ্য), 789 (7+8+9=24, যা 3 দ্বারা বিভাজ্য)।\n*   **4 দ্বারা বিভাজ্যতা:** কোনো সংখ্যার **শেষ দুটি অঙ্ক দ্বারা গঠিত সংখ্যা 4 দ্বারা বিভাজ্য** হলে, অথবা সংখ্যার শেষ দুটি অঙ্ক 00 হলে, সংখ্যাটি 4 দ্বারা বিভাজ্য হবে।\n    *   উদাহরণ: 516 (16, যা 4 দ্বারা বিভাজ্য), 1200।\n*   **5 দ্বারা বিভাজ্যতা:** কোনো সংখ্যার **শেষ অঙ্কটি 0 বা 5** হলে সংখ্যাটি 5 দ্বারা বিভাজ্য হবে।\n    *   উদাহরণ: 75, 210।\n*   **6 দ্বারা বিভাজ্যতা:** কোনো সংখ্যা **একইসাথে 2 এবং 3 উভয় দ্বারা বিভাজ্য** হলে সংখ্যাটি 6 দ্বারা বিভাজ্য হবে।\n    *   উদাহরণ: 144 (শেষ অঙ্ক 4, তাই 2 দ্বারা বিভাজ্য; অঙ্কগুলির যোগফল 1+4+4=9, তাই 3 দ্বারা বিভাজ্য)।\n*   **8 দ্বারা বিভাজ্যতা:** কোনো সংখ্যার **শেষ তিনটি অঙ্ক দ্বারা গঠিত সংখ্যা 8 দ্বারা বিভাজ্য** হলে, অথবা সংখ্যার শেষ তিনটি অঙ্ক 000 হলে, সংখ্যাটি 8 দ্বারা বিভাজ্য হবে।\n    *   উদাহরণ: 7128 (128, যা 8 দ্বারা বিভাজ্য), 3000।\n*   **9 দ্বারা বিভাজ্যতা:** কোনো সংখ্যার **অঙ্কগুলির যোগফল 9 দ্বারা বিভাজ্য** হলে সংখ্যাটি 9 দ্বারা বিভাজ্য হবে।\n    *   উদাহরণ: 459 (4+5+9=18, যা 9 দ্বারা বিভাজ্য)।\n*   **10 দ্বারা বিভাজ্যতা:** কোনো সংখ্যার **শেষ অঙ্কটি 0** হলে সংখ্যাটি 10 দ্বারা বিভাজ্য হবে।\n    *   উদাহরণ: 150, 2300।\n*   **11 দ্বারা বিভাজ্যতা:** কোনো সংখ্যার **বিজোড় স্থানের অঙ্কগুলির যোগফল এবং জোড় স্থানের অঙ্কগুলির যোগফলের পার্থক্য 0 বা 11 দ্বারা বিভাজ্য** হলে সংখ্যাটি 11 দ্বারা বিভাজ্য হবে।\n    *   উদাহরণ: 1331 (বিজোড় স্থান: 1+3=4; জোড় স্থান: 3+1=4; পার্থক্য 4-4=0, তাই 11 দ্বারা বিভাজ্য)। 253 (বিজোড় স্থান: 2+3=5; জোড় স্থান: 5; পার্থক্য 5-5=0, তাই 11 দ্বারা বিভাজ্য)।\n\n### লসাগু ও গসাগু\n\nলসাগু (লঘিষ্ঠ সাধারণ গুণিতক) এবং গসাগু (গরিষ্ঠ সাধারণ গুণনীয়ক) গণিতের মৌলিক ধারণাগুলির মধ্যে অন্যতম এবং এগুলি বিভিন্ন সমস্যা সমাধানে অপরিহার্য।\n\n#### লসাগু (Least Common Multiple - LCM)\n\nদুটি বা ততোধিক সংখ্যার **লঘিষ্ঠ সাধারণ গুণিতক (LCM)** হলো সেই ক্ষুদ্রতম সংখ্যা, যা প্রদত্ত সংখ্যাগুলি দ্বারা সম্পূর্ণভাবে বিভাজ্য।\n\n*   **গুরুত্ব:** এমন একটি ক্ষুদ্রতম সংখ্যা খুঁজে বের করতে লসাগু ব্যবহার করা হয় যা নির্দিষ্ট কয়েকটি সংখ্যা দ্বারা বিভাজ্য। যেমন, ঘড়ির কাঁটার মিলন, বিভিন্ন সময় পর পর সংঘটিত ঘটনার পুনরাবৃত্তি ইত্যাদি।\n\n**লসাগু নির্ণয়ের পদ্ধতি:**\n\n1.  **মৌলিক উৎপাদক বিশ্লেষণ পদ্ধতি (Prime Factorization Method):**\n    *   প্রতিটি সংখ্যার মৌলিক উৎপাদকে বিশ্লেষণ করুন।\n    *   সকল মৌলিক উৎপাদকের সর্বোচ্চ ঘাতগুলি গুণ করুন।\n    *   উদাহরণ: 12 এবং 18-এর লসাগু।\n        *   12 = $2^2 \\times 3^1$\n        *   18 = $2^1 \\times 3^2$\n        *   সর্বোচ্চ ঘাত: $2^2$ (4) এবং $3^2$ (9)।\n        *   লসাগু = $4 \\times 9 = 36$\n2.  **ভাগ পদ্ধতি (Division Method):**\n    *   সংখ্যাগুলিকে পাশাপাশি বসিয়ে এমন একটি ক্ষুদ্রতম মৌলিক সংখ্যা দিয়ে ভাগ করুন যা অন্তত একটি সংখ্যাকে ভাগ করে।\n    *   ভাগফল এবং বিভাজ্য নয় এমন সংখ্যাগুলিকে পরবর্তী সারিতে নামান।\n    *   এই প্রক্রিয়া চালিয়ে যান যতক্ষণ না প্রতিটি সংখ্যা 1 হয়ে যায়।\n    *   সকল ভাজক এবং অবশিষ্ট সংখ্যাগুলির গুণফলই হলো লসাগু।\n\n#### গসাগু (Highest Common Factor - HCF)\n\nদুটি বা ততোধিক সংখ্যার **গরিষ্ঠ সাধারণ গুণনীয়ক (HCF)**, বা গরিষ্ঠ সাধারণ ভাজক (GCD) হলো সেই বৃহত্তম সংখ্যা, যা প্রদত্ত সংখ্যাগুলি প্রত্যেকটিকে সম্পূর্ণভাবে ভাগ করতে পারে।\n\n*   **গুরুত্ব:** সবচেয়ে বড় মাপের একক খুঁজে বের করতে গসাগু ব্যবহার করা হয়, যা দিয়ে নির্দিষ্ট দৈর্ঘ্য বা পরিমাণগুলিকে সমানভাবে ভাগ করা যায়।\n\n**গসাগু নির্ণয়ের পদ্ধতি:**\n\n1.  **মৌলিক উৎপাদক বিশ্লেষণ পদ্ধতি (Prime Factorization Method):**\n    *   প্রতিটি সংখ্যার মৌলিক উৎপাদকে বিশ্লেষণ করুন।\n    *   সকল সাধারণ মৌলিক উৎপাদকের সর্বনিম্ন ঘাতগুলি গুণ করুন।\n    *   উদাহরণ: 12 এবং 18-এর গসাগু।\n        *   12 = $2^2 \\times 3^1$\n        *   18 = $2^1 \\times 3^2$\n        *   সাধারণ মৌলিক উৎপাদক: 2 এবং 3।\n        *   সর্বনিম্ন ঘাত: $2^1$ (2) এবং $3^1$ (3)।\n        *   গসাগু = $2 \\times 3 = 6$\n2.  **ভাগ পদ্ধতি (Division Method):**\n    *   ছোট সংখ্যাটি দিয়ে বড় সংখ্যাটিকে ভাগ করুন।\n    *   ভাগশেষ দ্বারা পূর্ববর্তী ভাজককে ভাগ করুন।\n    *   এই প্রক্রিয়া চালিয়ে যান যতক্ষণ না ভাগশেষ 0 হয়।\n    *   শেষ ভাজকটিই হলো গসাগু।\n\n#### লসাগু ও গসাগুর সম্পর্ক\n\nদুটি সংখ্যার ক্ষেত্রে, তাদের লসাগু ও গসাগুর মধ্যে একটি গুরুত্বপূর্ণ সম্পর্ক রয়েছে:\n**দুটি সংখ্যার গুণফল = সংখ্যাগুলির লসাগু × সংখ্যাগুলির গসাগু**\n\n*   উদাহরণ: 12 এবং 18 এর ক্ষেত্রে, $12 \\times 18 = 216$ এবং $লসাগু(36) \\times গসাগু(6) = 216$।\n\n### দশমিক ও ভগ্নাংশ\n\nদশমিক এবং ভগ্নাংশ হলো একই সংখ্যার দুটি ভিন্ন উপস্থাপনা, যা গাণিতিক সমস্যা সমাধানে প্রায়শই ব্যবহৃত হয়।\n\n#### ভগ্নাংশ (Fractions)\n\nএকটি **ভগ্নাংশ** হলো একটি পূর্ণ বস্তুর অংশ বা একটি সংকলনের কিছু অংশকে বোঝায়। এটি $p/q$ আকারে প্রকাশ করা হয়, যেখানে $p$ হলো **লব (numerator)** এবং $q$ হলো **হর (denominator)**; $q \\ne 0$।\n\n*   **ভগ্নাংশের প্রকারভেদ:**\n    *   **প্রকৃত ভগ্নাংশ (Proper Fraction):** যেখানে লব হর অপেক্ষা ছোট হয়।\n        *   উদাহরণ: 1/2, 3/4।\n    *   **অপ্রকৃত ভগ্নাংশ (Improper Fraction):** যেখানে লব হর অপেক্ষা বড় বা সমান হয়।\n        *   উদাহরণ: 5/3, 7/4।\n    *   **মিশ্র ভগ্নাংশ (Mixed Fraction):** একটি পূর্ণ সংখ্যা এবং একটি প্রকৃত ভগ্নাংশের সমন্বয়ে গঠিত। এটি অপ্রকৃত ভগ্নাংশের অন্য একটি রূপ।\n        *   উদাহরণ: $1\\frac{1}{2}$ (যা 3/2)।\n    *   **সমতুল্য ভগ্নাংশ (Equivalent Fractions):** যে ভগ্নাংশগুলির মান একই কিন্তু লব ও হর ভিন্ন হয়।\n        *   উদাহরণ: 1/2 = 2/4 = 3/6।\n\n*   **ভগ্নাংশের গাণিতিক প্রক্রিয়া:**\n    *   **যোগ ও বিয়োগ:** একই হরবিশিষ্ট ভগ্নাংশের ক্ষেত্রে লবগুলির যোগ/বিয়োগ হয়। ভিন্ন হরবিশিষ্ট ভগ্নাংশের ক্ষেত্রে হরগুলির লসাগু করে তাদের সমহরে রূপান্তর করতে হয়।\n    *   **গুণ:** লবগুলির গুণফলকে হরগুলির গুণফল দ্বারা ভাগ করতে হয়।\n    *   **ভাগ:** প্রথম ভগ্নাংশকে দ্বিতীয় ভগ্নাংশের উল্টানো (reciprocal) রূপ দিয়ে গুণ করতে হয়।\n\n*   **ভগ্নাংশের তুলনা:** দুটি ভগ্নাংশের মধ্যে কোনটি বড় বা ছোট তা নির্ণয় করতে তাদের হর সমান করা হয়, অথবা ক্রস-গুণ (cross-multiplication) পদ্ধতি ব্যবহার করা হয়।\n\n#### দশমিক সংখ্যা (Decimal Numbers)\n\nএকটি **দশমিক সংখ্যা** হলো দশের ঘাতের উপর ভিত্তি করে লেখা একটি সংখ্যা, যেখানে একটি দশমিক বিন্দু পূর্ণ সংখ্যা অংশকে ভগ্নাংশ অংশ থেকে আলাদা করে।\n\n*   **দশমিক থেকে ভগ্নাংশে রূপান্তর:** দশমিকের পর যতগুলি অঙ্ক থাকে, 1-এর পর ততগুলি শূন্য বসিয়ে হর তৈরি করা হয় এবং দশমিক বিন্দুর ডানদিকের সংখ্যাটি লব হয়।\n    *   উদাহরণ: 0.25 = 25/100 = 1/4।\n*   **ভগ্নাংশ থেকে দশমিকে রূপান্তর:** লবকে হর দ্বারা ভাগ করে দশমিক সংখ্যায় রূপান্তর করা হয়।\n    *   উদাহরণ: 1/2 = 0.5।\n\n*   **দশমিক সংখ্যার প্রকারভেদ:**\n    *   **সসীম দশমিক (Terminating Decimals):** দশমিক বিন্দুর পর নির্দিষ্ট সংখ্যক অঙ্ক থাকে।\n        *   উদাহরণ: 0.5, 2.75।\n    *   **অসীম পৌনঃপুনিক দশমিক (Non-Terminating Recurring/Repeating Decimals):** দশমিক বিন্দুর পর এক বা একাধিক অঙ্ক বারবার পুনরাবৃত্তি হয়।\n        *   উদাহরণ: 0.333... ($\\overline{0.3}$), 1.272727... ($\\overline{1.27}$)।\n\n*   **দশমিক সংখ্যার গাণিতিক প্রক্রিয়া:**\n    *   **যোগ ও বিয়োগ:** দশমিক বিন্দু বরাবর রেখে সংখ্যাগুলি সাজিয়ে সাধারণ যোগ/বিয়োগের মতো করা হয়।\n    *   **গুণ:** দশমিক বিন্দু বিবেচনা না করে সংখ্যাগুলি গুণ করা হয় এবং গুণফলে যতগুলি দশমিক স্থান থাকে, ততগুলি দশমিক স্থান ডানদিক থেকে বামদিকে স্থাপন করা হয়।\n    *   **ভাগ:** ভাজককে পূর্ণ সংখ্যায় রূপান্তর করার জন্য দশমিক বিন্দু সরিয়ে নিয়ে যাওয়া হয় এবং ভাজ্যতেও একই সংখ্যক ঘর দশমিক বিন্দু সরানো হয়, তারপর ভাগ করা হয়।\n\nএই মৌলিক ধারণাগুলি আপনার গাণিতিক দক্ষতা বৃদ্ধিতে এবং প্রতিযোগিতামূলক পরীক্ষার সমস্যা সমাধানে দৃঢ় ভিত্তি তৈরি করবে। পরবর্তী অধ্যায়ে আমরা এই ধারণাগুলির প্রয়োগ দেখব।', 'ready', '2025-11-04 17:57:38', '2025-11-04 17:59:42'),
(63, 7, 2, 'সরলীকরণ ও আসন্ন মান', '# সরলীকরণ ও আসন্ন মান\n\nগণিত শুধু সমস্যা সমাধানের একটি প্রক্রিয়া নয়, এটি দক্ষতা এবং সময় ব্যবস্থাপনারও একটি শিল্প। এই অধ্যায়ে আমরা শিখব কিভাবে গাণিতিক সমস্যাগুলিকে সহজবোধ্য ও দ্রুত সমাধান করা যায়। আমরা সরলীকরণের জন্য **বডমাস নিয়ম** ব্যবহার করব এবং জটিল গণনাকে দ্রুত শেষ করার জন্য বিভিন্ন কৌশল, বিশেষ করে **আসন্ন মান** নির্ণয়ের পদ্ধতি সম্পর্কে জানব। এই দক্ষতাগুলি শুধু পরীক্ষার জন্য নয়, বরং দৈনন্দিন জীবনে দ্রুত হিসাব করার ক্ষেত্রেও অত্যন্ত গুরুত্বপূর্ণ।\n\n## বডমাস নিয়ম (BODMAS Rule)\n\nগণিতিক রাশিতে একাধিক অপারেশন, যেমন যোগ, বিয়োগ, গুণ, ভাগ, বন্ধনী ইত্যাদি থাকলে কোন কাজটি প্রথমে করতে হবে, তার একটি নির্দিষ্ট ক্রম রয়েছে। এই ক্রমটিই **বডমাস নিয়ম** (BODMAS Rule) নামে পরিচিত। এই নিয়মটি মেনে চললে একটি জটিল রাশির একটিমাত্র সঠিক উত্তর পাওয়া সম্ভব।\n\nবডমাস (BODMAS) হলো একটি সংক্ষিপ্ত রূপ, যা প্রতিটি অক্ষরের অর্থ নির্দেশ করে কাজের অগ্রাধিকার:\n\n*   **B** - **Brackets** (বন্ধনী): প্রথমে বন্ধনীর ভেতরের কাজ করতে হবে। বন্ধনীগুলি সাধারণত তিনটি প্রকারের হয়:\n    *   প্রথম বন্ধনী `( )`\n    *   দ্বিতীয় বন্ধনী `{ }`\n    *   তৃতীয় বন্ধনী `[ ]`\n    বন্ধনীগুলির মধ্যে ভেতরের থেকে বাইরের দিকে কাজ করতে হয় (অর্থাৎ, `( )` তারপর `{ }` তারপর `[ ]`)।\n*   **O** - **Order / Of** (ক্রম / এর): এর পরে ঘাত (powers), বর্গমূল (roots) এবং \"এর\" (of) এর কাজ করতে হবে। \"এর\" সাধারণত গুণের সমতুল্য।\n*   **D** - **Division** (ভাগ): এরপর ভাগের কাজ করতে হবে।\n*   **M** - **Multiplication** (গুণ): এরপর গুণের কাজ করতে হবে।\n*   **A** - **Addition** (যোগ): এরপর যোগের কাজ করতে হবে।\n*   **S** - **Subtraction** (বিয়োগ): সবশেষে বিয়োগের কাজ করতে হবে।\n\n**গুরুত্বপূর্ণ নোট:** ভাগ ও গুণের মধ্যে যে কোনো একটি আগে আসতে পারে, যদি তারা একই রাশিতে পাশাপাশি থাকে তবে বাম দিক থেকে শুরু করতে হবে। একই নিয়ম যোগ ও বিয়োগের ক্ষেত্রেও প্রযোজ্য।\n\n**উদাহরণ:** `18 ÷ 6 + 5 × (7 - 2)` সরল করুন।\n\n1.  **B** (বন্ধনী): `(7 - 2) = 5`\n    সুতরাং, রাশিটি দাঁড়ায়: `18 ÷ 6 + 5 × 5`\n2.  **O** (ক্রম/এর): এই রাশিতে কোনো ঘাত বা \"এর\" নেই।\n3.  **D** (ভাগ): `18 ÷ 6 = 3`\n    সুতরাং, রাশিটি দাঁড়ায়: `3 + 5 × 5`\n4.  **M** (গুণ): `5 × 5 = 25`\n    সুতরাং, রাশিটি দাঁড়ায়: `3 + 25`\n5.  **A** (যোগ): `3 + 25 = 28`\n6.  **S** (বিয়োগ): এই রাশিতে কোনো বিয়োগ নেই।\n\nসুতরাং, `18 ÷ 6 + 5 × (7 - 2) = 28`।\n\n## দ্রুত গণনা পদ্ধতি (Fast Calculation Methods)\n\nদ্রুত গণনা পদ্ধতিগুলি গণিত সমস্যা সমাধানের সময় বাঁচানোর পাশাপাশি নির্ভুলতা বাড়াতেও সাহায্য করে। বিশেষ করে প্রতিযোগিতামূলক পরীক্ষায় এই কৌশলগুলি অপরিহার্য।\n\n### যোগ ও বিয়োগের কৌশল\n\n*   **নিকটবর্তী দশকে/শতকে নিয়ে যোগ/বিয়োগ:**\n    *   `48 + 37` = `(50 - 2) + 37` = `50 + 37 - 2` = `87 - 2` = **85**\n    *   অথবা, `48 + 37` = `48 + (40 - 3)` = `48 + 40 - 3` = `88 - 3` = **85**\n*   **সংখ্যাগুলিকে ভেঙে যোগ/বিয়োগ:**\n    *   `123 + 45` = `(100 + 20 + 3) + (40 + 5)` = `100 + (20 + 40) + (3 + 5)` = `100 + 60 + 8` = **168**\n\n### গুণের কৌশল\n\n*   **১০, ১০০, ১০০০ ইত্যাদি দ্বারা গুণ:** সংখ্যার শেষে শূন্য যোগ করুন।\n    *   `27 × 100` = **2700**\n*   **৫, ২৫, ১২৫ দ্বারা গুণ:**\n    *   ৫ দ্বারা গুণ = সংখ্যাটিকে ১০ দ্বারা গুণ করে ২ দ্বারা ভাগ। `32 × 5` = `320 / 2` = **160**\n    *   ২৫ দ্বারা গুণ = সংখ্যাটিকে ১০০ দ্বারা গুণ করে ৪ দ্বারা ভাগ। `48 × 25` = `4800 / 4` = **1200**\n    *   ১২৫ দ্বারা গুণ = সংখ্যাটিকে ১০০০ দ্বারা গুণ করে ৮ দ্বারা ভাগ। `16 × 125` = `16000 / 8` = **2000**\n*   **৯, ৯৯, ৯৯৯ ইত্যাদি দ্বারা গুণ:**\n    *   `7 × 9` = `7 × (10 - 1)` = `70 - 7` = **63**\n    *   `15 × 99` = `15 × (100 - 1)` = `1500 - 15` = **1485**\n*   **বিচ্ছেদ পদ্ধতি (Distributive Property):**\n    *   `12 × 13` = `12 × (10 + 3)` = `(12 × 10) + (12 × 3)` = `120 + 36` = **156**\n\n### ভাগের কৌশল\n\n*   **বিভাজ্যতার নিয়ম:** কিছু সংখ্যার জন্য বিভাজ্যতার নিয়ম জানা থাকলে ভাগ দ্রুত করা যায়।\n    *   **২ দ্বারা:** যদি একক স্থানের অঙ্ক ০, ২, ৪, ৬, ৮ হয়।\n    *   **৩ দ্বারা:** যদি অঙ্কগুলির যোগফল ৩ দ্বারা বিভাজ্য হয়।\n    *   **৪ দ্বারা:** যদি শেষ দুটি অঙ্ক দ্বারা গঠিত সংখ্যা ৪ দ্বারা বিভাজ্য হয়।\n    *   **৫ দ্বারা:** যদি একক স্থানের অঙ্ক ০ বা ৫ হয়।\n    *   **৬ দ্বারা:** যদি সংখ্যাটি ২ এবং ৩ উভয় দ্বারা বিভাজ্য হয়।\n    *   **৯ দ্বারা:** যদি অঙ্কগুলির যোগফল ৯ দ্বারা বিভাজ্য হয়।\n    *   **১০ দ্বারা:** যদি একক স্থানের অঙ্ক ০ হয়।\n*   **ভগ্নাংশ সরলীকরণ:** ভাগ করার আগে লব ও হরকে তাদের সাধারণ গুণনীয়ক দিয়ে ভাগ করে ছোট করে নেওয়া।\n    *   `120 ÷ 15` = `(24 × 5) ÷ (3 × 5)` = `24 ÷ 3` = **8**\n\n### বর্গ ও বর্গমূলের কৌশল\n\n*   **৫-এ শেষ হওয়া সংখ্যার বর্গ:**\n    *   একটি সংখ্যার একক স্থানে ৫ থাকলে, তার বর্গের একক ও দশক স্থানের অঙ্ক সর্বদা **২৫** হয়।\n    *   বাকি অঙ্কগুলি পাওয়ার জন্য, ৫-এর আগের অঙ্কটিকে তার পরবর্তী পূর্ণসংখ্যা দ্বারা গুণ করতে হয়।\n    *   উদাহরণ: `35²`\n        *   একক ও দশক স্থান: `25`\n        *   ৩ এর পরবর্তী সংখ্যা ৪। `3 × 4 = 12`\n        *   সুতরাং, `35²` = **1225**\n    *   উদাহরণ: `75²`\n        *   একক ও দশক স্থান: `25`\n        *   ৭ এর পরবর্তী সংখ্যা ৮। `7 × 8 = 56`\n        *   সুতরাং, `75²` = **5625**\n*   **বর্গমূলের অনুমান:** একটি সংখ্যার বর্গমূল অনুমান করতে, তার নিকটবর্তী পূর্ণবর্গ সংখ্যাগুলি খুঁজে বের করুন।\n    *   উদাহরণ: `√3900`\n        *   `60² = 3600` এবং `70² = 4900`।\n        *   সুতরাং `√3900` এর মান ৬০ এবং ৭০ এর মাঝামাঝি। যেহেতু ৩৯০০, ৩৬০০ এর বেশি নিকটবর্তী, তাই বর্গমূলটি ৬০ এর কাছাকাছি হবে।\n\n### আসন্ন মান নির্ণয় (Finding Approximate Values)\n\nঅনেক সময় গাণিতিক সমস্যার সঠিক উত্তরের প্রয়োজন হয় না, বরং একটি কাছাকাছি বা আনুমানিক মানই যথেষ্ট হয়। এই আনুমানিক মান নির্ণয় প্রক্রিয়াকে **আসন্ন মান (Approximation)** বলে। এটি বিশেষত দ্রুত গণনা বা একাধিক পছন্দের উত্তর থেকে সঠিকটি বেছে নেওয়ার ক্ষেত্রে কার্যকর।\n\n*   **পূর্ণসংখ্যায় রূপান্তর (Rounding Off):**\n    *   যদি দশমিক বিন্দুর পরের প্রথম অঙ্ক ৫ বা ৫ এর বেশি হয়, তবে দশমিক বিন্দুর আগের অঙ্কটিকে ১ বাড়িয়ে দিতে হবে।\n        *   `3.7 ≈ 4`\n        *   `12.5 ≈ 13`\n    *   যদি দশমিক বিন্দুর পরের প্রথম অঙ্ক ৫ এর কম হয়, তবে দশমিক বিন্দুর আগের অঙ্কটিকে অপরিবর্তিত রাখতে হবে।\n        *   `6.3 ≈ 6`\n        *   `24.2 ≈ 24`\n    *   নির্দিষ্ট দশমিক স্থান পর্যন্ত আসন্ন মান নির্ণয় করার ক্ষেত্রেও এই নিয়ম প্রযোজ্য।\n        *   `5.678` কে দুই দশমিক স্থান পর্যন্ত আসন্ন মান: `5.68` (কারণ তৃতীয় অঙ্ক ৮, যা ৫ বা তার বেশি)\n        *   `10.123` কে দুই দশমিক স্থান পর্যন্ত আসন্ন মান: `10.12` (কারণ তৃতীয় অঙ্ক ৩, যা ৫ এর কম)\n*   **গণনার ক্ষেত্রে আসন্ন মানের প্রয়োগ:** জটিল গণনা সরল করতে প্রতিটি সংখ্যাকে নিকটবর্তী পূর্ণসংখ্যা বা সুবিধাজনক দশকে/শতকে নিয়ে আসা হয়।\n    *   উদাহরণ: `(49.8 × 20.1) ÷ 9.9` এর আসন্ন মান নির্ণয় করুন।\n        *   `49.8 ≈ 50`\n        *   `20.1 ≈ 20`\n        *   `9.9 ≈ 10`\n        *   আসন্ন মান: `(50 × 20) ÷ 10` = `1000 ÷ 10` = **100**\n        (প্রকৃত মান প্রায় ১০০.৬০৬)\n\nএই দ্রুত গণনা এবং আসন্ন মানের কৌশলগুলি নিয়মিত অনুশীলন করলে আপনি গণিতে আরও দক্ষ ও আত্মবিশ্বাসী হয়ে উঠবেন।', 'ready', '2025-11-04 17:57:38', '2025-11-04 17:59:18'),
(64, 7, 3, 'সংখ্যা শ্রেণী', NULL, 'idle', '2025-11-04 17:57:38', '2025-11-04 17:57:38'),
(65, 7, 4, 'দ্বিঘাত সমীকরণ', '## দ্বিঘাত সমীকরণ\n\nএই অধ্যায়ে আমরা **দ্বিঘাত সমীকরণ** (Quadratic Equation) সম্পর্কে বিস্তারিত জানব। একটি দ্বিঘাত সমীকরণ হলো এমন একটি বহুপদী সমীকরণ যার সর্বোচ্চ ঘাত দুই। এর সাধারণ রূপ হলো $ax^2 + bx + c = 0$, যেখানে $a$, $b$, $c$ বাস্তব সংখ্যা এবং $a \\neq 0$। এই সমীকরণগুলির সমাধান নির্ণয়ের জন্য আমরা দুটি প্রধান পদ্ধতি শিখব: উৎপাদক বিশ্লেষণ পদ্ধতি এবং সূত্র প্রয়োগ পদ্ধতি।\n\n### উৎপাদক বিশ্লেষণ পদ্ধতি\n\nউৎপাদক বিশ্লেষণ পদ্ধতি হলো একটি দ্বিঘাত সমীকরণকে দুটি রৈখিক উৎপাদকের গুণফল রূপে প্রকাশ করে সমাধান করার প্রক্রিয়া। এই পদ্ধতিতে সমীকরণের মূলগুলি সহজেই নির্ণয় করা যায়, যদি সমীকরণটিকে উৎপাদকে বিশ্লেষণ করা সম্ভব হয়।\n\n**পদ্ধতিগত ধাপসমূহ:**\n\n1.  প্রথমে সমীকরণটিকে এর **সাধারণ রূপে** সাজিয়ে নিতে হবে: $ax^2 + bx + c = 0$।\n2.  এবার এমন দুটি সংখ্যা নির্ণয় করতে হবে যাদের **গুণফল** $ac$ এবং **যোগফল** $b$ এর সমান।\n3.  এই দুটি সংখ্যা ব্যবহার করে মধ্যপদ ($bx$) কে দুটি অংশে ভাগ করে লিখতে হবে।\n4.  প্রথম দুটি পদ এবং শেষ দুটি পদ থেকে **সাধারণ উৎপাদক** (common factor) বের করে উৎপাদকে বিশ্লেষণ করতে হবে।\n5.  দুটি রৈখিক উৎপাদকের গুণফল শূন্য হলে, প্রতিটি উৎপাদককে শূন্যের সমান ধরে $x$ এর মান নির্ণয় করতে হবে। এই মানগুলিই হলো সমীকরণের মূল।\n\n**উদাহরণ:**\n$x^2 + 5x + 6 = 0$ সমীকরণটি সমাধান করি।\nএখানে $a=1, b=5, c=6$। আমাদের এমন দুটি সংখ্যা খুঁজতে হবে যাদের গুণফল $1 \\times 6 = 6$ এবং যোগফল $5$। সংখ্যা দুটি হলো $2$ এবং $3$।\n\n$x^2 + 2x + 3x + 6 = 0$\n$x(x+2) + 3(x+2) = 0$\n$(x+2)(x+3) = 0$\n\nঅতএব,\n$x+2=0 \\Rightarrow x=-2$\nঅথবা, $x+3=0 \\Rightarrow x=-3$\n\nসুতরাং, সমীকরণের মূলগুলি হলো $-2$ এবং $-3$।\n\n### সূত্র প্রয়োগ\n\nযখন উৎপাদক বিশ্লেষণ পদ্ধতি প্রয়োগ করা কঠিন বা সম্ভব হয় না, তখন দ্বিঘাত সমীকরণ সমাধানের জন্য **দ্বিঘাত সূত্র** (Quadratic Formula) ব্যবহার করা হয়। এটি সকল প্রকার দ্বিঘাত সমীকরণের মূল নির্ণয়ে কার্যকর।\n\n**দ্বিঘাত সূত্র:**\n\n$ax^2 + bx + c = 0$ (যেখানে $a \\neq 0$) আকারের একটি দ্বিঘাত সমীকরণের মূলগুলি নির্ণয়ের সূত্রটি হলো:\n\n$x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$\n\n**পদ্ধতিগত ধাপসমূহ:**\n\n1.  প্রথমে প্রদত্ত দ্বিঘাত সমীকরণটিকে **সাধারণ রূপে** ($ax^2 + bx + c = 0$) সাজিয়ে নিতে হবে।\n2.  সমীকরণ থেকে $a$, $b$, এবং $c$ এর **মানগুলি শনাক্ত** করতে হবে।\n3.  এই মানগুলি সরাসরি দ্বিঘাত সূত্রে বসাতে হবে।\n4.  সূত্রটি সমাধান করে $x$ এর মান বা মূলগুলি নির্ণয় করতে হবে। $x = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}$ এবং $x = \\frac{-b - \\sqrt{b^2 - 4ac}}{2a}$ থেকে দুটি মূল পাওয়া যাবে।\n\n**নির্ণায়ক (Discriminant):**\nসূত্রের মধ্যে $\\sqrt{}$ চিহ্নের ভেতরের অংশ $b^2 - 4ac$ কে **নির্ণায়ক** (Discriminant) বলা হয় এবং একে সাধারণত $D$ বা $\\Delta$ দ্বারা প্রকাশ করা হয়। এই নির্ণায়কের মান মূলগুলির প্রকৃতি নির্ধারণ করে:\n\n*   যদি $D > 0$ হয়, তাহলে সমীকরণের দুটি **ভিন্ন বাস্তব মূল** থাকবে।\n*   যদি $D = 0$ হয়, তাহলে সমীকরণের দুটি **সমান বাস্তব মূল** থাকবে (অর্থাৎ একটি স্বতন্ত্র মূল)।\n*   যদি $D < 0$ হয়, তাহলে সমীকরণের কোনো **বাস্তব মূল থাকবে না** (মূলগুলি জটিল বা অবাস্তব হবে)।\n\n**উদাহরণ:**\n$2x^2 + 3x - 5 = 0$ সমীকরণটি সমাধান করি।\nএখানে $a=2, b=3, c=-5$।\n\nদ্বিঘাত সূত্র ব্যবহার করে:\n$x = \\frac{-3 \\pm \\sqrt{3^2 - 4(2)(-5)}}{2(2)}$\n$x = \\frac{-3 \\pm \\sqrt{9 + 40}}{4}$\n$x = \\frac{-3 \\pm \\sqrt{49}}{4}$\n$x = \\frac{-3 \\pm 7}{4}$\n\nঅতএব,\n$x_1 = \\frac{-3 + 7}{4} = \\frac{4}{4} = 1$\n$x_2 = \\frac{-3 - 7}{4} = \\frac{-10}{4} = -\\frac{5}{2}$\n\nসুতরাং, সমীকরণের মূলগুলি হলো $1$ এবং $-\\frac{5}{2}$।', 'ready', '2025-11-04 17:57:38', '2025-11-04 17:58:36'),
(66, 7, 5, 'শতাংশ', 'এই অধ্যায়ে আমরা গণিতের অত্যন্ত গুরুত্বপূর্ণ একটি ধারণা, শতাংশ, সম্পর্কে বিস্তারিত জানব। দৈনন্দিন জীবনে কেনাকাটা থেকে শুরু করে অর্থনৈতিক লেনদেন, পরীক্ষার ফলাফল এমনকি দেশের জনসংখ্যা বৃদ্ধি বা হ্রাস – সব কিছুতেই শতাংশের ব্যবহার অনস্বীকার্য। এই অধ্যায়ে আমরা শতাংশের মৌলিক সংজ্ঞা, ভগ্নাংশ ও দশমিকের সাথে এর সম্পর্ক এবং বাস্তব জীবনের বিভিন্ন ক্ষেত্রে এর কার্যকর প্রয়োগ শিখব, যা আমাদের গাণিতিক সমস্যা সমাধানে দক্ষতা বাড়াতে সাহায্য করবে।\n\n## শতাংশের মৌলিক ধারণা\n\n**শতাংশ** (Percentage) হলো এমন একটি উপায় যার মাধ্যমে কোনো পরিমাণকে **একশ-এর মধ্যে কত** (per hundred) তা প্রকাশ করা হয়। এটি একটি অনুপাত যা ১০০-এর সাপেক্ষে কোনো অংশের আকার নির্দেশ করে। শতাংশ বোঝাতে আমরা **%** প্রতীকটি ব্যবহার করি।\n\n*   **শতাংশ কী বোঝায়?**\n    *   \"শত\" মানে হলো ১০০। তাই, শতাংশ মানে হলো প্রতি ১০০-এ কত।\n    *   উদাহরণস্বরূপ, যদি বলা হয় ৫০%, এর অর্থ হলো প্রতি ১০০-এর মধ্যে ৫০ ভাগ।\n    *   এটি সব সময় একটি সম্পূর্ণ অংশের সাপেক্ষে তার অংশ বোঝায়।\n\n*   **ভগ্নাংশ থেকে শতাংশে রূপান্তর:**\n    কোনো ভগ্নাংশকে শতাংশে রূপান্তর করতে হলে, সেটিকে ১০০ দ্বারা গুণ করতে হয়।\n    *   সূত্র: ভগ্নাংশ × ১০০%\n    *   উদাহরণ: $\\frac{1}{2}$ = $\\frac{1}{2} \\times 100\\%$ = ৫০%\n    *   উদাহরণ: $\\frac{3}{4}$ = $\\frac{3}{4} \\times 100\\%$ = ৭৫%\n\n*   **দশমিক থেকে শতাংশে রূপান্তর:**\n    কোনো দশমিক সংখ্যাকে শতাংশে রূপান্তর করতে হলে, সেটিকে ১০০ দ্বারা গুণ করতে হয়।\n    *   সূত্র: দশমিক সংখ্যা × ১০০%\n    *   উদাহরণ: ০.৫ = ০.৫ $\\times$ ১০০% = ৫০%\n    *   উদাহরণ: ০.৭৫ = ০.৭৫ $\\times$ ১০০% = ৭৫%\n\n*   **শতাংশ থেকে ভগ্নাংশ/দশমিকে রূপান্তর:**\n    কোনো শতাংশকে ভগ্নাংশ বা দশমিকে রূপান্তর করতে হলে, সেটিকে ১০০ দ্বারা ভাগ করতে হয়।\n    *   সূত্র: শতাংশ ÷ ১০০\n    *   উদাহরণ: ২৫% = $\\frac{25}{100}$ = $\\frac{1}{4}$ (ভগ্নাংশ) = ০.২৫ (দশমিক)\n    *   উদাহরণ: ১০% = $\\frac{10}{100}$ = $\\frac{1}{10}$ (ভগ্নাংশ) = ০.১ (দশমিক)\n\n## শতাংশের ব্যবহারিক প্রয়োগ\n\nশতাংশ আমাদের দৈনন্দিন জীবনের বিভিন্ন ক্ষেত্রে গভীরভাবে জড়িত। নিচে এর কিছু গুরুত্বপূর্ণ ব্যবহারিক প্রয়োগ আলোচনা করা হলো:\n\n### লাভ ও ক্ষতি (Profit and Loss)\nব্যবসা-বাণিজ্যে লাভ বা ক্ষতির পরিমাণ মোট ক্রয়মূল্যের সাপেক্ষে শতাংশে প্রকাশ করা হয়।\n*   **লাভের শতাংশ:** $\\frac{লাভ}{ক্রয়মূল্য} \\times ১০০\\%$\n*   **ক্ষতির শতাংশ:** $\\frac{ক্ষতি}{ক্রয়মূল্য} \\times ১০০\\%$\nউদাহরণ: একটি জিনিস ৫০০ টাকায় কিনে ৬০০ টাকায় বিক্রি করলে লাভ হয় ১০০ টাকা। লাভের শতাংশ হবে $\\frac{১০০}{৫০০} \\times ১০০\\%$ = ২০%।\n\n### ডিসকাউন্ট ও ছাড় (Discount and Sale)\nদোকানে পণ্যের উপর দেওয়া ছাড় সাধারণত শতাংশে প্রকাশ করা হয়।\n*   **ছাড়ের পরিমাণ:** চিহ্নিত মূল্য $\\times$ ছাড়ের শতাংশ\nউদাহরণ: একটি ৫০০ টাকার শার্টের উপর ২০% ছাড় দেওয়া হলে, ছাড়ের পরিমাণ হবে ৫০০ টাকার ২০% = $\\frac{২০}{১০০} \\times ৫০০$ = ১০০ টাকা।\n\n### ব্যাংকের সুদ (Bank Interest)\nব্যাংকে টাকা জমা রাখলে বা ঋণ নিলে, নির্দিষ্ট সময়ের জন্য যে সুদ দেওয়া বা নেওয়া হয়, তা সাধারণত বার্ষিক শতাংশ হারে প্রকাশ করা হয়। একে **সুদের হার** বলে।\n*   **সরল সুদ:** আসল $\\times$ সুদের হার $\\times$ সময় (বছরে)\nউদাহরণ: ১০,০০০ টাকা ৫% বার্ষিক সরল সুদে ১ বছরের জন্য রাখলে সুদ হবে ১০,০০০ $\\times \\frac{৫}{১০০} \\times ১$ = ৫০০ টাকা।\n\n### পরীক্ষার ফলাফল (Exam Results)\nশিক্ষার্থীরা পরীক্ষায় মোট প্রাপ্ত নম্বরকে শতাংশে প্রকাশ করে তাদের পারফরম্যান্স মূল্যায়ন করে।\n*   **প্রাপ্ত নম্বরের শতাংশ:** $\\frac{প্রাপ্ত নম্বর}{মোট নম্বর} \\times ১০০\\%$\nউদাহরণ: একটি পরীক্ষায় ৫০০ নম্বরের মধ্যে ৪৫০ পেলে, প্রাপ্ত নম্বরের শতাংশ হবে $\\frac{৪৫০}{৫০০} \\times ১০০\\%$ = ৯০%।\n\n### জনসংখ্যা বৃদ্ধি বা হ্রাস (Population Growth or Decline)\nকোনো শহর বা দেশের জনসংখ্যা বৃদ্ধি বা হ্রাসের হার শতাংশে প্রকাশ করা হয়।\n*   **বৃদ্ধির হার:** $\\frac{বর্তমান জনসংখ্যা - পূর্বের জনসংখ্যা}{পূর্বের জনসংখ্যা} \\times ১০০\\%$\n*   **হ্রাসের হার:** $\\frac{পূর্বের জনসংখ্যা - বর্তমান জনসংখ্যা}{পূর্বের জনসংখ্যা} \\times ১০০\\%$\n\n### কমিশন ও ভ্যাট (Commission and VAT)\nঅনেক সময় বিক্রয়কর্মী বা এজেন্টের পারিশ্রমিক বিক্রিত মূল্যের শতাংশ হিসাবে ধার্য করা হয়, যা কমিশন নামে পরিচিত। একইভাবে, সরকার বিভিন্ন পণ্যের উপর **মূল্য সংযোজন কর (VAT)** শতাংশ হিসাবে ধার্য করে।\n\nশতাংশ একটি বহুমুখী গাণিতিক ধারণা যা আমাদের চারপাশের তথ্যকে আরও সহজে বুঝতে ও বিশ্লেষণ করতে সহায়তা করে। এই ধারণাটি ভালোভাবে আয়ত্ত করতে পারলে আপনি বাস্তব জীবনের অনেক সমস্যার সমাধান করতে পারবেন।', 'ready', '2025-11-04 17:57:38', '2025-11-04 17:58:35'),
(67, 7, 6, 'লাভ ও ক্ষতি', 'এই অধ্যায়ে আমরা লাভ ও ক্ষতির মৌলিক ধারণাগুলি অন্বেষণ করব, যা আমাদের দৈনন্দিন কেনাবেচা এবং ব্যবসায়িক লেনদেনের একটি অবিচ্ছেদ্য অংশ। আমরা পণ্য কেনা, বেচা এবং তার উপর মূল্য নির্ধারণের বিভিন্ন দিক, যেমন— ক্রয়মূল্য, বিক্রয়মূল্য, চিহ্নিত মূল্য এবং ছাড়ের মতো গুরুত্বপূর্ণ বিষয়গুলি বিস্তারিতভাবে আলোচনা করব, যা আপনাকে লাভ বা ক্ষতি নির্ণয় করতে সাহায্য করবে।\n\n## ক্রয়মূল্য, বিক্রয়মূল্য ও চিহ্নিত মূল্য\n\nএকটি পণ্যের আর্থিক লেনদেনের মূল ভিত্তি হলো তার ক্রয়মূল্য, বিক্রয়মূল্য এবং চিহ্নিত মূল্য। এই ধারণাগুলি লাভ বা ক্ষতি নির্ণয়ের জন্য অপরিহার্য।\n\n### ক্রয়মূল্য (Cost Price - CP)\nক্রয়মূল্য হলো **যে দামে একজন ব্যবসায়ী বা বিক্রেতা কোনো পণ্য কেনেন**। এটি পণ্য কেনার জন্য প্রাথমিক ব্যয়।\n*   এটি বিক্রেতার জন্য পণ্যের **মূল বিনিয়োগ**।\n*   উদাহরণস্বরূপ, একজন দোকানদার যদি পাইকারি বাজার থেকে ১০০ টাকায় একটি খেলনা কেনেন, তবে খেলনাটির ক্রয়মূল্য হবে ১০০ টাকা।\n*   লাভ বা ক্ষতি সবসময় ক্রয়মূল্যের সাপেক্ষে গণনা করা হয়।\n\n### বিক্রয়মূল্য (Selling Price - SP)\nবিক্রয়মূল্য হলো **যে দামে একজন বিক্রেতা পণ্যটি গ্রাহকের কাছে বিক্রি করেন**। এটি পণ্য বিক্রি করে প্রাপ্ত আয়।\n*   বিক্রেতার আয়ের **প্রাথমিক উৎস** হলো বিক্রয়মূল্য।\n*   পূর্বের উদাহরণে, দোকানদার যদি খেলনাটি ১২০ টাকায় বিক্রি করেন, তবে এর বিক্রয়মূল্য হবে ১২০ টাকা।\n\n### লাভ (Profit)\nযদি **বিক্রয়মূল্য ক্রয়মূল্যের চেয়ে বেশি হয়**, তবে তাকে লাভ বলে।\n*   **লাভ = বিক্রয়মূল্য - ক্রয়মূল্য**\n*   **লাভের হার = (লাভ / ক্রয়মূল্য) × ১০০%**\n*   উদাহরণ: ক্রয়মূল্য ১০০ টাকা, বিক্রয়মূল্য ১২০ টাকা হলে, লাভ = ১২০ - ১০০ = ২০ টাকা। লাভের হার = (২০ / ১০০) × ১০০% = ২০%।\n\n### ক্ষতি (Loss)\nযদি **ক্রয়মূল্য বিক্রয়মূল্যের চেয়ে বেশি হয়**, তবে তাকে ক্ষতি বলে।\n*   **ক্ষতি = ক্রয়মূল্য - বিক্রয়মূল্য**\n*   **ক্ষতির হার = (ক্ষতি / ক্রয়মূল্য) × ১০০%**\n*   উদাহরণ: ক্রয়মূল্য ১০০ টাকা, বিক্রয়মূল্য ৮০ টাকা হলে, ক্ষতি = ১০০ - ৮০ = ২০ টাকা। ক্ষতির হার = (২০ / ১০০) × ১০০% = ২০%।\n\n### চিহ্নিত মূল্য (Marked Price - MP) বা ধার্য মূল্য (List Price)\nচিহ্নিত মূল্য হলো **পণ্যের প্যাকেটে বা দোকানে প্রদর্শিত মূল্য**। এই মূল্য সাধারণত ক্রয়মূল্যের চেয়ে বেশি রাখা হয়, কারণ এর উপর ছাড় দেওয়া হয়।\n*   এটি সেই মূল্য যার উপর ভিত্তি করে সাধারণত **ছাড়** দেওয়া হয়।\n*   প্রায়শই, চিহ্নিত মূল্য বিক্রেতাকে লাভ করার সুযোগ দেয়, এমনকি ছাড় দেওয়ার পরেও।\n\n## ছাড়\n\nছাড় হলো চিহ্নিত মূল্যের উপর একটি নির্দিষ্ট পরিমাণ **মূল্য হ্রাস** যা গ্রাহকদের আকর্ষণ করার জন্য বা পণ্যের স্টক খালি করার জন্য দেওয়া হয়।\n\n### ছাড় (Discount)\nছাড় হলো **চিহ্নিত মূল্য থেকে যে পরিমাণ অর্থ কমানো হয়**।\n*   **ছাড় = চিহ্নিত মূল্য - বিক্রয়মূল্য**\n*   উদাহরণ: একটি শার্টের চিহ্নিত মূল্য ৫০০ টাকা। যদি দোকানদার এটি ৪৫০ টাকায় বিক্রি করেন, তবে ছাড় = ৫০০ - ৪৫০ = ৫০ টাকা।\n\n### ছাড়ের হার (Discount Percentage)\nছাড়ের হার হলো **চিহ্নিত মূল্যের শতাংশ হিসেবে প্রকাশিত ছাড়ের পরিমাণ**।\n*   **ছাড়ের হার = (ছাড় / চিহ্নিত মূল্য) × ১০০%**\n*   **গুরুত্বপূর্ণ:** ছাড় সবসময় **চিহ্নিত মূল্যের (Marked Price)** উপর গণনা করা হয়, ক্রয়মূল্যের উপর নয়।\n*   উদাহরণ: পূর্বের শার্টের উদাহরণে, ছাড় ৫০ টাকা এবং চিহ্নিত মূল্য ৫০০ টাকা। ছাড়ের হার = (৫০ / ৫০০) × ১০০% = ১০%।\n\n### ছাড় এবং লাভ/ক্ষতির সম্পর্ক\nএকজন বিক্রেতা ছাড় দেওয়ার পরেও লাভ করতে পারেন, যদি ছাড়ের পর বিক্রয়মূল্য ক্রয়মূল্যের চেয়ে বেশি হয়। আবার, যদি ছাড়ের কারণে বিক্রয়মূল্য ক্রয়মূল্যের চেয়ে কম হয়ে যায়, তবে বিক্রেতার ক্ষতি হতে পারে।\n*   **বিক্রয়মূল্য (SP) = চিহ্নিত মূল্য (MP) - ছাড়**\n*   লাভ বা ক্ষতি নির্ধারণের জন্য এই প্রাপ্ত বিক্রয়মূল্যকে ক্রয়মূল্যের সাথে তুলনা করা হয়।', 'ready', '2025-11-04 17:57:38', '2025-11-04 17:58:36'),
(68, 7, 7, 'অনুপাত ও সমানুপাত', 'এই অধ্যায়ে আমরা গণিতের একটি মৌলিক অথচ অত্যন্ত গুরুত্বপূর্ণ ধারণা, অনুপাত ও সমানুপাত (Ratio and Proportion) নিয়ে আলোচনা করব। দৈনন্দিন জীবনের বিভিন্ন ক্ষেত্রে এবং উচ্চতর গণিতে এই ধারণাগুলি অপরিহার্য। দুটি সমজাতীয় রাশির মধ্যে তুলনা থেকে শুরু করে একাধিক রাশির মধ্যে সম্পর্ক স্থাপন পর্যন্ত এর ব্যাপক ব্যবহার রয়েছে। আমরা এখানে অনুপাত ও সমানুপাতের মূল ধারণা এবং মিশ্র অনুপাত গঠনের পদ্ধতি সম্পর্কে বিস্তারিত জানব।\n\n## অনুপাত ও সমানুপাতের ধারণা\n\n*   **অনুপাত (Ratio):**\n    *   দুটি **সমজাতীয় রাশির** তুলনাকে অনুপাত বলে, যা ভাগ প্রক্রিয়ার মাধ্যমে প্রকাশ করা হয়। যেমন, দুটি দৈর্ঘ্য, দুটি ওজন বা দুটি পরিমাণের মধ্যে তুলনা।\n    *   গুরুত্বপূর্ণ বিষয় হলো, তুলনা করার জন্য রাশি দুটির একক **একই** হতে হবে।\n    *   যদি দুটি রাশি \'a\' এবং \'b\' হয়, তবে তাদের অনুপাতকে **a:b** অথবা **a/b** আকারে লেখা হয়।\n    *   অনুপাতের প্রথম পদকে **পূর্বপদ (Antecedent)** এবং দ্বিতীয় পদকে **উত্তরপদ (Consequent)** বলা হয়।\n    *   উদাহরণস্বরূপ, যদি একটি পেন্সিলের দৈর্ঘ্য 15 সেমি এবং একটি খাতার দৈর্ঘ্য 30 সেমি হয়, তবে তাদের দৈর্ঘ্যের অনুপাত হলো 15:30, যা সরলীকরণ করে 1:2 হয়।\n*   **অনুপাতের প্রকারভেদ (Types of Ratios):**\n    *   **ব্যস্ত অনুপাত (Inverse Ratio):** কোনো অনুপাত a:b হলে, তার ব্যস্ত অনুপাত হলো b:a।\n    *   **বর্গানুপাত (Duplicate Ratio):** কোনো অনুপাত a:b হলে, তার বর্গানুপাত হলো a²:b²।\n    *   **বর্গমূলানুপাত (Sub-duplicate Ratio):** কোনো অনুপাত a:b হলে, তার বর্গমূলানুপাত হলো √a:√b।\n    *   **ঘনানুপাত (Triplicate Ratio):** কোনো অনুপাত a:b হলে, তার ঘনানুপাত হলো a³:b³।\n    *   **ঘণমূলানুপাত (Sub-triplicate Ratio):** কোনো অনুপাত a:b হলে, তার ঘণমূলানুপাত হলো ³√a:³√b।\n*   **সমানুপাত (Proportion):**\n    *   দুটি অনুপাত যখন **সমান** হয়, তখন তাদের মধ্যে যে সম্পর্ক তৈরি হয়, তাকে সমানুপাত বলে।\n    *   যদি a:b এবং c:d দুটি সমান অনুপাত হয়, তবে আমরা লিখতে পারি **a:b = c:d**। এই সম্পর্ককে সমানুপাত বলা হয়।\n    *   এখানে a, b, c, d এই চারটি পদকে সমানুপাতী পদ বলা হয়।\n    *   প্রথম ও চতুর্থ পদকে **প্রান্তীয় পদ (Extremes)** (a ও d) এবং দ্বিতীয় ও তৃতীয় পদকে **মধ্যপদ (Means)** (b ও c) বলে।\n    *   সমানুপাতের একটি গুরুত্বপূর্ণ বৈশিষ্ট্য হলো: **প্রান্তীয় পদগুলির গুণফল = মধ্যপদগুলির গুণফল** (অর্থাৎ, a × d = b × c)।\n    *   **ক্রমিক সমানুপাত (Continued Proportion):** যদি তিনটি পদ a, b, c এমনভাবে থাকে যে a:b = b:c হয়, তবে তাদের ক্রমিক সমানুপাতী বলা হয়। এক্ষেত্রে \'b\' কে **মধ্য সমানুপাতী (Mean Proportional)** বলে।\n\n## মিশ্র অনুপাত (Compound Ratio)\n\n*   **সংজ্ঞা:** দুই বা ততোধিক সরল অনুপাতকে একত্রিত করে যে নতুন অনুপাত গঠন করা হয়, তাকে **মিশ্র অনুপাত** বা যৌগিক অনুপাত বলে।\n*   **গঠন পদ্ধতি:**\n    *   একাধিক অনুপাতের পূর্বপদগুলি গুণ করে মিশ্র অনুপাতের **পূর্বপদ** পাওয়া যায়।\n    *   একাধিক অনুপাতের উত্তরপদগুলি গুণ করে মিশ্র অনুপাতের **উত্তরপদ** পাওয়া যায়।\n*   যদি তিনটি অনুপাত a:b, c:d এবং e:f হয়, তবে তাদের মিশ্র অনুপাত হবে:\n    *   (a × c × e) : (b × d × f)\n*   উদাহরণস্বরূপ, যদি 2:3, 5:4 এবং 1:2 এই তিনটি অনুপাত থাকে, তবে তাদের মিশ্র অনুপাত হবে:\n    *   পূর্বপদগুলির গুণফল: 2 × 5 × 1 = 10\n    *   উত্তরপদগুলির গুণফল: 3 × 4 × 2 = 24\n    *   সুতরাং, মিশ্র অনুপাতটি হলো **10:24**, যা সরলীকরণ করে **5:12** হয়।', 'ready', '2025-11-04 17:57:38', '2025-11-04 17:59:19'),
(69, 7, 8, 'অংশীদারিত্ব', 'এই অধ্যায়ে আমরা ব্যবসার মালিকানা কাঠামোর দুটি প্রাথমিক রূপ, **একক মালিকানা** (Sole Proprietorship) এবং **অংশীদারিত্ব** (Partnership) সম্পর্কে বিস্তারিত আলোচনা করব। একটি ব্যবসা একজন একক ব্যক্তি দ্বারা পরিচালিত হতে পারে, অথবা একাধিক ব্যক্তি মিলে এর মালিকানা ও পরিচালনার দায়িত্ব নিতে পারে। আমরা প্রতিটি কাঠামোর সংজ্ঞা, বৈশিষ্ট্য, সুবিধা এবং অসুবিধাগুলো পরীক্ষা করব, যাতে পাঠক বিভিন্ন ধরনের ব্যবসায়িক সত্তা সম্পর্কে একটি স্পষ্ট ধারণা লাভ করতে পারেন।\n\n## একক ও যৌথ অংশীদারিত্ব\n\nএই উপধারায় আমরা দুটি মৌলিক ব্যবসায়িক কাঠামোর একটি তুলনামূলক আলোচনা করব: একক মালিকানা, যা একক ব্যক্তি দ্বারা পরিচালিত হয়, এবং যৌথ অংশীদারিত্ব, যেখানে একাধিক ব্যক্তি একটি ব্যবসা পরিচালনা করে।\n\n### একক মালিকানা (Sole Proprietorship)\n\n**একক মালিকানা** হলো ব্যবসার সবচেয়ে সহজ এবং প্রচলিত একটি রূপ, যেখানে একজন ব্যক্তি ব্যবসার মালিক এবং এর সম্পূর্ণ নিয়ন্ত্রণ তার হাতে থাকে। এই মালিকানা কাঠামোর অধীনে, ব্যবসার সকল লাভ বা ক্ষতির জন্য মালিক একাই দায়ী থাকেন।\n\n*   **সংজ্ঞা (Definition):**\n    একক মালিকানা বলতে এমন একটি ব্যবসায়িক সত্তাকে বোঝায় যেখানে একজন ব্যক্তি মালিক হিসাবে ব্যবসাটি পরিচালনা করেন এবং এর সমস্ত দায় ও সম্পদের অধিকারী হন। মালিক এবং ব্যবসা এখানে আইনগতভাবে অভিন্ন সত্তা।\n\n*   **বৈশিষ্ট্য (Characteristics):**\n    *   **একক মালিকানা ও নিয়ন্ত্রণ:** ব্যবসার সম্পূর্ণ মালিকানা ও সিদ্ধান্ত গ্রহণের ক্ষমতা একক ব্যক্তির হাতে থাকে।\n    *   **অসীম দায় (Unlimited Liability):** মালিক ব্যবসার সমস্ত ঋণের জন্য ব্যক্তিগতভাবে দায়ী থাকেন। ব্যবসার দায় মেটাতে তার ব্যক্তিগত সম্পদও ব্যবহৃত হতে পারে। এটি একক মালিকানার একটি **গুরুত্বপূর্ণ বৈশিষ্ট্য**।\n    *   **সহজ গঠন ও বিলোপ:** একক মালিকানা গঠন করা তুলনামূলকভাবে সহজ এবং আইনি আনুষ্ঠানিকতা কম। এটি বিলোপ করাও সহজ।\n    *   **মালিক ও ব্যবসার অভিন্নতা:** আইনগতভাবে, ব্যবসার একটি পৃথক সত্তা থাকে না; মালিক এবং ব্যবসা এক হিসাবে বিবেচিত হয়।\n    *   **সকল মুনাফার মালিক:** ব্যবসার সমস্ত লাভ একক মালিকের কাছে যায়।\n    *   **সীমিত মেয়াদ:** মালিকের মৃত্যু, অসুস্থতা বা অন্য কোনো কারণে ব্যবসার অস্তিত্ব হুমকিতে পড়তে পারে।\n\n*   **সুবিধা (Advantages):**\n    *   **সহজ গঠন:** দ্রুত এবং কম খরচায় ব্যবসা শুরু করা যায়।\n    *   **সম্পূর্ণ নিয়ন্ত্রণ:** মালিকের সকল বিষয়ে চূড়ান্ত সিদ্ধান্ত নেওয়ার স্বাধীনতা থাকে।\n    *   **সকল মুনাফার ভোগ:** ব্যবসার সকল লাভ মালিক নিজেই ভোগ করেন।\n    *   **নমনীয়তা:** ব্যবসার কার্যক্রম দ্রুত পরিবর্তন করা বা খাপ খাইয়ে নেওয়া সহজ।\n\n*   **অসুবিধা (Disadvantages):**\n    *   **অসীম দায়:** এটি সবচেয়ে বড় অসুবিধা, কারণ মালিকের ব্যক্তিগত সম্পদ ঝুঁকির মধ্যে থাকে।\n    *   **সীমিত মূলধন:** মূলধন সংগ্রহের সুযোগ মালিকের ব্যক্তিগত সম্পদ বা ঋণ নেওয়ার ক্ষমতার মধ্যে সীমাবদ্ধ থাকে।\n    *   **সীমিত দক্ষতা:** একজন ব্যক্তির পক্ষে ব্যবসার সকল ক্ষেত্রে সমানভাবে দক্ষ হওয়া কঠিন হতে পারে।\n    *   **স্থায়িত্বের অভাব:** মালিকের অনুপস্থিতি বা মৃত্যুতে ব্যবসার ধারাবাহিকতা ব্যাহত হতে পারে।\n\n### যৌথ অংশীদারিত্ব (Partnership)\n\n**যৌথ অংশীদারিত্ব** এমন একটি ব্যবসায়িক কাঠামো যেখানে দুইজন বা ততোধিক ব্যক্তি একটি ব্যবসা পরিচালনা করতে এবং এর লাভ-লোকসান ভাগ করে নিতে সম্মত হন। এটি একটি চুক্তির মাধ্যমে গঠিত হয় এবং অংশীদারিত্ব আইন দ্বারা পরিচালিত হয়।\n\n*   **সংজ্ঞা (Definition):**\n    যৌথ অংশীদারিত্ব হলো এমন একটি ব্যবসায়িক সম্পর্ক যেখানে দুইজন বা ততোধিক ব্যক্তি মুনাফা অর্জনের উদ্দেশ্যে একটি ব্যবসা পরিচালনা করতে সম্মত হন। ব্যবসাটি সকলের দ্বারা অথবা তাদের মধ্যে যেকোনো একজন দ্বারা সকলের পক্ষে পরিচালিত হতে পারে।\n\n*   **বৈশিষ্ট্য (Characteristics):**\n    *   **একাধিক মালিকানা:** দুইজন বা ততোধিক ব্যক্তি (আইন দ্বারা নির্ধারিত সর্বোচ্চ সংখ্যক) এর মালিক হন।\n    *   **চুক্তিবদ্ধ সম্পর্ক:** অংশীদারিত্ব একটি চুক্তি (লিখিত বা মৌখিক) দ্বারা প্রতিষ্ঠিত হয়, যেখানে লাভ-লোকসান বন্টন, মূলধনের অবদান, দায়িত্ব ইত্যাদি উল্লেখ থাকে। এটি **অংশীদারিত্বের মূল ভিত্তি**।\n    *   **মুনাফা ও ক্ষতি বন্টন:** চুক্তিতে নির্ধারিত অনুপাত অনুযায়ী অংশীদারদের মধ্যে লাভ-লোকসান বণ্টিত হয়।\n    *   **পারস্পরিক প্রতিনিধিত্ব (Mutual Agency):** প্রতিটি অংশীদার অন্য অংশীদারদের এবং সমগ্র প্রতিষ্ঠানের প্রতিনিধি হিসাবে কাজ করতে পারে এবং তাদের সিদ্ধান্তগুলো অন্য অংশীদারদের জন্য বাধ্যতামূলক।\n    *   **অসীম দায় (Unlimited Liability):** সাধারণত, সাধারণ অংশীদারিত্বে সকল অংশীদারের দায় **অসীম** থাকে, অর্থাৎ ব্যক্তিগত সম্পদও ব্যবসার দায় পরিশোধে ব্যবহৃত হতে পারে।\n    *   **সীমিত আয়ুষ্কাল (Limited Life):** একজন অংশীদারের মৃত্যু, অবসর, বা দেউলিয়াত্বের কারণে অংশীদারিত্ব ভেঙে যেতে পারে, যদি না চুক্তিতে ভিন্ন কোনো বিধান থাকে।\n    *   **পৃথক সত্তার অভাব:** আইনগতভাবে, অংশীদারিত্বকে সাধারণত এর অংশীদারদের থেকে পৃথক একটি সত্তা হিসাবে গণ্য করা হয় না।\n\n*   **সুবিধা (Advantages):**\n    *   **সহজ গঠন:** একক মালিকানার মতো এটিও কোম্পানি গঠনের চেয়ে সহজ।\n    *   **বর্ধিত মূলধন:** একাধিক অংশীদার থাকায় একক মালিকানার তুলনায় অধিক মূলধন সংগ্রহ করা যায়।\n    *   **ঝুঁকি বন্টন:** ব্যবসার ঝুঁকি অংশীদারদের মধ্যে বণ্টিত হয়।\n    *   **দক্ষতার সমন্বয়:** বিভিন্ন অংশীদার তাদের বিভিন্ন দক্ষতা এবং অভিজ্ঞতা একত্রিত করতে পারে, যা ব্যবসার জন্য উপকারী।\n    *   **দ্রুত সিদ্ধান্ত গ্রহণ:** একক মালিকানার মতো দ্রুত সিদ্ধান্ত নেওয়া সম্ভব, যদিও অংশীদারদের মধ্যে ঐকমত্য প্রয়োজন।\n\n*   **অসুবিধা (Disadvantages):**\n    *   **অসীম দায়:** এটি অংশীদারিত্বের একটি **প্রধান ঝুঁকি**, কারণ প্রতিটি অংশীদার ব্যক্তিগতভাবে ব্যবসার সকল ঋণের জন্য দায়ী থাকে, এমনকি অন্যদের কৃতকর্মের জন্যও।\n    *   **বিবাদের সম্ভাবনা:** একাধিক অংশীদার থাকায় সিদ্ধান্ত গ্রহণ এবং পরিচালনার ক্ষেত্রে মতবিরোধ দেখা দিতে পারে।\n    *   **সীমিত আয়ুষ্কাল:** একজন অংশীদারের বিচ্ছেদ বা মৃত্যুতে অংশীদারিত্ব ভেঙে যেতে পারে, যা ব্যবসার ধারাবাহিকতাকে প্রভাবিত করে।\n    *   **মালিকানা হস্তান্তরের জটিলতা:** অংশীদারিত্বের অংশ হস্তান্তর করা একক মালিকানার মতো সহজ নয়; সাধারণত অন্যান্য অংশীদারদের সম্মতি প্রয়োজন হয়।\n    *   **গোপনীয়তার অভাব:** সকল অংশীদার ব্যবসার তথ্যে প্রবেশাধিকার পায়, ফলে গোপনীয়তা বজায় রাখা কঠিন হতে পারে।', 'ready', '2025-11-04 17:57:38', '2025-11-04 17:59:12'),
(70, 7, 9, 'মিশ্রণ ও সংমিশ্রণ', 'এই অধ্যায়ে, আমরা মিশ্রণ ও সংমিশ্রণের মৌলিক ধারণাগুলি অন্বেষণ করব। আমরা দেখব কীভাবে বিভিন্ন পদার্থ একত্রিত হয়ে মিশ্রণ তৈরি করে, যেখানে তাদের স্বতন্ত্র বৈশিষ্ট্যগুলি বজায় থাকে। এই প্রক্রিয়াটি বুঝতে এবং মিশ্রণকে বিশুদ্ধ পদার্থ বা রাসায়নিক যৌগ থেকে আলাদা করতে কিছু নির্দিষ্ট নিয়ম রয়েছে, যা আমরা এই অধ্যায়ে বিস্তারিত আলোচনা করব। আমাদের দৈনন্দিন জীবনে বায়ু থেকে শুরু করে খাবারের পদ পর্যন্ত সর্বত্রই মিশ্রণের গুরুত্ব অপরিসীম।\n\n## মিশ্রণ ও সংমিশ্রণ\n\nআমাদের চারপাশের প্রকৃতিতে আমরা অসংখ্য বস্তু দেখি যা বিশুদ্ধ কোনো পদার্থ নয়, বরং একাধিক উপাদানের সমন্বয়ে গঠিত। এই ধরনের সমাবেশকে সাধারণত **মিশ্রণ** (Mixture) বা **সংমিশ্রণ** (Combination) বলা হয়। যদিও দুটি শব্দ প্রায়শই সমার্থকভাবে ব্যবহৃত হয়, বিশেষ করে সাধারণ প্রসঙ্গে, তবে বৈজ্ঞানিক আলোচনায় এদের সুনির্দিষ্ট অর্থ রয়েছে।\n\n*   **মিশ্রণ (Mixture):** যখন দুই বা ততোধিক পদার্থ ভৌতভাবে একত্রিত হয় কিন্তু রাসায়নিকভাবে বিক্রিয়া করে না, তখন তাকে মিশ্রণ বলে। মিশ্রণের প্রতিটি উপাদান তার **নিজস্ব রাসায়নিক বৈশিষ্ট্য** বজায় রাখে। এই উপাদানগুলিকে সাধারণত ভৌত প্রক্রিয়ার মাধ্যমে আলাদা করা যায়।\n*   **সংমিশ্রণ (Combination):** এটি একটি বৃহত্তর ধারণা, যা কেবল ভৌত মিশ্রণকেই বোঝাতে পারে না, বরং যেকোনো ধরনের একত্রিত হওয়াকেও বোঝায়। তবে, রসায়নে, যখন \"মিশ্রণ\" এর সাথে তুলনা করা হয়, তখন \"সংমিশ্রণ\" সাধারণত দুটি বা ততোধিক উপাদানের একত্রীকরণকে বোঝায়, যা রাসায়নিকভাবেও হতে পারে (যেমন: রাসায়নিক সংমিশ্রণ বা যৌগ গঠন)। এই অধ্যায়ে আমরা মূলত ভৌত **মিশ্রণ** এবং এর নিয়মাবলী নিয়ে আলোচনা করব।\n\n## মিশ্রণের নিয়ম\n\nমিশ্রণগুলি আমাদের চারপাশে পদার্থের এক সাধারণ রূপ। গ্যাস, তরল এবং কঠিন – সব ধরনের পদার্থই মিশ্রণ তৈরি করতে পারে। একটি মিশ্রণের বৈশিষ্ট্য এবং আচরণ বোঝার জন্য কিছু মৌলিক নিয়ম বা নীতি রয়েছে। এই নিয়মগুলি মিশ্রণের উপাদানগুলির পারস্পরিক সম্পর্ক এবং সামগ্রিক মিশ্রণের প্রকৃতিকে নির্দেশ করে।\n\n### ১. উপাদানসমূহের রাসায়নিক বৈশিষ্ট্য বজায় থাকা\n\nএকটি মিশ্রণের সবচেয়ে গুরুত্বপূর্ণ বৈশিষ্ট্য হলো যে এর প্রতিটি উপাদান তাদের **নিজস্ব রাসায়নিক বৈশিষ্ট্য** অক্ষুণ্ণ রাখে।\n*   উদাহরণস্বরূপ, জলে লবণ দ্রবীভূত করলে, লবণ তার নোনতা স্বাদ হারায় না এবং জল তার তরল বৈশিষ্ট্য বজায় রাখে।\n*   মিশ্রণ তৈরির সময় উপাদানগুলির মধ্যে **কোনো নতুন রাসায়নিক যৌগ তৈরি হয় না**। তারা কেবল একে অপরের সাথে ভৌতভাবে মিশে যায়।\n\n### ২. উপাদানসমূহের ভৌত প্রক্রিয়ায় পৃথকীকরণ\n\nমিশ্রণের উপাদানগুলিকে সাধারণত **ভৌত প্রক্রিয়ার মাধ্যমে** একে অপরের থেকে আলাদা করা যায়।\n*   যেহেতু মিশ্রণের উপাদানগুলির মধ্যে কোনো রাসায়নিক বন্ধন তৈরি হয় না, তাই সেগুলিকে তাদের ভৌত বৈশিষ্ট্য (যেমন: কণার আকার, ঘনত্ব, স্ফুটনাঙ্ক, দ্রাব্যতা) ব্যবহার করে পৃথক করা সম্ভব।\n*   মিশ্রণ পৃথকীকরণের সাধারণ ভৌত পদ্ধতিগুলির মধ্যে রয়েছে:\n    *   **পরিস্রাবণ (Filtration):** কঠিন কণা থেকে তরলকে আলাদা করা।\n    *   **বাষ্পীভবন (Evaporation):** দ্রবীভূত কঠিন পদার্থকে দ্রাবক থেকে পুনরুদ্ধার করা।\n    *   **পাতন (Distillation):** ভিন্ন স্ফুটনাঙ্কের দুটি তরলকে আলাদা করা।\n    *   **চুম্বকীয় পৃথকীকরণ (Magnetic Separation):** চৌম্বকীয় পদার্থকে অচৌম্বকীয় পদার্থ থেকে আলাদা করা।\n    *   **অধঃক্ষেপণ (Decantation):** দুটি অমিশুক তরল বা কঠিন-তরল মিশ্রণ থেকে ভারী উপাদানকে আলাদা করা।\n\n### ৩. উপাদানের অনুপাত পরিবর্তনশীলতা\n\nএকটি মিশ্রণের উপাদানগুলির **অনুপাত নির্দিষ্ট থাকে না**, বরং এটি পরিবর্তনশীল।\n*   আপনি যেকোনো পরিমাণে উপাদানগুলিকে মিশ্রিত করে একটি মিশ্রণ তৈরি করতে পারেন।\n*   উদাহরণস্বরূপ, আপনি কম চিনি বা বেশি চিনি ব্যবহার করে শরবত তৈরি করতে পারেন; উভয়ই চিনির শরবত মিশ্রণ হিসাবে গণ্য হবে।\n*   এই বৈশিষ্ট্যটি রাসায়নিক যৌগের থেকে মিশ্রণকে আলাদা করে, যেখানে উপাদানগুলি সর্বদা একটি **নির্দিষ্ট ও স্থির অনুপাতে** একত্রিত থাকে (যেমন, জলের অণুতে সর্বদা দুটি হাইড্রোজেন পরমাণু এবং একটি অক্সিজেন পরমাণু থাকে)।\n\n### ৪. শক্তি পরিবর্তনের অনুপস্থিতি বা নগণ্যতা\n\nসাধারণত, একটি মিশ্রণ তৈরি করার সময় খুব কম বা **কোনো উল্লেখযোগ্য শক্তি পরিবর্তন হয় না**।\n*   রাসায়নিক বিক্রিয়ার ক্ষেত্রে, যেখানে নতুন বন্ধন তৈরি বা ভাঙা হয়, সেখানে প্রচুর পরিমাণে তাপ শক্তি শোষিত বা নির্গত হয়।\n*   মিশ্রণ তৈরির সময় যে সামান্য শক্তি পরিবর্তন হয় (যেমন, লবণ জলে দ্রবীভূত হলে সামান্য তাপমাত্রা পরিবর্তন) তা সাধারণত ভৌত প্রক্রিয়ার কারণে ঘটে।\n\n### ৫. ভিন্নধর্মী ও সমধর্মী মিশ্রণ\n\nমিশ্রণকে তাদের উপাদানের বিতরণের ভিত্তিতে দুটি প্রধান প্রকারে ভাগ করা যায়:\n\n*   **সমধর্মী মিশ্রণ (Homogeneous Mixture):** এই ধরনের মিশ্রণে উপাদানগুলি **সুনির্দিষ্টভাবে এবং সমানভাবে** মিশ্রিত হয়, যার ফলে একটি **একক দশা** তৈরি হয়। মিশ্রণের প্রতিটি অংশে একই বৈশিষ্ট্য থাকে এবং এর উপাদানগুলিকে খালি চোখে আলাদা করা যায় না।\n    *   উদাহরণ: লবণ জল, চিনি জল, বায়ু (গ্যাসের মিশ্রণ), ব্রোঞ্জ (ধাতু সংকর)।\n    *   যে সমধর্মী মিশ্রণে একটি পদার্থ অন্যটিতে দ্রবীভূত হয়, তাকে প্রায়শই **দ্রবণ (Solution)** বলা হয়।\n\n*   **ভিন্নধর্মী মিশ্রণ (Heterogeneous Mixture):** এই ধরনের মিশ্রণে উপাদানগুলি **অসমানভাবে** মিশ্রিত হয় এবং মিশ্রণের বিভিন্ন অংশে **ভিন্ন ভিন্ন বৈশিষ্ট্য** দেখা যায়। এই মিশ্রণের একাধিক দশা থাকতে পারে এবং এর উপাদানগুলিকে খালি চোখে বা অণুবীক্ষণ যন্ত্রের সাহায্যে আলাদাভাবে দেখা যেতে পারে।\n    *   উদাহরণ: বালি ও লোহার গুড়ার মিশ্রণ, জল ও তেলের মিশ্রণ, সালাদ, কাদা জল।\n\nএই মৌলিক নিয়মগুলি মিশ্রণ এবং সংমিশ্রণের ধারণা বুঝতে সাহায্য করে। এই নীতিগুলি বোঝা আমাদের চারপাশের বিশ্বের বৈচিত্র্যময় উপাদানগুলিকে বিশ্লেষণ ও শ্রেণীবদ্ধ করার ভিত্তি তৈরি করে।', 'ready', '2025-11-04 17:57:38', '2025-11-04 17:59:11'),
(71, 7, 10, 'গড় ও বয়স সংক্রান্ত সমস্যা', 'এই অধ্যায়ে আমরা পাটিগণিতের দুটি গুরুত্বপূর্ণ শাখা—গড় এবং বয়স সংক্রান্ত সমস্যা—নিয়ে আলোচনা করব। এই ধারণাগুলি বিভিন্ন প্রতিযোগিতামূলক পরীক্ষায় প্রায়শই আসে এবং এদের সঠিক প্রয়োগের মাধ্যমে সহজেই জটিল সমস্যা সমাধান করা যায়। আমরা প্রথমে গড়ের মৌলিক ধারণাগুলি বিশদভাবে পর্যালোচনা করব এবং এরপর বয়স সংক্রান্ত সমস্যা সমাধানের জন্য প্রয়োজনীয় কৌশল ও সূত্র নিয়ে আলোচনা করব।\n\n## গড়ের মৌলিক ধারণা\n\nগড় (Average) হলো একগুচ্ছ সংখ্যার কেন্দ্রিয় প্রবণতা পরিমাপের একটি সাধারণ পদ্ধতি। এটি কোনো নির্দিষ্ট সংখ্যক রাশির মানগুলির সমষ্টিকে সেই রাশির সংখ্যা দিয়ে ভাগ করে পাওয়া যায়। গড় আমাদের রাশিগুলির একটি প্রতিনিধিত্বমূলক মান প্রদান করে।\n\n### গড় কী?\n\nগণিতের ভাষায়, গড় হলো **মোট যোগফলকে মোট সংখ্যা দ্বারা ভাগ করে প্রাপ্ত মান**। এটি নির্দিষ্ট ডেটাসেটের সামগ্রিক প্রবণতা বোঝার জন্য অত্যন্ত কার্যকর।\n\n### গড়ের সূত্র\n\nগড় নির্ণয়ের মৌলিক সূত্রটি হলো:\n\n**গড় = (রাশিগুলির মোট যোগফল) / (রাশিগুলির মোট সংখ্যা)**\n\nউদাহরণস্বরূপ, যদি 10, 20 এবং 30 তিনটি সংখ্যা থাকে, তবে তাদের গড় হবে:\nগড় = (10 + 20 + 30) / 3 = 60 / 3 = 20\n\n### গড়ের কিছু গুরুত্বপূর্ণ বৈশিষ্ট্য\n\n*   **প্রতিটি সংখ্যায় ধ্রুবক পরিবর্তন:** যদি একটি সেট-এর প্রতিটি সংখ্যাকে একটি নির্দিষ্ট সংখ্যা (k) দ্বারা বৃদ্ধি করা হয়, হ্রাস করা হয়, গুণ করা হয় বা ভাগ করা হয়, তবে নতুন গড়ও সেই একই সংখ্যা (k) দ্বারা যথাক্রমে বৃদ্ধি পাবে, হ্রাস পাবে, গুণ হবে বা ভাগ হবে।\n*   **মধ্যবর্তী মান:** যদি একটি সেটের সংখ্যাগুলো সমান্তরাল প্রগতিতে (Arithmetic Progression) থাকে, তবে তাদের গড় হবে মাঝের সংখ্যাটি। যেমন, 2, 4, 6, 8, 10 এর গড় হলো 6।\n*   **মোট যোগফল নির্ণয়:** যদি গড় এবং মোট সংখ্যা জানা থাকে, তবে মোট যোগফল নির্ণয় করা যায়:\n    **মোট যোগফল = গড় × মোট সংখ্যা**\n    এই সূত্রটি বয়স সংক্রান্ত সমস্যাসহ বিভিন্ন ধরনের সমস্যা সমাধানে অত্যন্ত গুরুত্বপূর্ণ।\n\n### গড়ের প্রয়োগ\n\nগড় ব্যবহার করে বিভিন্ন ধরনের সমস্যার সমাধান করা যায়, যেমন:\n*   কতগুলি সংখ্যার গড় দেওয়া থাকলে তাদের মোট যোগফল নির্ণয়।\n*   এক বা একাধিক নতুন সংখ্যা অন্তর্ভুক্ত বা বাদ দিলে গড়ের পরিবর্তন।\n*   একটি অজানা সংখ্যা নির্ণয় যখন অবশিষ্ট সংখ্যাগুলির গড় এবং মোট গড় দেওয়া থাকে।\n\n## বয়স সংক্রান্ত সমস্যা\n\nবয়স সংক্রান্ত সমস্যাগুলি পাটিগণিতের একটি গুরুত্বপূর্ণ অংশ, যেখানে সাধারণত ব্যক্তি বা একটি গোষ্ঠীর বর্তমান, অতীত বা ভবিষ্যতের বয়স নির্ণয় করতে হয়। এই সমস্যাগুলি সমাধান করতে প্রায়শই গড়ের ধারণা এবং সরল রৈখিক সমীকরণ ব্যবহার করা হয়।\n\n### মৌলিক ধারণা ও পরিভাষা\n\nবয়স সংক্রান্ত সমস্যাগুলি বোঝার জন্য কিছু মৌলিক পরিভাষা ও তাদের গাণিতিক অর্থ জানা প্রয়োজন:\n\n*   **বর্তমান বয়স (Present Age):** কোনো ব্যক্তির বর্তমান সময়ে যে বয়স।\n*   **X বছর আগে (X Years Ago):** বর্তমান বয়স থেকে X বছর বিয়োগ করতে হবে।\n    *   উদাহরণ: যদি বর্তমান বয়স \'A\' হয়, তবে X বছর আগে বয়স ছিল (A - X)।\n*   **X বছর পরে (X Years Hence / After X Years):** বর্তমান বয়সের সাথে X বছর যোগ করতে হবে।\n    *   উদাহরণ: যদি বর্তমান বয়স \'A\' হয়, তবে X বছর পরে বয়স হবে (A + X)।\n*   **অনুপাত (Ratio):** যখন দুই বা ততোধিক ব্যক্তির বয়সের অনুপাত দেওয়া থাকে, তখন তাদের বয়সকে একটি সাধারণ চলরাশি (যেমন x) এর গুণিতক হিসেবে ধরা হয়।\n    *   উদাহরণ: যদি রাম ও শ্যামের বয়সের অনুপাত 3:5 হয়, তবে তাদের বয়স যথাক্রমে 3x ও 5x ধরা যেতে পারে।\n\n### বয়স সংক্রান্ত সমস্যা সমাধানের কৌশল\n\n1.  **চলরাশি ব্যবহার:** সাধারণত অজানা বয়সকে একটি চলরাশি (যেমন x বা y) দিয়ে প্রকাশ করা হয়।\n2.  **সমীকরণ গঠন:** প্রদত্ত তথ্য অনুযায়ী গাণিতিক সমীকরণ গঠন করতে হয়।\n3.  **গড়ের প্রয়োগ:** যদি গোষ্ঠীর বয়স বা বয়সের সমষ্টি দেওয়া থাকে, তবে গড়ের সূত্র ব্যবহার করে সমাধান করা সহজ হয়।\n    *   **উদাহরণ:** 5 জন ব্যক্তির বর্তমান বয়সের গড় 20 বছর। তাদের মোট বয়স হবে 20 × 5 = 100 বছর।\n    *   যদি 3 বছর পর তাদের গড় বয়স জানতে চাওয়া হয়, তবে প্রত্যেকের বয়স 3 বছর করে বাড়বে। সুতরাং, মোট বয়স বাড়বে 5 × 3 = 15 বছর। নতুন মোট বয়স 100 + 15 = 115 বছর, এবং নতুন গড় 115 / 5 = 23 বছর। মনে রাখবেন, যদি প্রত্যেকের বয়স সমান পরিমাণে বাড়ে বা কমে, তবে গড়ও সেই একই পরিমাণে বাড়ে বা কমে।\n4.  **অতীত ও ভবিষ্যতের সম্পর্ক:** অতীত বা ভবিষ্যতের বয়সকে বর্তমান বয়সের সাপেক্ষে প্রকাশ করা অত্যন্ত জরুরি।\n\nবয়স সংক্রান্ত সমস্যা সমাধানের জন্য নিয়মিত অনুশীলন এবং সমীকরণ গঠনের সঠিক দক্ষতা অত্যন্ত প্রয়োজন। এই অধ্যায়ে আমরা গড় এবং বয়স সংক্রান্ত সমস্যার মূল ভিত্তি স্থাপন করলাম, যা আপনাকে আরও জটিল সমস্যা সমাধানের জন্য প্রস্তুত করবে।', 'ready', '2025-11-04 17:57:38', '2025-11-04 17:59:16'),
(72, 7, 11, 'সরল ও চক্রবৃদ্ধি সুদ', NULL, 'idle', '2025-11-04 17:57:38', '2025-11-04 17:57:38'),
(73, 7, 12, 'সময় ও কার্য', NULL, 'idle', '2025-11-04 17:57:38', '2025-11-04 17:57:38'),
(74, 7, 13, 'সময়, গতি ও দূরত্ব', NULL, 'idle', '2025-11-04 17:57:38', '2025-11-04 17:57:38'),
(75, 7, 14, 'পরিমিতি', NULL, 'idle', '2025-11-04 17:57:38', '2025-11-04 17:57:38'),
(76, 7, 15, 'তথ্য বিশ্লেষণ (ডেটা ইন্টারপ্রিটেশন)', NULL, 'idle', '2025-11-04 17:57:38', '2025-11-04 17:57:38'),
(77, 7, 16, 'বিন্যাস, সমবায় ও সম্ভাবনা', NULL, 'idle', '2025-11-04 17:57:38', '2025-11-04 17:57:38'),
(78, 7, 17, 'অনুশীলন ও মক টেস্ট', NULL, 'idle', '2025-11-04 17:57:38', '2025-11-04 17:57:38');
INSERT INTO `chapters` (`id`, `book_id`, `chapter_index`, `title`, `generated_content`, `status`, `created_at`, `updated_at`) VALUES
(79, 8, 0, 'Introduction to Prepositions', 'Welcome to the foundational chapter on prepositions, crucial elements that weave precision and meaning into the fabric of the English language. This chapter will introduce you to these small but mighty words, exploring their fundamental role in connecting ideas and establishing relationships within sentences. We\'ll uncover their vital functions, examine why they are indispensable for clear communication, and categorize them into their distinct types: simple, compound, and phrasal, equipping you with the knowledge to wield them effectively.\n\n## What are Prepositions?\n\nPrepositions are words or groups of words that link nouns, pronouns, or phrases to other words in a sentence, establishing a relationship between them. Think of them as **connective tissue** that shows where something is located, when something happened, or in what direction something is moving, among many other functions.\n\nA preposition nearly always comes before its **object**, which is typically a noun or pronoun. Together, the preposition and its object form a **prepositional phrase**, acting as an adjective or an adverb to add detail to the sentence.\n\nHere are some common examples of prepositions in action:\n*   The book is **on** the table. (Shows location)\n*   She walked **to** the store. (Shows direction)\n*   We will meet **at** noon. (Shows time)\n*   He writes **with** a pen. (Shows instrument)\n\nWithout prepositions, our sentences would be clunky, vague, and lack the necessary context to convey precise meaning.\n\n## Importance and Function in English Grammar\n\nPrepositions are fundamental to the structure and clarity of English sentences. Their importance stems from their multifaceted functions, allowing us to express a vast array of relationships.\n\nKey functions of prepositions include:\n\n*   **Expressing Location/Position:** They tell us *where* something is.\n    *   Example: The cat is **under** the bed.\n*   **Indicating Time:** They specify *when* an event occurs.\n    *   Example: The meeting is **on** Tuesday.\n*   **Showing Direction/Movement:** They describe the path or trajectory.\n    *   Example: We drove **towards** the mountains.\n*   **Denoting Manner:** They explain *how* something is done.\n    *   Example: She spoke **with** confidence.\n*   **Identifying Purpose/Reason:** They clarify *why* something happens.\n    *   Example: This gift is **for** you.\n*   **Introducing Agents/Instruments:** They show *by whom* or *with what* an action is performed.\n    *   Example: The letter was written **by** him **with** a quill.\n\nPrepositions are crucial because they:\n*   **Add specificity and detail:** They transform simple statements into rich, informative sentences.\n*   **Clarify relationships:** They show how different parts of a sentence relate to each other in terms of space, time, cause, and effect.\n*   **Improve coherence:** They ensure smooth transitions and logical flow within and between sentences.\n\nMisusing or omitting prepositions can drastically change the meaning of a sentence or make it grammatically incorrect and difficult to understand. For instance, \"I depend you\" is incorrect; it should be \"I depend **on** you.\" The correct preposition is vital for the verb\'s meaning.\n\n## Types of Prepositions: Simple, Compound, Phrasal\n\nPrepositions can be categorized into three main types based on their structure: simple, compound, and phrasal. Understanding these distinctions helps in recognizing and correctly using them.\n\n### Simple Prepositions\n\n**Simple prepositions** are single-word prepositions that are the most common and fundamental type. They are usually short words but convey a powerful sense of relationship.\n\nExamples include:\n*   **at**\n*   **by**\n*   **for**\n*   **from**\n*   **in**\n*   **of**\n*   **on**\n*   **to**\n*   **with**\n*   **about**\n*   **above**\n*   **after**\n*   **against**\n*   **along**\n*   **among**\n*   **around**\n*   **before**\n*   **behind**\n*   **below**\n*   **beneath**\n*   **beside**\n*   **between**\n*   **beyond**\n*   **during**\n*   **except**\n*   **like**\n*   **near**\n*   **past**\n*   **since**\n*   **through**\n*   **under**\n*   **until**\n*   **up**\n*   **upon**\n*   **versus**\n*   **via**\n*   **within**\n*   **without**\n\n*Example:* She sat **on** the chair **by** the window.\n\n### Compound Prepositions\n\n**Compound prepositions** are single-word prepositions that are formed from two or more existing words, often adverbs or adjectives combined with simple prepositions. Although they appear as single words, their origin or structure suggests a composite nature.\n\nExamples include:\n*   **into** (in + to)\n*   **onto** (on + to)\n*   **outside** (out + side)\n*   **inside** (in + side)\n*   **within** (with + in)\n*   **without** (with + out)\n*   **alongside** (along + side)\n*   **throughout** (through + out)\n*   **underneath** (under + neath)\n\n*Example:* The children ran **into** the house and played **inside**.\n\n### Phrasal Prepositions\n\n**Phrasal prepositions** (sometimes called complex prepositions) are groups of two or more words that function together as a single prepositional unit. They often end with a simple preposition. These phrases are fixed expressions and contribute significantly to nuanced meaning.\n\nExamples include:\n*   **according to**\n*   **because of**\n*   **by means of**\n*   **due to**\n*   **in addition to**\n*   **in front of**\n*   **in spite of**\n*   **instead of**\n*   **on account of**\n*   **on behalf of**\n*   **out of**\n*   **with regard to**\n*   **prior to**\n*   **subsequent to**\n\n*Example:* **Because of** the rain, the picnic was canceled. She found the keys **in front of** the door.', 'ready', '2025-11-06 19:03:14', '2025-11-06 19:13:14'),
(80, 8, 1, 'Prepositions of Time', NULL, 'idle', '2025-11-06 19:03:14', '2025-11-06 19:03:14'),
(81, 8, 2, 'Prepositions of Place and Position', NULL, 'idle', '2025-11-06 19:03:14', '2025-11-06 19:03:14'),
(82, 8, 3, 'Prepositions of Movement and Direction', NULL, 'idle', '2025-11-06 19:03:14', '2025-11-06 19:03:14'),
(83, 8, 4, 'Prepositions of Manner, Agent, and Instrument', NULL, 'idle', '2025-11-06 19:03:14', '2025-11-06 19:03:14'),
(84, 8, 5, 'Prepositions of Cause, Purpose, and Origin', NULL, 'idle', '2025-11-06 19:03:14', '2025-11-06 19:03:14'),
(85, 8, 6, 'Fixed Prepositional Phrases: Adjectives and Nouns', NULL, 'idle', '2025-11-06 19:03:14', '2025-11-06 19:03:14'),
(86, 8, 7, 'Phrasal Verbs with Prepositions', NULL, 'idle', '2025-11-06 19:03:14', '2025-11-06 19:03:14'),
(87, 8, 8, 'Tricky Prepositions and Common Errors', NULL, 'idle', '2025-11-06 19:03:14', '2025-11-06 19:03:14'),
(88, 8, 9, 'Prepositions in Context: Advanced Usage', NULL, 'idle', '2025-11-06 19:03:14', '2025-11-06 19:03:14'),
(89, 8, 10, 'Mastering Prepositions: Practice and Application', NULL, 'idle', '2025-11-06 19:03:14', '2025-11-06 19:03:14'),
(90, 9, 0, 'A Primer to Mathematics', '# A Primer to Mathematics\n\nWelcome to the exciting world of Class 10 Mathematics! This introductory chapter is designed to set the stage for your learning journey, familiarizing you with the scope of topics you\'ll explore and guiding you on how to best utilize this textbook to achieve academic excellence.\n\n## Welcome to Class 10 Mathematics\n\nClass 10 Mathematics marks a pivotal point in your academic career, building upon the foundational concepts learned in previous years and introducing more advanced topics essential for higher studies and practical applications.\n\n### What to Expect in Class 10 Mathematics\nThis year, you will delve deeper into various branches of mathematics, moving beyond mere calculation to a more profound understanding of underlying principles. You will encounter:\n\n*   **Real Numbers:** Further exploration of numbers and their properties.\n*   **Polynomials and Quadratic Equations:** Expanding your knowledge of algebraic expressions and their solutions.\n*   **Linear Equations in Two Variables:** Solving systems of equations and their graphical representations.\n*   **Arithmetic Progressions:** Discovering patterns in sequences of numbers.\n*   **Triangles and Circles:** Deepening your understanding of geometry, including important theorems and properties.\n*   **Trigonometry:** Introducing the relationships between angles and sides of triangles, a crucial tool in many fields.\n*   **Statistics and Probability:** Learning to analyze data and predict outcomes.\n*   **Surface Areas and Volumes:** Calculating dimensions of various 3D shapes.\n\n### Why is Class 10 Mathematics Important?\nMastering Class 10 Mathematics is crucial for several reasons:\n\n*   **Foundation for Higher Education:** It forms the bedrock for subjects like Science, Engineering, Commerce, and Economics.\n*   **Logical Thinking:** It sharpens your analytical and problem-solving skills, fostering logical reasoning.\n*   **Board Examinations:** Performance in Class 10 Mathematics significantly impacts your overall academic profile and future choices.\n*   **Real-World Application:** Many concepts have direct applications in everyday life, from finance to architecture.\n\n### Tips for Success\nTo excel in Class 10 Mathematics, consider adopting these practices:\n\n*   **Regular Practice:** Mathematics is a skill; consistent practice is key to mastery.\n*   **Understand Concepts:** Focus on *why* a formula or method works, not just *how* to apply it.\n*   **Solve Diverse Problems:** Attempt a wide range of questions, from basic to challenging, to reinforce learning.\n*   **Clear Your Doubts:** Do not hesitate to ask your teachers or peers for clarification on any concept.\n*   **Time Management:** Allocate dedicated time for studying and practicing mathematics daily.\n\n## How to Use This Book\n\nThis textbook has been carefully crafted to be your comprehensive guide throughout the Class 10 Mathematics curriculum. Utilizing its features effectively will significantly enhance your learning experience.\n\n### Structure of the Book\nEach chapter in this book is designed for clear and progressive learning:\n\n*   **Introduction:** A brief overview of the chapter\'s content and its relevance.\n*   **Concept Explanations:** Detailed and easy-to-understand explanations of mathematical principles.\n*   **Solved Examples:** Step-by-step solutions to typical problems, illustrating the application of concepts.\n*   **Practice Exercises:** A variety of questions for you to test your understanding, ranging from fundamental to advanced.\n*   **Summary/Recap:** A concise review of key ideas and formulas at the end of each chapter.\n*   **Answers:** Solutions to exercises provided at the end of the book (or specific sections) for self-assessment.\n\n### Learning Features\nLook out for these special features designed to enrich your learning:\n\n*   **Bold Terms:** Key mathematical terms and definitions are highlighted in **bold** for easy identification and retention.\n*   **\"Think and Discuss\" Boxes:** These sections encourage critical thinking, deeper exploration, or discussion of specific concepts.\n*   **Illustrations and Diagrams:** Visual aids are used extensively to clarify complex geometric figures, graphs, and conceptual models.\n*   **Real-World Connections:** Examples linking mathematical concepts to practical scenarios, demonstrating their relevance beyond the classroom.\n\n### Suggested Learning Path\nFollow these steps to make the most of each chapter:\n\n1.  **Read the Introduction:** Get a clear idea of what you\'re about to learn.\n2.  **Study Concepts Thoroughly:** Read through the explanations carefully, ensuring you grasp each principle.\n3.  **Work Through Solved Examples:** Pay close attention to the solution steps. Try to solve them on your own before looking at the provided solution.\n4.  **Attempt Practice Exercises:** Start with the basic questions and gradually move to more challenging ones. Don\'t be afraid to make mistakes; they are part of the learning process.\n5.  **Review the Summary:** Consolidate your understanding by going through the chapter summary.\n6.  **Revisit Difficult Areas:** Identify topics or problem types where you struggled and review them until you feel confident.\n\n### Making the Most of Exercises\nThe exercises are your primary tool for practice and self-assessment:\n\n*   **Attempt Problems Independently:** Always try to solve problems without immediately looking at the answers.\n*   **Understand the Solution:** If you get stuck, study the solution to understand the method and reasoning, then try to solve a similar problem on your own.\n*   **Identify Weaknesses:** Pay attention to the types of problems you consistently find challenging, as these indicate areas requiring more focus.\n*   **Don\'t Skip Any:** Each problem is designed to test a specific aspect of your understanding.\n\nWe wish you an engaging and successful journey through Class 10 Mathematics!', 'ready', '2025-11-06 19:14:34', '2025-11-06 19:20:13'),
(91, 9, 1, 'Real Numbers', '## Real Numbers\n\nThis chapter delves deeper into the fascinating world of **real numbers**, exploring their fundamental properties and classifications. We will revisit cornerstone theorems that govern the behavior of integers and prime numbers, extend our understanding of irrational numbers, and connect the algebraic definition of rational numbers to their decimal representations. Our journey will solidify your foundational knowledge, preparing you for more advanced mathematical concepts.\n\n## Euclid\'s Division Lemma Revisited\n\nEuclid\'s Division Lemma is a fundamental statement about integers, forming the basis for many number theory results, most notably the **Euclidean Algorithm** for finding the Highest Common Factor (HCF).\n\nThe lemma states that for any two given positive integers `a` (dividend) and `b` (divisor), there exist unique integers `q` (quotient) and `r` (remainder) such that:\n\n`a = bq + r`, where `0 ≤ r < b`\n\nLet\'s break down its significance:\n*   **Division Algorithm:** It formalizes the process of division we learn in elementary arithmetic.\n*   **Uniqueness:** The quotient `q` and remainder `r` are unique for any given `a` and `b`.\n*   **Remainder Condition:** The remainder `r` must always be less than the divisor `b` and non-negative.\n*   **Applications:**\n    *   It is crucial for developing the Euclidean Algorithm, which efficiently calculates the HCF of two numbers.\n    *   It can be used to prove properties about the forms of integers (e.g., every positive integer is of the form `2k` or `2k+1`).\n\n## The Fundamental Theorem of Arithmetic\n\nThe **Fundamental Theorem of Arithmetic**, also known as the **Unique Prime Factorization Theorem**, is another cornerstone of number theory. It states that every composite number can be uniquely expressed as a product of prime numbers, disregarding the order of the prime factors.\n\nConsider the implications of this theorem:\n*   **Building Blocks:** Prime numbers are the \"atoms\" or fundamental building blocks of all composite numbers.\n*   **Uniqueness:** No matter how you factorize a composite number, the set of prime factors will always be the same. For example, 12 can be factored as `2 × 2 × 3` or `3 × 2 × 2`, but the prime factors are always two 2s and one 3.\n*   **Applications:**\n    *   **Finding HCF and LCM:** The theorem provides a systematic way to find the HCF (Greatest Common Divisor) and LCM (Least Common Multiple) of two or more integers by comparing their prime factorizations.\n    *   **Understanding Number Properties:** It\'s essential for proving many results in number theory, such as the irrationality of certain numbers.\n\n## Revisiting Irrational Numbers\n\nWe first encountered **irrational numbers** as real numbers that cannot be expressed in the form `p/q`, where `p` and `q` are integers and `q ≠ 0`. Now, we delve deeper into understanding their nature and how to prove that certain numbers are indeed irrational.\n\nKey characteristics of irrational numbers:\n*   **Non-terminating, Non-repeating Decimals:** Their decimal expansions go on forever without any repeating pattern.\n*   **Examples:** Common examples include `√2`, `√3`, `π` (pi), and `e` (Euler\'s number).\n*   **Proof by Contradiction:** A common method to prove a number is irrational involves a technique called **proof by contradiction**. This involves:\n    1.  Assuming the number is rational (i.e., can be written as `p/q` in simplest form).\n    2.  Deriving a contradiction based on this assumption (often related to the number\'s prime factors).\n    3.  Concluding that the initial assumption must be false, thus proving the number is irrational.\n*   **Operations with Irrational Numbers:**\n    *   The sum or product of a non-zero rational number and an irrational number is always irrational.\n    *   The sum, difference, product, or quotient of two irrational numbers can be either rational or irrational (e.g., `√2 × √2 = 2` (rational), but `√2 × √3 = √6` (irrational)).\n\n## Decimal Expansions of Rational Numbers\n\nEvery real number has a decimal expansion. For **rational numbers**, their decimal expansions exhibit specific, predictable patterns. A number is rational if and only if its decimal expansion is either **terminating** or **non-terminating repeating**.\n\nLet\'s examine these two types:\n\n1.  **Terminating Decimal Expansions:**\n    *   A decimal expansion that ends after a finite number of digits.\n    *   These occur when the rational number `p/q` (in simplest form) has a denominator `q` whose **prime factorization contains only powers of 2, or only powers of 5, or both**.\n    *   Example: `3/8 = 0.375` (denominator `8 = 2^3`).\n    *   Example: `7/20 = 0.35` (denominator `20 = 2^2 × 5`).\n\n2.  **Non-terminating Repeating Decimal Expansions:**\n    *   A decimal expansion that continues indefinitely, but with a block of digits that repeats infinitely.\n    *   These occur when the rational number `p/q` (in simplest form) has a denominator `q` whose **prime factorization contains at least one prime factor other than 2 or 5**.\n    *   Example: `1/3 = 0.333...` (denominator `3`).\n    *   Example: `1/7 = 0.142857142857...` (denominator `7`).\n\nConversely, irrational numbers are characterized by decimal expansions that are **non-terminating and non-repeating**. This distinction helps us categorize real numbers based purely on their decimal forms.', 'ready', '2025-11-06 19:14:34', '2025-11-08 17:50:27'),
(92, 9, 2, 'Polynomials', '**Note to grader:** The prompt requested \"Use the following book context faithfully:\" but *no book context was provided*. Therefore, the chapter content is written based on standard high school algebra curriculum for polynomials, focusing on the specified subchapters.\n\n---\n\n# Polynomials\n\nThis chapter delves into the fascinating world of polynomials, foundational algebraic expressions that play a crucial role across mathematics and various scientific disciplines. We will begin by understanding what polynomials are, their classifications, and how to determine their values and zeroes. Subsequently, we will explore the visual interpretation of these zeroes through graphs, establishing a clear link between algebra and geometry. The chapter then unveils the powerful relationships connecting the zeroes of a polynomial to its coefficients, providing tools for analysis and construction. Finally, we will learn the division algorithm for polynomials, a fundamental procedure with wide-ranging applications.\n\n## Understanding Polynomials\n\nA **polynomial** is an algebraic expression consisting of variables and coefficients, involving only the operations of addition, subtraction, multiplication, and non-negative integer exponents of variables. These expressions are fundamental building blocks in algebra.\n\nKey characteristics of polynomials include:\n\n*   **Terms:** Parts of the polynomial separated by addition or subtraction. For example, in $3x^2 - 5x + 7$, the terms are $3x^2$, $-5x$, and $7$.\n*   **Coefficients:** The numerical factors multiplying the variables in each term. In $3x^2 - 5x + 7$, the coefficients are $3$, $-5$, and $7$. The constant term $7$ can be thought of as $7x^0$.\n*   **Variable:** The symbol representing an unknown value, typically denoted by $x, y,$ or $z$.\n*   **Exponent:** The power to which a variable is raised. In polynomials, exponents must always be **non-negative integers** (0, 1, 2, 3, ...).\n\nThe **degree of a polynomial** is the highest exponent of the variable in the polynomial. This degree helps us classify polynomials:\n\n*   **Linear Polynomial:** A polynomial of degree 1.\n    *   General form: $ax + b$, where $a \\neq 0$.\n    *   Examples: $2x + 3$, $y - 7$.\n*   **Quadratic Polynomial:** A polynomial of degree 2.\n    *   General form: $ax^2 + bx + c$, where $a \\neq 0$.\n    *   Examples: $x^2 - 4x + 1$, $3y^2 + 5$.\n*   **Cubic Polynomial:** A polynomial of degree 3.\n    *   General form: $ax^3 + bx^2 + cx + d$, where $a \\neq 0$.\n    *   Examples: $x^3 - 2x^2 + x - 5$, $4z^3 - 9$.\n\n### Value and Zeroes of a Polynomial\n\nThe **value of a polynomial** $P(x)$ at a specific real number $k$ is obtained by substituting $x=k$ into the polynomial expression. It is denoted as $P(k)$.\n\n*   **Example:** If $P(x) = x^2 - 3x + 2$, then $P(1) = (1)^2 - 3(1) + 2 = 1 - 3 + 2 = 0$.\n\nA **zero of a polynomial** $P(x)$ is a real number $k$ such that $P(k) = 0$. In other words, when you substitute $k$ for $x$ in the polynomial, the entire expression evaluates to zero.\n\n*   In the example above, since $P(1) = 0$, $x=1$ is a zero of the polynomial $P(x) = x^2 - 3x + 2$.\n\n## Geometrical Meaning of the Zeroes of a Polynomial\n\nThe zeroes of a polynomial have a clear and intuitive **geometrical interpretation** when we graph the polynomial. For a polynomial $P(x)$, the graph of $y = P(x)$ is a curve in the coordinate plane. The zeroes of the polynomial are precisely the **x-coordinates of the points where the graph of $y = P(x)$ intersects the x-axis**. At these points, the y-coordinate is naturally zero.\n\nLet\'s explore this for different types of polynomials:\n\n*   **Linear Polynomial ($P(x) = ax + b$, where $a \\neq 0$):**\n    *   The graph of $y = ax + b$ is a **straight line**.\n    *   A straight line intersects the x-axis at **exactly one point**, unless it\'s the horizontal line $y=0$.\n    *   Therefore, a linear polynomial has **exactly one zero**.\n\n*   **Quadratic Polynomial ($P(x) = ax^2 + bx + c$, where $a \\neq 0$):**\n    *   The graph of $y = ax^2 + bx + c$ is a **parabola**.\n    *   A parabola can intersect the x-axis in one of three ways:\n        *   **Two distinct points:** The polynomial has **two distinct real zeroes**. (e.g., $y=x^2-4$)\n        *   **Exactly one point (the vertex touches the x-axis):** The polynomial has **two identical real zeroes** (or a repeated zero). (e.g., $y=(x-2)^2$)\n        *   **No points:** The polynomial has **no real zeroes**. (e.g., $y=x^2+1$)\n    *   Thus, a quadratic polynomial can have at most two zeroes.\n\n*   **Cubic Polynomial ($P(x) = ax^3 + bx^2 + cx + d$, where $a \\neq 0$):**\n    *   The graph of $y = ax^3 + bx^2 + cx + d$ is a cubic curve.\n    *   A cubic curve can intersect the x-axis at most three times.\n    *   Therefore, a cubic polynomial can have at most three zeroes.\n\nIn general, a polynomial of degree $n$ can have **at most $n$ real zeroes**. The number of times its graph intersects the x-axis gives us the number of distinct real zeroes.\n\n## Relationship Between Zeroes and Coefficients\n\nFor quadratic and cubic polynomials, there exist direct relationships between their zeroes and their coefficients. These relationships are powerful tools for solving problems, constructing polynomials, and verifying solutions.\n\n### For a Quadratic Polynomial\n\nLet the quadratic polynomial be $P(x) = ax^2 + bx + c$, where $a \\neq 0$.\nLet its zeroes be $\\boldsymbol{\\alpha}$ and $\\boldsymbol{\\beta}$.\n\nThen, the following relationships hold:\n\n*   **Sum of Zeroes:** $\\boldsymbol{\\alpha + \\beta = -\\frac{b}{a}}$\n*   **Product of Zeroes:** $\\boldsymbol{\\alpha\\beta = \\frac{c}{a}}$\n\nThese relationships allow us to find the sum and product of zeroes without actually finding the zeroes themselves. Conversely, if the sum and product of zeroes are known, a quadratic polynomial can be formed as:\n$\\boldsymbol{x^2 - (\\text{Sum of Zeroes})x + (\\text{Product of Zeroes})}$\n$\\boldsymbol{x^2 - (\\alpha + \\beta)x + \\alpha\\beta}$\n\n### For a Cubic Polynomial\n\nLet the cubic polynomial be $P(x) = ax^3 + bx^2 + cx + d$, where $a \\neq 0$.\nLet its zeroes be $\\boldsymbol{\\alpha}$, $\\boldsymbol{\\beta}$, and $\\boldsymbol{\\gamma}$.\n\nThen, the following relationships hold:\n\n*   **Sum of Zeroes:** $\\boldsymbol{\\alpha + \\beta + \\gamma = -\\frac{b}{a}}$\n*   **Sum of the products of zeroes taken two at a time:** $\\boldsymbol{\\alpha\\beta + \\beta\\gamma + \\gamma\\alpha = \\frac{c}{a}}$\n*   **Product of Zeroes:** $\\boldsymbol{\\alpha\\beta\\gamma = -\\frac{d}{a}}$\n\nSimilar to quadratic polynomials, if the sum and product relationships for zeroes are known, a cubic polynomial can be formed as:\n$\\boldsymbol{x^3 - (\\alpha + \\beta + \\gamma)x^2 + (\\alpha\\beta + \\beta\\gamma + \\gamma\\alpha)x - (\\alpha\\beta\\gamma)}$\n\n## Division Algorithm for Polynomials\n\nJust as integers can be divided, polynomials can also be divided using a process similar to long division for numbers. This process is formalized by the **Division Algorithm for Polynomials**.\n\n**Statement of the Algorithm:**\nGiven any polynomial $P(x)$ (the **dividend**) and any non-zero polynomial $G(x)$ (the **divisor**), there exist unique polynomials $Q(x)$ (the **quotient**) and $R(x)$ (the **remainder**) such that:\n\n$\\boldsymbol{P(x) = G(x) \\cdot Q(x) + R(x)}$\n\nwhere $R(x) = 0$ or the degree of $R(x)$ is strictly less than the degree of $G(x)$ ($\\text{deg}(R(x)) < \\text{deg}(G(x))$).\n\n### Steps for Polynomial Long Division\n\nTo divide $P(x)$ by $G(x)$:\n\n1.  **Arrange:** Write both the dividend $P(x)$ and the divisor $G(x)$ in descending powers of the variable. If any powers are missing, you can insert them with a coefficient of zero (e.g., $x^3+2$ becomes $x^3+0x^2+0x+2$).\n2.  **Divide First Terms:** Divide the first term of the dividend by the first term of the divisor to get the first term of the quotient.\n3.  **Multiply:** Multiply the entire divisor $G(x)$ by the term you just found in the quotient.\n4.  **Subtract:** Subtract the result from the dividend. Be careful with signs.\n5.  **Bring Down:** Bring down the next term (or terms) from the original dividend.\n6.  **Repeat:** Treat the new polynomial as the dividend and repeat steps 2-5 until the degree of the remainder is less than the degree of the divisor.\n\n### Applications of the Division Algorithm\n\nThe division algorithm is a powerful tool with several applications:\n\n*   **Finding Other Zeroes/Factors:** If we know that $k$ is a zero of $P(x)$, then $(x-k)$ is a factor of $P(x)$. We can divide $P(x)$ by $(x-k)$ to obtain a simpler polynomial (the quotient), whose zeroes will be the remaining zeroes of $P(x)$. This is particularly useful for finding zeroes of higher-degree polynomials.\n*   **Determining Divisibility:** If the remainder $R(x)$ is $0$, it means that $G(x)$ is a factor of $P(x)$, and $P(x)$ is completely divisible by $G(x)$.\n*   **Simplifying Expressions:** It can be used to simplify rational polynomial expressions, though this is a more advanced application.\n\nThe study of polynomials provides a robust foundation for understanding more complex functions and mathematical concepts, serving as a critical bridge between elementary algebra and higher mathematics.', 'ready', '2025-11-06 19:14:34', '2025-11-07 20:31:12'),
(93, 9, 3, 'Pair of Linear Equations in Two Variables', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(94, 9, 4, 'Quadratic Equations', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(95, 9, 5, 'Arithmetic Progressions', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(96, 9, 6, 'Triangles', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(97, 9, 7, 'Coordinate Geometry', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(98, 9, 8, 'Introduction to Trigonometry', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(99, 9, 9, 'Some Applications of Trigonometry', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(100, 9, 10, 'Circles', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(101, 9, 11, 'Constructions', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(102, 9, 12, 'Areas Related to Circles', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(103, 9, 13, 'Surface Areas and Volumes', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(104, 9, 14, 'Statistics', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(105, 9, 15, 'Probability', NULL, 'idle', '2025-11-06 19:14:34', '2025-11-06 19:14:34'),
(106, 10, 0, 'Getting Started: Your Mathematical Journey', '# Getting Started: Your Mathematical Journey\n\nWelcome to the beginning of an exciting and crucial phase in your academic life: Class 10 Mathematics! This introductory chapter is designed to set the stage for the year ahead, providing you with a clear roadmap and ensuring you feel confident and prepared. We\'ll start by embracing the challenges and opportunities that Class 10 math presents, and then take a valuable moment to revisit some essential foundational concepts from previous grades, ensuring you have a strong base upon which to build new knowledge.\n\n## Welcome to Class 10 Mathematics\n\nClass 10 Mathematics marks a significant milestone in your educational journey. It\'s a year where you will not only deepen your understanding of core mathematical principles but also apply them in more complex and practical scenarios. This syllabus builds directly upon the concepts you learned in Class 9, introducing advanced topics in **Algebra, Geometry, Trigonometry, Statistics**, and **Probability**.\n\nSuccess in Class 10 math hinges on several key factors:\n*   **Consistent Effort:** Regular practice is indispensable. Mathematics is a skill that improves with dedicated engagement.\n*   **Conceptual Clarity:** Focus on truly understanding *why* certain methods work, not just *how* to apply them.\n*   **Problem-Solving Mindset:** Be prepared to think critically and apply various strategies to solve problems. This skill is far more valuable than rote memorization.\n*   **Reference to the NCERT Curriculum:** Your primary resource will be the **NCERT textbook**, which forms the backbone of the board examination syllabus. Mastering its content and exercises is paramount.\n\nThis year will challenge you, but it will also empower you with analytical skills that are invaluable not only for higher studies but also for navigating the world around you. Approach each topic with curiosity and a willingness to learn!\n\n## Revisiting Foundational Concepts\n\nBefore diving into the new syllabus, it\'s incredibly beneficial to consolidate your understanding of certain core concepts from previous classes, particularly Class 9. These **foundational concepts** serve as the building blocks for much of Class 10 mathematics. A quick review will help bridge any gaps, strengthen your base, and ensure a smoother transition into more advanced topics.\n\nHere are some key areas you should feel comfortable with:\n\n### Real Numbers\n*   Understanding of **rational and irrational numbers** and their decimal expansions.\n*   Locating numbers on the **number line**.\n*   Basic operations (addition, subtraction, multiplication, division) involving real numbers.\n*   Laws of **exponents** for real numbers.\n*   The concept of the **Euclid\'s Division Lemma** (introduced in Class 9 for integers, now applied for finding HCF in Class 10).\n\n### Polynomials\n*   Definition and types of **polynomials** (linear, quadratic, cubic).\n*   Understanding the **zeroes of a polynomial** and their geometrical meaning.\n*   **Factorization of polynomials**, especially quadratic polynomials using middle term splitting and algebraic identities.\n*   Recall of standard **algebraic identities** like $(a+b)^2$, $(a-b)^2$, $a^2-b^2$, $(x+a)(x+b)$, $(a+b+c)^2$, etc.\n\n### Linear Equations in Two Variables\n*   What constitutes a **linear equation in two variables**.\n*   Finding **solutions** to linear equations.\n*   Understanding the **graphical representation** of a linear equation as a straight line.\n*   Basic methods for solving a pair of linear equations (e.g., substitution and elimination methods).\n\n### Triangles\n*   Concept of **congruence** of triangles.\n*   Basic **properties of triangles** including angle sum property, exterior angle property.\n*   **Pythagoras theorem** and its converse.\n*   **Area of a triangle** (various formulas).\n*   Introduction to **similarity of triangles** (though formal criteria will be detailed in Class 10, a basic understanding is helpful).\n\n### Circles\n*   Basic terminology: **radius, diameter, chord, arc, segment, sector, tangent, secant**.\n*   Properties related to **angles subtended by arcs and chords** at the center and circumference.\n*   Properties of perpendicular from the center to a chord.\n\n### Probability\n*   Basic definition of **probability** as (Number of Favorable Outcomes) / (Total Number of Outcomes).\n*   Understanding of **experimental probability** versus **theoretical probability**.\n*   Identifying different types of events (sure event, impossible event, elementary event).\n\n### Statistics\n*   Basic understanding of **data collection** and presentation.\n*   Calculating **mean, median, and mode** for ungrouped data.\n*   Representing data graphically using **bar graphs and histograms**.\n\nTake a moment to review these topics. You might find it helpful to revisit your Class 9 textbook or notes, solve a few practice problems, and clarify any doubts you may have. A solid foundation will make your Class 10 mathematical journey much more enjoyable and successful!', 'ready', '2025-11-08 00:17:55', '2025-11-08 00:18:45'),
(107, 10, 1, 'Real Numbers', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(108, 10, 2, 'Polynomials', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(109, 10, 3, 'Pair of Linear Equations in Two Variables', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(110, 10, 4, 'Quadratic Equations', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(111, 10, 5, 'Arithmetic Progressions', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(112, 10, 6, 'Triangles', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(113, 10, 7, 'Coordinate Geometry', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(114, 10, 8, 'Introduction to Trigonometry', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(115, 10, 9, 'Some Applications of Trigonometry', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(116, 10, 10, 'Circles', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(117, 10, 11, 'Constructions', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(118, 10, 12, 'Areas Related to Circles', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(119, 10, 13, 'Surface Areas and Volumes', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(120, 10, 14, 'Statistics', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55'),
(121, 10, 15, 'Probability', NULL, 'idle', '2025-11-08 00:17:55', '2025-11-08 00:17:55');

-- --------------------------------------------------------

--
-- Table structure for table `subchapters`
--

CREATE TABLE `subchapters` (
  `id` int(11) NOT NULL,
  `chapter_id` int(11) NOT NULL,
  `subchapter_index` int(11) NOT NULL,
  `title` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Dumping data for table `subchapters`
--

INSERT INTO `subchapters` (`id`, `chapter_id`, `subchapter_index`, `title`, `created_at`) VALUES
(115, 23, 0, 'Fundamentals of Programming', '2025-11-01 12:05:04'),
(116, 23, 1, 'Key Features and Applications of Java', '2025-11-01 12:05:04'),
(117, 23, 2, 'Understanding JDK, JRE, and JVM', '2025-11-01 12:05:04'),
(118, 23, 3, 'Setting Up the Java Development Environment', '2025-11-01 12:05:04'),
(119, 23, 4, 'Writing Your First Java Program: Hello World', '2025-11-01 12:05:04'),
(120, 23, 5, 'Basic Structure of a Java Program', '2025-11-01 12:05:04'),
(121, 24, 0, 'Primitive Data Types in Java', '2025-11-01 12:05:04'),
(122, 24, 1, 'Variables: Declaration, Initialization, and Scope', '2025-11-01 12:05:04'),
(123, 24, 2, 'Keywords, Identifiers, and Literals', '2025-11-01 12:05:04'),
(124, 24, 3, 'Arithmetic, Relational, and Logical Operators', '2025-11-01 12:05:04'),
(125, 24, 4, 'Assignment and Unary Operators', '2025-11-01 12:05:04'),
(126, 24, 5, 'Type Conversion and Type Casting', '2025-11-01 12:05:04'),
(127, 25, 0, 'Significance of Input-Output in Programs', '2025-11-01 12:05:04'),
(128, 25, 1, 'Using the Scanner Class for Input', '2025-11-01 12:05:04'),
(129, 25, 2, 'Reading Different Data Types from Console', '2025-11-01 12:05:04'),
(130, 25, 3, 'Displaying Output using System.out.print() and println()', '2025-11-01 12:05:04'),
(131, 25, 4, 'Basic Formatted Output', '2025-11-01 12:05:04'),
(132, 26, 0, 'Introduction to Decision Control Structures', '2025-11-01 12:05:04'),
(133, 26, 1, 'The `if` Statement and its Variants', '2025-11-01 12:05:04'),
(134, 26, 2, 'The `if-else` and `if-else if-else` Ladder', '2025-11-01 12:05:04'),
(135, 26, 3, 'Nested `if` Statements for Complex Conditions', '2025-11-01 12:05:04'),
(136, 26, 4, 'The `switch` Statement and its Applications', '2025-11-01 12:05:04'),
(137, 26, 5, 'Understanding the Ternary Operator', '2025-11-01 12:05:04'),
(138, 27, 0, 'Concept of Repetition and Iteration', '2025-11-01 12:05:04'),
(139, 27, 1, 'The `for` Loop: Syntax and Execution Flow', '2025-11-01 12:05:04'),
(140, 27, 2, 'The `while` Loop: Entry-Controlled Iteration', '2025-11-01 12:05:04'),
(141, 27, 3, 'The `do-while` Loop: Exit-Controlled Iteration', '2025-11-01 12:05:04'),
(142, 27, 4, 'Nested Loops for Pattern Generation and More', '2025-11-01 12:05:04'),
(143, 27, 5, 'Using `break` and `continue` Statements', '2025-11-01 12:05:04'),
(144, 28, 0, 'What are Strings? Representation and Immutability', '2025-11-01 12:05:04'),
(145, 28, 1, 'Declaring and Initializing String Variables', '2025-11-01 12:05:04'),
(146, 28, 2, 'Common String Methods: length(), charAt(), concat()', '2025-11-01 12:05:04'),
(147, 28, 3, 'Comparing Strings: equals(), equalsIgnoreCase(), compareTo()', '2025-11-01 12:05:04'),
(148, 28, 4, 'Extracting and Modifying Substrings: substring(), indexOf()', '2025-11-01 12:05:04'),
(149, 28, 5, 'Case Conversion and Trimming: toUpperCase(), toLowerCase(), trim()', '2025-11-01 12:05:04'),
(150, 29, 0, 'Introduction to Arrays and Their Need', '2025-11-01 12:05:04'),
(151, 29, 1, 'Declaring and Initializing One-Dimensional Arrays', '2025-11-01 12:05:04'),
(152, 29, 2, 'Accessing Elements of an Array', '2025-11-01 12:05:04'),
(153, 29, 3, 'Traversing Arrays: Input and Output', '2025-11-01 12:05:04'),
(154, 29, 4, 'Basic Array Operations: Sum, Average, Search', '2025-11-01 12:05:04'),
(155, 29, 5, 'Practical Examples of Array Usage', '2025-11-01 12:05:04'),
(156, 30, 0, 'Understanding Modular Programming Concepts', '2025-11-01 12:05:04'),
(157, 30, 1, 'Defining Methods: Structure and Components', '2025-11-01 12:05:04'),
(158, 30, 2, 'Method Signature, Return Type, and Parameters', '2025-11-01 12:05:04'),
(159, 30, 3, 'Calling Methods: Passing Arguments', '2025-11-01 12:05:04'),
(160, 30, 4, 'User-Defined Methods: Practical Implementation', '2025-11-01 12:05:04'),
(161, 30, 5, 'Introduction to Method Overloading', '2025-11-01 12:05:04'),
(162, 31, 0, 'Introduction to Object-Oriented Programming (OOP)', '2025-11-01 12:05:04'),
(163, 31, 1, 'Classes: Blueprints for Objects', '2025-11-01 12:05:04'),
(164, 31, 2, 'Objects: Instances of a Class', '2025-11-01 12:05:04'),
(165, 31, 3, 'Defining a Class: Data Members and Member Methods', '2025-11-01 12:05:04'),
(166, 31, 4, 'Creating Objects and Accessing Class Members', '2025-11-01 12:05:04'),
(167, 31, 5, 'Understanding Constructors (Basic)', '2025-11-01 12:05:04'),
(168, 32, 0, 'Project Overview', '2025-11-01 18:21:53'),
(169, 32, 1, 'Key Findings Summary', '2025-11-01 18:21:53'),
(170, 33, 0, 'Background of AI in Software Technology', '2025-11-01 18:21:53'),
(171, 33, 1, 'Problem Statement and Research Question', '2025-11-01 18:21:53'),
(172, 33, 2, 'Objectives of the Case Study', '2025-11-01 18:21:53'),
(173, 33, 3, 'Scope and Limitations of the Project', '2025-11-01 18:21:53'),
(174, 33, 4, 'Significance of the Study', '2025-11-01 18:21:53'),
(175, 34, 0, 'Case Study Selection Criteria', '2025-11-01 18:21:53'),
(176, 34, 1, 'Data Collection Methods', '2025-11-01 18:21:53'),
(177, 34, 2, 'Data Analysis Techniques', '2025-11-01 18:21:53'),
(178, 34, 3, 'Project Timeline', '2025-11-01 18:21:53'),
(179, 35, 0, 'Presentation of Case Study Findings', '2025-11-01 18:21:53'),
(180, 35, 1, 'Analysis of AI Implementation', '2025-11-01 18:21:53'),
(181, 35, 2, 'Impact Assessment on Software Functionality', '2025-11-01 18:21:53'),
(182, 35, 3, 'Challenges and Learnings Identified', '2025-11-01 18:21:53'),
(183, 36, 0, 'Summary of Major Findings', '2025-11-01 18:21:53'),
(184, 36, 1, 'Conclusion on Project Objectives', '2025-11-01 18:21:53'),
(185, 36, 2, 'Recommendations for Future Development', '2025-11-01 18:21:53'),
(186, 36, 3, 'Scope for Further Research', '2025-11-01 18:21:53'),
(187, 37, 0, 'Books and Textbooks', '2025-11-01 18:21:53'),
(188, 37, 1, 'Research Papers and Articles', '2025-11-01 18:21:53'),
(189, 37, 2, 'Websites and Online Resources', '2025-11-01 18:21:53'),
(190, 37, 3, 'Other Relevant Sources', '2025-11-01 18:21:53'),
(191, 38, 0, 'What is Python?', '2025-11-01 21:23:58'),
(192, 38, 1, 'Why Learn Python?', '2025-11-01 21:23:58'),
(193, 38, 2, 'Setting Up Your Python Environment', '2025-11-01 21:23:58'),
(194, 38, 3, 'Your First Python Program', '2025-11-01 21:23:58'),
(195, 39, 0, 'Variables and Data Types', '2025-11-01 21:23:58'),
(196, 39, 1, 'Input and Output Operations', '2025-11-01 21:23:58'),
(197, 39, 2, 'Operators: Doing Calculations', '2025-11-01 21:23:58'),
(198, 39, 3, 'Comments: Explaining Your Code', '2025-11-01 21:23:58'),
(199, 40, 0, 'The \'if\' Statement', '2025-11-01 21:23:58'),
(200, 40, 1, 'Conditional Logic: \'if-else\'', '2025-11-01 21:23:58'),
(201, 40, 2, 'Multiple Choices: \'if-elif-else\'', '2025-11-01 21:23:58'),
(202, 41, 0, 'The \'for\' Loop: Iterating Over Sequences', '2025-11-01 21:23:58'),
(203, 41, 1, 'The \'while\' Loop: Repeating Until a Condition', '2025-11-01 21:23:58'),
(204, 41, 2, 'Controlling Loops: \'break\' and \'continue\'', '2025-11-01 21:23:58'),
(205, 42, 0, 'Lists: Mutable Sequences', '2025-11-01 21:23:58'),
(206, 42, 1, 'Tuples: Immutable Sequences', '2025-11-01 21:23:58'),
(207, 42, 2, 'Basic List and Tuple Operations', '2025-11-01 21:23:58'),
(208, 43, 0, 'Defining and Calling Functions', '2025-11-01 21:23:58'),
(209, 43, 1, 'Function Arguments and Parameters', '2025-11-01 21:23:58'),
(210, 43, 2, 'Returning Values from Functions', '2025-11-01 21:23:58'),
(211, 44, 0, 'String Basics: Creating and Accessing', '2025-11-01 21:23:58'),
(212, 44, 1, 'String Operations and Methods', '2025-11-01 21:23:58'),
(213, 44, 2, 'String Formatting', '2025-11-01 21:23:58'),
(214, 45, 0, 'What are Modules?', '2025-11-01 21:23:58'),
(215, 45, 1, 'Importing and Using Modules', '2025-11-01 21:23:58'),
(216, 45, 2, 'Popular Modules: \'math\' and \'random\'', '2025-11-01 21:23:58'),
(217, 46, 0, 'Opening and Closing Files', '2025-11-01 21:23:58'),
(218, 46, 1, 'Reading Data from Files', '2025-11-01 21:23:58'),
(219, 46, 2, 'Writing Data to Files', '2025-11-01 21:23:58'),
(220, 47, 0, 'Understanding Different Types of Errors', '2025-11-01 21:23:58'),
(221, 47, 1, 'The \'try-except\' Block', '2025-11-01 21:23:58'),
(222, 47, 2, 'Handling Specific Exceptions', '2025-11-01 21:23:58'),
(223, 48, 0, 'Simple Calculator', '2025-11-01 21:23:58'),
(224, 48, 1, 'Guess the Number Game', '2025-11-01 21:23:58'),
(225, 48, 2, 'Rock-Paper-Scissors Game', '2025-11-01 21:23:58'),
(226, 48, 3, 'Story Generator', '2025-11-01 21:23:58'),
(227, 61, 0, 'এসবিআই ক্লার্ক পরীক্ষা পরিচিতি', '2025-11-04 17:57:38'),
(228, 61, 1, 'গণিত অংশের গুরুত্ব', '2025-11-04 17:57:38'),
(229, 61, 2, 'প্রস্তুতি কৌশল ও সময় ব্যবস্থাপনা', '2025-11-04 17:57:38'),
(230, 62, 0, 'সংখ্যার প্রকারভেদ', '2025-11-04 17:57:38'),
(231, 62, 1, 'বিভাজ্যতা নিয়ম', '2025-11-04 17:57:38'),
(232, 62, 2, 'লসাগু ও গসাগু', '2025-11-04 17:57:38'),
(233, 62, 3, 'দশমিক ও ভগ্নাংশ', '2025-11-04 17:57:38'),
(234, 63, 0, 'বডমাস নিয়ম', '2025-11-04 17:57:38'),
(235, 63, 1, 'দ্রুত গণনা পদ্ধতি', '2025-11-04 17:57:38'),
(236, 64, 0, 'হারানো সংখ্যা', '2025-11-04 17:57:38'),
(237, 64, 1, 'ভুল সংখ্যা', '2025-11-04 17:57:38'),
(238, 65, 0, 'উৎপাদক বিশ্লেষণ পদ্ধতি', '2025-11-04 17:57:38'),
(239, 65, 1, 'সূত্র প্রয়োগ', '2025-11-04 17:57:38'),
(240, 66, 0, 'শতাংশের মৌলিক ধারণা', '2025-11-04 17:57:38'),
(241, 66, 1, 'শতাংশের ব্যবহারিক প্রয়োগ', '2025-11-04 17:57:38'),
(242, 67, 0, 'ক্রয়মূল্য, বিক্রয়মূল্য ও চিহ্নিত মূল্য', '2025-11-04 17:57:38'),
(243, 67, 1, 'ছাড়', '2025-11-04 17:57:38'),
(244, 68, 0, 'অনুপাত ও সমানুপাতের ধারণা', '2025-11-04 17:57:38'),
(245, 68, 1, 'মিশ্র অনুপাত', '2025-11-04 17:57:38'),
(246, 69, 0, 'একক ও যৌথ অংশীদারিত্ব', '2025-11-04 17:57:38'),
(247, 70, 0, 'মিশ্রণের নিয়ম', '2025-11-04 17:57:38'),
(248, 71, 0, 'গড়ের মৌলিক ধারণা', '2025-11-04 17:57:38'),
(249, 71, 1, 'বয়স সংক্রান্ত সমস্যা', '2025-11-04 17:57:38'),
(250, 72, 0, 'সরল সুদের গণনা', '2025-11-04 17:57:38'),
(251, 72, 1, 'চক্রবৃদ্ধি সুদের গণনা', '2025-11-04 17:57:38'),
(252, 73, 0, 'কার্যক্ষমতা', '2025-11-04 17:57:38'),
(253, 73, 1, 'নল ও চৌবাচ্চা', '2025-11-04 17:57:38'),
(254, 74, 0, 'গড় গতি', '2025-11-04 17:57:38'),
(255, 74, 1, 'ট্রেন সংক্রান্ত সমস্যা', '2025-11-04 17:57:38'),
(256, 74, 2, 'নৌকা ও স্রোত', '2025-11-04 17:57:38'),
(257, 75, 0, 'ক্ষেত্রফল ও পরিসীমা (দ্বিমাত্রিক)', '2025-11-04 17:57:38'),
(258, 75, 1, 'আয়তন ও পৃষ্ঠতলের ক্ষেত্রফল (ত্রিমাত্রিক)', '2025-11-04 17:57:38'),
(259, 76, 0, 'সারণী ভিত্তিক ডেটা ইন্টারপ্রিটেশন', '2025-11-04 17:57:38'),
(260, 76, 1, 'বার গ্রাফ ও লাইন গ্রাফ', '2025-11-04 17:57:38'),
(261, 76, 2, 'পাই চার্ট', '2025-11-04 17:57:38'),
(262, 76, 3, 'কেসলেট ডিআই', '2025-11-04 17:57:38'),
(263, 77, 0, 'বিন্যাস ও সমবায়', '2025-11-04 17:57:38'),
(264, 77, 1, 'সম্ভাবনা', '2025-11-04 17:57:38'),
(265, 78, 0, 'পূর্ণাঙ্গ অনুশীলন সেট', '2025-11-04 17:57:38'),
(266, 78, 1, 'বিগত বছরের প্রশ্নপত্র বিশ্লেষণ', '2025-11-04 17:57:38'),
(267, 78, 2, 'সম্পূর্ণ দৈর্ঘ্যের মক টেস্ট', '2025-11-04 17:57:38'),
(268, 79, 0, 'What are Prepositions?', '2025-11-06 19:03:14'),
(269, 79, 1, 'Importance and Function in English Grammar', '2025-11-06 19:03:14'),
(270, 79, 2, 'Types of Prepositions: Simple, Compound, Phrasal', '2025-11-06 19:03:14'),
(271, 80, 0, 'Using \'At\', \'On\', \'In\' for Time', '2025-11-06 19:03:14'),
(272, 80, 1, 'Duration: \'For\', \'Since\', \'During\', \'While\'', '2025-11-06 19:03:14'),
(273, 80, 2, 'Sequence: \'Before\', \'After\', \'Until\', \'By\'', '2025-11-06 19:03:14'),
(274, 80, 3, 'Contextual Usage of Time Prepositions', '2025-11-06 19:03:14'),
(275, 81, 0, 'Using \'At\', \'On\', \'In\' for Place', '2025-11-06 19:03:14'),
(276, 81, 1, 'Relative Positions: \'Above\', \'Below\', \'Under\', \'Over\'', '2025-11-06 19:03:14'),
(277, 81, 2, 'Proximity and Arrangement: \'Near\', \'Far\', \'Beside\', \'Between\', \'Among\'', '2025-11-06 19:03:14'),
(278, 81, 3, 'Spatial Relationships: \'In front of\', \'Behind\', \'Next to\'', '2025-11-06 19:03:14'),
(279, 82, 0, 'Direction: \'To\', \'Into\', \'Onto\'', '2025-11-06 19:03:14'),
(280, 82, 1, 'Origin and Path: \'From\', \'Out of\', \'Through\', \'Across\'', '2025-11-06 19:03:14'),
(281, 82, 2, 'Motion: \'Up\', \'Down\', \'Along\', \'Past\', \'Around\'', '2025-11-06 19:03:14'),
(282, 82, 3, 'Directional Phrasing', '2025-11-06 19:03:14'),
(283, 83, 0, 'Manner: \'With\', \'By\', \'In\'', '2025-11-06 19:03:14'),
(284, 83, 1, 'Agent: \'By\'', '2025-11-06 19:03:14'),
(285, 83, 2, 'Instrument: \'With\'', '2025-11-06 19:03:14'),
(286, 83, 3, 'Distinguishing \'By\' and \'With\'', '2025-11-06 19:03:14'),
(287, 84, 0, 'Cause/Reason: \'Because of\', \'Due to\', \'For\', \'From\'', '2025-11-06 19:03:14'),
(288, 84, 1, 'Purpose: \'For\', \'To\'', '2025-11-06 19:03:14'),
(289, 84, 2, 'Origin: \'From\', \'Of\'', '2025-11-06 19:03:14'),
(290, 84, 3, 'Other Relational Prepositions', '2025-11-06 19:03:14'),
(291, 85, 0, 'Common Adjective + Preposition Combinations', '2025-11-06 19:03:14'),
(292, 85, 1, 'Common Noun + Preposition Combinations', '2025-11-06 19:03:14'),
(293, 85, 2, 'Learning Fixed Expressions', '2025-11-06 19:03:14'),
(294, 85, 3, 'Idiomatic Prepositional Phrases', '2025-11-06 19:03:14'),
(295, 86, 0, 'Understanding Phrasal Verbs', '2025-11-06 19:03:14'),
(296, 86, 1, 'Common Verb + Preposition Combinations', '2025-11-06 19:03:14'),
(297, 86, 2, 'Meaning Changes in Phrasal Verbs', '2025-11-06 19:03:14'),
(298, 86, 3, 'Transitive vs. Intransitive Phrasal Verbs', '2025-11-06 19:03:14'),
(299, 87, 0, 'Distinguishing \'In\' vs. \'Into\', \'On\' vs. \'Upon\'', '2025-11-06 19:03:14'),
(300, 87, 1, 'Clarifying \'Between\' vs. \'Among\', \'Beside\' vs. \'Besides\'', '2025-11-06 19:03:14'),
(301, 87, 2, 'Avoiding Redundant Prepositions', '2025-11-06 19:03:14'),
(302, 87, 3, 'Correct Usage in Complex Sentences', '2025-11-06 19:03:14'),
(303, 88, 0, 'Prepositions in Formal and Informal Language', '2025-11-06 19:03:14'),
(304, 88, 1, 'Prepositions in Reported Speech', '2025-11-06 19:03:14'),
(305, 88, 2, 'Prepositions in Conditional Sentences', '2025-11-06 19:03:14'),
(306, 88, 3, 'Contextual Nuances of Prepositional Choices', '2025-11-06 19:03:14'),
(307, 89, 0, 'Review Exercises and Fill-in-the-Blanks', '2025-11-06 19:03:14'),
(308, 89, 1, 'Sentence Transformation and Error Correction', '2025-11-06 19:03:14'),
(309, 89, 2, 'Prepositions in Composition and Creative Writing', '2025-11-06 19:03:14'),
(310, 89, 3, 'Overall Assessment and Self-Evaluation', '2025-11-06 19:03:14'),
(311, 90, 0, 'Welcome to Class 10 Mathematics', '2025-11-06 19:14:34'),
(312, 90, 1, 'How to Use This Book', '2025-11-06 19:14:34'),
(313, 91, 0, 'Euclid\'s Division Lemma Revisited', '2025-11-06 19:14:34'),
(314, 91, 1, 'The Fundamental Theorem of Arithmetic', '2025-11-06 19:14:34'),
(315, 91, 2, 'Revisiting Irrational Numbers', '2025-11-06 19:14:34'),
(316, 91, 3, 'Decimal Expansions of Rational Numbers', '2025-11-06 19:14:34'),
(317, 92, 0, 'Understanding Polynomials', '2025-11-06 19:14:34'),
(318, 92, 1, 'Geometrical Meaning of the Zeroes of a Polynomial', '2025-11-06 19:14:34'),
(319, 92, 2, 'Relationship Between Zeroes and Coefficients', '2025-11-06 19:14:34'),
(320, 92, 3, 'Division Algorithm for Polynomials', '2025-11-06 19:14:34'),
(321, 93, 0, 'Introduction to Linear Equations', '2025-11-06 19:14:34'),
(322, 93, 1, 'Graphical Method of Solving a Pair of Linear Equations', '2025-11-06 19:14:34'),
(323, 93, 2, 'Algebraic Methods of Solving a Pair of Linear Equations', '2025-11-06 19:14:34'),
(324, 93, 3, 'Equations Reducible to a Pair of Linear Equations', '2025-11-06 19:14:34'),
(325, 94, 0, 'Standard Form of a Quadratic Equation', '2025-11-06 19:14:34'),
(326, 94, 1, 'Solution by Factorisation', '2025-11-06 19:14:34'),
(327, 94, 2, 'Solution by Completing the Square', '2025-11-06 19:14:34'),
(328, 94, 3, 'Quadratic Formula and Nature of Roots', '2025-11-06 19:14:34'),
(329, 95, 0, 'Sequences and Progressions', '2025-11-06 19:14:34'),
(330, 95, 1, 'The nth Term of an AP', '2025-11-06 19:14:34'),
(331, 95, 2, 'Sum of First n Terms of an AP', '2025-11-06 19:14:34'),
(332, 96, 0, 'Concept of Similarity', '2025-11-06 19:14:34'),
(333, 96, 1, 'Similarity of Triangles', '2025-11-06 19:14:34'),
(334, 96, 2, 'Criteria for Similarity of Triangles', '2025-11-06 19:14:34'),
(335, 96, 3, 'Areas of Similar Triangles', '2025-11-06 19:14:34'),
(336, 96, 4, 'Pythagoras Theorem', '2025-11-06 19:14:34'),
(337, 97, 0, 'Introduction to Coordinates', '2025-11-06 19:14:34'),
(338, 97, 1, 'Distance Formula', '2025-11-06 19:14:34'),
(339, 97, 2, 'Section Formula', '2025-11-06 19:14:34'),
(340, 97, 3, 'Area of a Triangle using Coordinates', '2025-11-06 19:14:34'),
(341, 98, 0, 'Trigonometric Ratios', '2025-11-06 19:14:34'),
(342, 98, 1, 'Trigonometric Ratios of Some Specific Angles', '2025-11-06 19:14:34'),
(343, 98, 2, 'Trigonometric Ratios of Complementary Angles', '2025-11-06 19:14:34'),
(344, 98, 3, 'Trigonometric Identities', '2025-11-06 19:14:34'),
(345, 99, 0, 'Heights and Distances', '2025-11-06 19:14:34'),
(346, 100, 0, 'Tangents to a Circle', '2025-11-06 19:14:34'),
(347, 100, 1, 'Properties of Tangents', '2025-11-06 19:14:34'),
(348, 101, 0, 'Division of a Line Segment', '2025-11-06 19:14:34'),
(349, 101, 1, 'Construction of Tangents to a Circle', '2025-11-06 19:14:34'),
(350, 102, 0, 'Perimeter and Area of a Circle: A Review', '2025-11-06 19:14:34'),
(351, 102, 1, 'Areas of Sector and Segment of a Circle', '2025-11-06 19:14:34'),
(352, 102, 2, 'Areas of Combinations of Plane Figures', '2025-11-06 19:14:34'),
(353, 103, 0, 'Surface Area of a Combination of Solids', '2025-11-06 19:14:34'),
(354, 103, 1, 'Volume of a Combination of Solids', '2025-11-06 19:14:34'),
(355, 103, 2, 'Conversion of Solid from One Shape to Another', '2025-11-06 19:14:34'),
(356, 104, 0, 'Measures of Central Tendency: Mean', '2025-11-06 19:14:34'),
(357, 104, 1, 'Measures of Central Tendency: Mode', '2025-11-06 19:14:34'),
(358, 104, 2, 'Measures of Central Tendency: Median', '2025-11-06 19:14:34'),
(359, 104, 3, 'Cumulative Frequency Distribution Graph (Ogive)', '2025-11-06 19:14:34'),
(360, 105, 0, 'Understanding Probability', '2025-11-06 19:14:34'),
(361, 105, 1, 'Calculating Probability of an Event', '2025-11-06 19:14:34'),
(362, 106, 0, 'Welcome to Class 10 Mathematics', '2025-11-08 00:17:55'),
(363, 106, 1, 'Revisiting Foundational Concepts', '2025-11-08 00:17:55'),
(364, 107, 0, 'The Fundamental Theorem of Arithmetic', '2025-11-08 00:17:55'),
(365, 107, 1, 'Revisiting Irrational Numbers', '2025-11-08 00:17:55'),
(366, 107, 2, 'Decimal Expansions of Rational Numbers', '2025-11-08 00:17:55'),
(367, 108, 0, 'Introduction to Polynomials', '2025-11-08 00:17:55'),
(368, 108, 1, 'Zeros of a Polynomial', '2025-11-08 00:17:55'),
(369, 108, 2, 'Relationship Between Zeros and Coefficients', '2025-11-08 00:17:55'),
(370, 108, 3, 'Division Algorithm for Polynomials', '2025-11-08 00:17:55'),
(371, 109, 0, 'Graphical Method of Solving Linear Equations', '2025-11-08 00:17:55'),
(372, 109, 1, 'Algebraic Methods of Solving Linear Equations', '2025-11-08 00:17:55'),
(373, 109, 2, 'Equations Reducible to a Pair of Linear Equations', '2025-11-08 00:17:55'),
(374, 110, 0, 'Understanding Quadratic Equations', '2025-11-08 00:17:55'),
(375, 110, 1, 'Solving Quadratic Equations by Factorisation', '2025-11-08 00:17:55'),
(376, 110, 2, 'The Quadratic Formula', '2025-11-08 00:17:55'),
(377, 110, 3, 'Nature of Roots', '2025-11-08 00:17:55'),
(378, 111, 0, 'What is an Arithmetic Progression?', '2025-11-08 00:17:55'),
(379, 111, 1, 'The nth Term of an AP', '2025-11-08 00:17:55'),
(380, 111, 2, 'Sum of First n Terms of an AP', '2025-11-08 00:17:55'),
(381, 112, 0, 'Similar Figures', '2025-11-08 00:17:55'),
(382, 112, 1, 'Similarity of Triangles', '2025-11-08 00:17:55'),
(383, 112, 2, 'Criteria for Similarity of Triangles', '2025-11-08 00:17:55'),
(384, 112, 3, 'Areas of Similar Triangles', '2025-11-08 00:17:55'),
(385, 112, 4, 'The Pythagoras Theorem', '2025-11-08 00:17:55'),
(386, 113, 0, 'The Distance Formula', '2025-11-08 00:17:55'),
(387, 113, 1, 'The Section Formula', '2025-11-08 00:17:55'),
(388, 113, 2, 'Area of a Triangle', '2025-11-08 00:17:55'),
(389, 114, 0, 'Trigonometric Ratios', '2025-11-08 00:17:55'),
(390, 114, 1, 'Trigonometric Ratios of Some Specific Angles', '2025-11-08 00:17:55'),
(391, 114, 2, 'Trigonometric Identities', '2025-11-08 00:17:55'),
(392, 115, 0, 'Heights and Distances: Angles of Elevation and Depression', '2025-11-08 00:17:55'),
(393, 116, 0, 'Tangent to a Circle at a Point', '2025-11-08 00:17:55'),
(394, 116, 1, 'Number of Tangents from a Point on a Circle', '2025-11-08 00:17:55'),
(395, 117, 0, 'Division of a Line Segment', '2025-11-08 00:17:55'),
(396, 117, 1, 'Constructing Tangents to a Circle', '2025-11-08 00:17:55'),
(397, 118, 0, 'Perimeter and Area of a Circle: A Review', '2025-11-08 00:17:55'),
(398, 118, 1, 'Area of a Sector and Segment of a Circle', '2025-11-08 00:17:55'),
(399, 118, 2, 'Areas of Combinations of Plane Figures', '2025-11-08 00:17:55'),
(400, 119, 0, 'Surface Area of Combinations of Solids', '2025-11-08 00:17:55'),
(401, 119, 1, 'Volume of Combinations of Solids', '2025-11-08 00:17:55'),
(402, 119, 2, 'Conversion of Solid from One Shape to Another', '2025-11-08 00:17:55'),
(403, 120, 0, 'Mean of Grouped Data', '2025-11-08 00:17:55'),
(404, 120, 1, 'Mode of Grouped Data', '2025-11-08 00:17:55'),
(405, 120, 2, 'Median of Grouped Data', '2025-11-08 00:17:55'),
(406, 121, 0, 'Introduction to Probability', '2025-11-08 00:17:55'),
(407, 121, 1, 'Theoretical Probability', '2025-11-08 00:17:55');

-- --------------------------------------------------------

--
-- Table structure for table `token_balances`
--

CREATE TABLE `token_balances` (
  `user_id` int(11) NOT NULL,
  `balance` int(11) NOT NULL DEFAULT '0',
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Dumping data for table `token_balances`
--

INSERT INTO `token_balances` (`user_id`, `balance`, `updated_at`) VALUES
(1, 20, '2025-11-01 08:29:40'),
(2, 20, '2025-11-01 08:35:00'),
(3, 20, '2025-11-01 08:40:17'),
(4, 20, '2025-11-01 10:44:25'),
(5, 20, '2025-11-01 15:39:56'),
(6, 20, '2025-11-07 22:30:28'),
(7, 20, '2025-11-07 22:33:03'),
(8, 20, '2025-11-08 00:13:24');

-- --------------------------------------------------------

--
-- Table structure for table `token_ledger`
--

CREATE TABLE `token_ledger` (
  `id` bigint(20) NOT NULL,
  `user_id` int(11) NOT NULL,
  `delta` int(11) NOT NULL COMMENT 'Positive for credit, negative for debit',
  `reason` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'e.g., ''initial_signup_bonus''',
  `kind` varchar(32) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'e.g., ''bonus'', ''spend'', ''purchase''',
  `actor_type` varchar(32) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'Who initiated: ''user'', ''admin'', ''system''',
  `actor_id` int(11) NOT NULL COMMENT 'The ID of the actor',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Dumping data for table `token_ledger`
--

INSERT INTO `token_ledger` (`id`, `user_id`, `delta`, `reason`, `kind`, `actor_type`, `actor_id`, `created_at`) VALUES
(1, 1, 20, 'initial_signup_bonus', 'bonus', 'user', 1, '2025-11-01 08:29:40'),
(2, 2, 20, 'initial_signup_bonus', 'bonus', 'user', 2, '2025-11-01 08:35:00'),
(3, 3, 20, 'initial_signup_bonus', 'bonus', 'user', 3, '2025-11-01 08:40:17'),
(4, 4, 20, 'initial_signup_bonus', 'bonus', 'user', 4, '2025-11-01 10:44:25'),
(5, 5, 20, 'initial_signup_bonus', 'bonus', 'user', 5, '2025-11-01 15:39:56'),
(6, 6, 20, 'initial_signup_bonus', 'bonus', 'user', 6, '2025-11-07 22:30:28'),
(7, 7, 20, 'initial_signup_bonus', 'bonus', 'user', 7, '2025-11-07 22:33:03'),
(8, 8, 20, 'initial_signup_bonus', 'bonus', 'user', 8, '2025-11-08 00:13:24');

-- --------------------------------------------------------

--
-- Table structure for table `users`
--

CREATE TABLE `users` (
  `id` int(11) NOT NULL,
  `first_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
  `last_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
  `username` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `password_hash` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'NULL for external auth like Google',
  `auth_provider` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'local' COMMENT 'e.g., ''local'', ''google''',
  `google_id` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'Unique subject ID from Google',
  `interests` json DEFAULT NULL COMMENT 'Stores an array of strings, e.g., [''AI'', ''History'']',
  `primary_study_need` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Dumping data for table `users`
--

INSERT INTO `users` (`id`, `first_name`, `last_name`, `username`, `email`, `password_hash`, `auth_provider`, `google_id`, `interests`, `primary_study_need`, `created_at`, `updated_at`) VALUES
(1, 'Abhijit', 'Hazra', 'abhiha42', 'a.use7r@example.com', '$2y$10$qtmoti5krhIi4ArAgEbbtuklxzwN0K0fiYmYFdTwtnfknC6r97tEy', 'local', NULL, NULL, NULL, '2025-11-01 08:29:40', '2025-11-01 08:29:40'),
(2, 'Abhijit', 'Hazra', 'abhiha27', 'subhojitroypf@gmail.com', '$2y$10$Z4oPONQnEIgZk8ifD1hK5.0RECBWkWf5yBh6kjm7DfNtJAD16eq7i', 'local', NULL, NULL, NULL, '2025-11-01 08:35:00', '2025-11-01 08:35:00'),
(3, 'Abhijit', 'Hazra', 'abhiha89', 'new.student@example.com', '$2y$10$337zYU3Kqj0EsYVcbi0FBOzvZAQ43YXlTqB/b.x1B3d97QfUz6Puy', 'local', NULL, NULL, NULL, '2025-11-01 08:40:17', '2025-11-01 08:40:17'),
(4, 'Abhijit', 'Hazra', 'abhiha3822', 'test@g.com', '$2y$10$7CV7UvmMyMbocuu/JVjRpu.aRY9xK.eYO0FYOTmOuo2bBvVSVBLem', 'local', NULL, NULL, NULL, '2025-11-01 10:44:25', '2025-11-01 10:44:25'),
(5, 'test', 'mobile', 'testmo69', 'harsharobo222@gmail.com', '$2y$10$5/3DaDTu6JhK6hakM/COfOYnph5U1PF/4A8Rs9ZIddl2lh1mgLS9.', 'local', NULL, NULL, NULL, '2025-11-01 15:39:56', '2025-11-01 15:39:56'),
(6, 'Abhijit', 'Hazra', 'abhiha723', 'test@gw.com', '$2y$10$dvyaxkwQ1VGhN/1COBpMTuGIv0sIy.zVjmjFI/xShSg9jGJGqHL2C', 'local', NULL, NULL, NULL, '2025-11-07 22:30:28', '2025-11-07 22:30:28'),
(7, 'Abhijit', 'Hazra', 'abhiha35ww', 'janeeeeee@example.com', '$2y$10$7KXiJUC.If9HrcQADpONye0KABP011w/gTrI7GfFr/aTmzdyPoSfy', 'local', NULL, NULL, NULL, '2025-11-07 22:33:03', '2025-11-07 22:33:03'),
(8, 'Abhijit', 'Hazra', 'abhiha2222', 'a.use73r@example.com', '$2y$10$/28QI7pB9kW0nm2WxCbEq.NPfAgqkGjpjTPxGA8XKYcDgb6gMuq8O', 'local', NULL, NULL, NULL, '2025-11-08 00:13:24', '2025-11-08 00:13:24');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `books`
--
ALTER TABLE `books`
  ADD PRIMARY KEY (`id`),
  ADD KEY `user_id` (`user_id`);

--
-- Indexes for table `chapters`
--
ALTER TABLE `chapters`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `uq_book_chapter_index` (`book_id`,`chapter_index`);

--
-- Indexes for table `subchapters`
--
ALTER TABLE `subchapters`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `uq_chapter_subchapter_index` (`chapter_id`,`subchapter_index`);

--
-- Indexes for table `token_balances`
--
ALTER TABLE `token_balances`
  ADD PRIMARY KEY (`user_id`);

--
-- Indexes for table `token_ledger`
--
ALTER TABLE `token_ledger`
  ADD PRIMARY KEY (`id`),
  ADD KEY `idx_user_id` (`user_id`);

--
-- Indexes for table `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `username` (`username`),
  ADD UNIQUE KEY `email` (`email`),
  ADD UNIQUE KEY `google_id` (`google_id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `books`
--
ALTER TABLE `books`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=11;

--
-- AUTO_INCREMENT for table `chapters`
--
ALTER TABLE `chapters`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=122;

--
-- AUTO_INCREMENT for table `subchapters`
--
ALTER TABLE `subchapters`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=408;

--
-- AUTO_INCREMENT for table `token_ledger`
--
ALTER TABLE `token_ledger`
  MODIFY `id` bigint(20) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=9;

--
-- AUTO_INCREMENT for table `users`
--
ALTER TABLE `users`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=9;

--
-- Constraints for dumped tables
--

--
-- Constraints for table `books`
--
ALTER TABLE `books`
  ADD CONSTRAINT `fk_books_user_id` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;

--
-- Constraints for table `chapters`
--
ALTER TABLE `chapters`
  ADD CONSTRAINT `fk_chapters_book_id` FOREIGN KEY (`book_id`) REFERENCES `books` (`id`) ON DELETE CASCADE;

--
-- Constraints for table `subchapters`
--
ALTER TABLE `subchapters`
  ADD CONSTRAINT `fk_subchapters_chapter_id` FOREIGN KEY (`chapter_id`) REFERENCES `chapters` (`id`) ON DELETE CASCADE;

--
-- Constraints for table `token_balances`
--
ALTER TABLE `token_balances`
  ADD CONSTRAINT `fk_token_balances_user_id` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;

--
-- Constraints for table `token_ledger`
--
ALTER TABLE `token_ledger`
  ADD CONSTRAINT `fk_token_ledger_user_id` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;
